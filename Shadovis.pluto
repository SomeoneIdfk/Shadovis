-- @pluto_warnings disable-type-mismatch
-- @pluto_warnings disable-unreachable-code

script_start = false
local stand_version, game_version, lua_version, main_url, main_path = "24.9.4", "1.69-3323", "0.14-alpha", "https://raw.githubusercontent.com/SomeoneIdfk/Shadovis/main/", $"{filesystem.store_dir()}Shadovis\\"

for i = 1, 100 do
    if i == 100 then util.stop_script() end
    if menu.get_edition() == 0 then
        util.yield()
    else break end
end

if (comparison := compareversions(menu.get_version().game, game_version)) != 0 then
    if !SCRIPT_MANUAL_START or comparison == -1 then
        util.toast($"[SHADOVIS] This script was made for version {game_version}.\nCurrently Detected version: {menu.get_version().game}", TOAST_DEFAULT|TOAST_CONSOLE)
        util.stop_script()
    end
    local time = util.current_time_millis() + 500
    menu.show_warning(menu.my_root(), CLICK_MENU, $"This script was made for version {game_version}.\nCurrently Detected version: {menu.get_version().game}", function()
        if util.current_time_millis() < time then
            util.toast($"[SHADOVIS] This script was made for version {game_version}.\nCurrently Detected version: {menu.get_version().game}", TOAST_DEFAULT|TOAST_CONSOLE)
            repeat util.yield() until util.current_time_millis() >= time
        end
        script_start = true
    end, || -> util.stop_script())
elseif (comparison := compareversions(menu.get_version().version, stand_version)) != 0 then
    if SCRIPT_MANUAL_START and !SCRIPT_SILENT_START then
        util.toast($"[SHADOVIS] This script was made for version {stand_version}.\nCurrently Detected version: {menu.get_version().version}", TOAST_DEFAULT|TOAST_CONSOLE)
    end
    if comparison == -1 then
        util.stop_script()
    end
end



local start_time, crypto, url, json = util.current_time_millis(), require("pluto:crypto"), require("pluto:url"), require("pluto:json")
util.ensure_package_is_installed("lua/auto-updater")
local updater, update_config = require("auto-updater"), {script_relpath = SCRIPT_RELPATH, source_url = $"{main_url}Shadovis.pluto", dependencies = {}}
util.require_natives("3095a", "g")

-- assume we loaded the libraries for the first time so they're cached, then restart the script so it takes less time to load the libraries
if util.current_time_millis() - start_time > 50 then util.yield(3000) util.restart_script() return end

local start_time_values, menu_version = util.current_time_millis(), menu.get_edition()
local dev = players.exists(players.user()) ? players.get_rockstar_id(players.user()) == 0x9E69C8D or players.get_rockstar_id(players.user()) == 0xD1FF4D4 : false

local global_compatibility_mode = compareversions(menu.get_version().game, game_version) != 0
local successfulcommand, removedetectioncommand, removeplayercommand = lang.find_builtin("Command executed successfully. :)", "en"), lang.find_builtin("Click to remove this detection.", "en"), lang.find_builtin("Click to remove this player.", "en")
local previous_vehicle = {peds = {}, peds_2 = {}, driving_style = 0, autodrivespeed = 80}
local hashes = {}
commandrefs = {[1] = {}, [2] = {}, [3] = {}, [4] = {}, [5] = {}, [6] = {}}
local functions = {}
local tabpositions = {save = true, current = nil, self = nil, vehicle = nil, online = nil, players = nil, world = nil, game = nil, stand = nil}
player_list = {}
detections = {
    spoofinghosttoken = {name = "Spoofing Host Token", description = "", reason = "for manipulating the host queue", reactions = {note = "Spoofing Host Token", addnote = 3, blockjoins = 3, track = 3, block = 3, kick = 3, crash = 3}},
    loveletterblock = {name = "Blocking Love Letters", description = "If a player is not being kicked with a Love Letter kick, it's very likely the host is blocking them for that player.", severity = 80, options = {notify = 2, log = 4, console = 4, allchat = 4, teamchat = 4}, spam = 3},
    previouslyremoved = {name = "Previously Removed", description = "Just checks whether a player has been removed with this script or not.", reason = "for being removed previously", reactions = {timeout = 3, block = 2, kick = 2, crash = 3}},
    followingyou = {name = "Following You", description = "Checks if someone might be potentially following you into sessions.", severity = 25, reason = "for following you", options = {notify = 2, log = 4, console = 4, allchat = 4, teamchat = 4}, reactions = {note = "Following You", addnote = 2, blockjoins = 3, track = 3, timeout = 3, block = 2, kick = 3, crash = 3}, spam = 1},
    attackingwhilegodmode = {name = "Attacking While Godmode", description = "If the target is using anti detections, this won't detect them.", severity = 0, reason = "for attacking while godmode", options = {notify = 2, log = 4, console = 4, allchat = 4, teamchat = 4}, reactions = {note = "Attacking While Godmode", addnote = 3, blockjoins = 3, track = 3, timeout = 3, block = 3, kick = 3, crash = 3}, spam = 3},
    killedsomeonewhilegodmode = {name = "Killed Someone While Godmode", description = "Attempts to check if someone is killing others in godmode. This could potentially false positive but unless it's like a specific rc I doubt it'll happen.", severity = 80, reason = "for killing someone while godmode", options = {notify = 2, log = 4, console = 4, allchat = 4, teamchat = 4}, reactions = {note = "Killed Someone While Godmode", addnote = 3, blockjoins = 3, track = 3, timeout = 3, block = 3, kick = 3, crash = 3}, spam = 2},
    undeadotr = {name = "Undead OTR", description = "If someone is undead to be Off The Radar.", severity = 100, options = {notify = 2, log = 4, console = 4, allchat = 4, teamchat = 4}, reactions = {note = "Undead OTR", addnote = 3, timeout = 3, block = 3}, spam = 3},
    teleportedonyou = {name = "Teleported On You", description = "This will likely false positive or not even work all the time, I tried okay?", severity = 70, reason = "for teleporting on you", options = {notify = 2, log = 4, console = 4, allchat = 4, teamchat = 4}, reactions = {note = "Teleported On You", addnote = 3, blockjoins = 3, track = 3, timeout = 3, block = 3, kick = 3, crash = 3}, spam = 2},
    blockingvehicletakeover = {name = "Blocking Vehicle Takeover Request", description = "Whether or not you can take control of their vehicle.", severity = 25, options = {notify = 2, log = 4, console = 4, allchat = 4, teamchat = 4}, spam = 3},
    shadovisdev = {name = "Shadovis Developer", description = "", severity = 0, options = {notify = 3, log = 4, console = 4, allchat = 4, teamchat = 4}, spam = 1},
    kickevent = {name = "Kick Event", description = "", reason = "for sending a kick event", reactions = {note = "Kick Event", addnote = 3, blockjoins = 3, track = 3, timeout = 3, block = 3, kick = 3, crash = 3}},
    crashevent = {name = "Crash Event", description = "", reason = "for sending a crash event", reactions = {note = "Crash Event", addnote = 3, blockjoins = 3, track = 3, timeout = 3, block = 3, kick = 3, crash = 3}},
    maliciousevents = {name = "Malicious Events", description = "If a player trips a \"malicious\" event.", reason = "for sending a malicious event", reactions = {note = "Malicious Events", addnote = 3, blockjoins = 3, track = 3, timeout = 3, block = 3, kick = 3, crash = 3}},
    ipmatch = {name = "IP Match", description = "", severity = 0, options = {notify = 2, log = 4, console = 4, allchat = 4, teamchat = 4}, reactions = {[1] = true}, spam = 3},
    fuckchatreactions = {name = "Fuck Chat Reactions", description = "If someone announces in chat about what events/detections they got.\nThis only works on text that is basically the same as Stands.", reason = "for being a little bitch with chat reactions", reactions = {timeout = 3, kick = 3, crash = 3}},
    hostshare = {name = "HostShareâ„¢", description = "This will only trigger if you're kicking players.", severity = 100, options = {notify = 2, log = 4, console = 4, allchat = 4, teamchat = 4}, spam = 3},
    altaccounts = {name = "Alt Account", description = "", severity = 25, options = {notify = 2, log = 4, console = 4, allchat = 4, teamchat = 4}, reactions = {note = "Alt Account", addnote = 3, track = 3}, spam = 2},
    tranq = {name = "Tranquilizer", description = "", severity = 100, options = {notify = 1, log = 4, console = 4, allchat = 4, teamchat = 4}, spam = 3}
}
ignored_detections, generic_detections = {"Shadovis Developer", "Stand User", "Blocking Love Letters", "Rockstar Anti Cheat"}, {}
local all_detections, malicious_events = {[1] = "Bypassed Message Filter"}, {}
local queues = {}
local kicks = {nonhostashost = {[1] = {name = "Smart", description = "Removes the player by any means necessary.", cooldown = 15}, [2] = {name = "Blacklist", description = "Acts like a vote kick, but kicks like a desync.", cooldown = 5}, [3] = {name = "Host", description = "Kicks the player using the vote kick mechanism.\nUnblockable when you are the host.", cooldown = 15}, [4] = {name = "Love Letter", description = "Unblockable when you are the host.", cooldown = 10}, [5] = {name = "Orgasm", description = "Blocked by popular menus.", cooldown = 10}}, hostasnonhost = {[1] = {name = "Smart", description = "Removes the player by any means necessary.", cooldown = 15}, [2] = {name = "Pool's Closed", description = "Blocked by popular menus.", cooldown = 15}, [3] = {name = "Host", description = "Kicks the player using the vote kick mechanism.", cooldown = 15}, [4] = {name = "Non-Host", description = "Blocked by most menus.", cooldown = 15}}, nonhostasnonhost = {[1] = {name = "Smart", description = "Removes the player by any means necessary.", cooldown = 15}, [2] = {name = "Love Letter", description = "Can be blocked if the host is blocking them for you.", cooldown = 15}, [3] = {name = "Orgasm", description = "Blocked by popular menus.", cooldown = 10}, [4] = {name = "Host", description = "Kicks the player using the vote kick mechanism.", cooldown = 15}}}
local crashes = {[menu_version > 1 ? 2 : 1] = {name = "Elegant", description = "If this crash doesn't work, it's unlikely the others will.", cooldown = 5}}
local all_players = {}
local killreactions = {
    [1] = {
        [1] = {"gr", "good round", "wp", "well played", "*dab*", ":dab:", ";((", "i think you did really well there"},
        [2] = {"how bad are you, _victimname_", "clipped", "n1", "nice one", "ez", "wow, didnt even hit me, _victimname_", "easy", "2bad4me", "2fast4u", "get a refund, _victimname_", "this is my game. you are bad, and i do not allow you to play this game", "oof 1", "get better bozo", "scrub", "get on my level _victimname_", "you missed", "more bad please", "so mad", "uninstall", "missed again", "i would say your aim is cancer _victimname_, however cancer kills people", "rip bozo smoking on that _victimname_ pack", "a stormtrooper has better aim then you _victimname_", "go rq already nn", "u suck hard so sit down dog", "sit down nn dog", "you look very submissive and breedable _victimname_"},
        [3] = {"Visit _linkad_ for the finest public GTAV cheat", "Stop being a noob! Get good with _linkad_", "I'm not using _linkad_, you're just bad", "You just got pwned by _menuad_, the #1 GTAV cheat", "If I was cheating, I'd use _linkad_", "Think you could do better? Not without _menuad_"}
    },
    [2] = {
        [1] = {"gr", "good round", "ns", "nice shot", "uhh", ";((", "*ded*", "i think you did really well there"},
        [2] = {"kys", "saddd", "so mad", "_ip_", "_geoip_", "_ip_ : _geoip_", "get the fuck out monkey, _victimname_"},
        [3] = {"_linkad_", "_menuad_"}
    },
    [3] = {[1] = {name = "Stand", link = "stand.gg"}, [2] = {name = "2Take1", link = "2take1.menu"}, [3] = {name = "NewWay", link = "newwaymenu.com"}, [4] = {name = "Soviet", link = "sovietcheats.com"}, [5] = {name = "X-Force", link = "xforce.menu"}, [6] = {name = "Rebound", link = "reboundcheats.org"}, [7] = {name = "ASSOS", link = "assos.menu"}, [8] = {name = "MidNight", link = "midnight.im"}, [9] = {name = "Cherax", link = "cherax.menu"}, [10] = {name = "Lexis", link = "lexis.re"}}
}
local ptfx_effects = {full = {}, small = {}}
local vehicle_bones = {"wheel_lf", "wheel_lr", "wheel_rf", "wheel_rr", "wheel_lm1", "wheel_rm1", "wheel_lm2", "wheel_rm2", "wheel_lm3", "wheel_rm3", "engine", "overheat", "exhaust"}
local spectateplayer, tploopplayer, spooftoplayer, orgplayer;
local session, kleptomaniac, cam, cam_lock, cam_active, gender = 0, 1, nil, true, false, -1
local fake_commandref = {}
local global_memory_for_compatibility, global_cache = {}, {}
globals = {}
local initialize_globals = {
    [1] = { -- Global_2657971[PLAYER::PLAYER_ID() /*465*/].f_233 (freemode.c) [spawn state]
        memory_type = "integer",
        default_value = 0,
        argument = true,
        tunable = false,
        script_global = function(integer: int): int
            return 2657971 + 1 + integer * 465 + 233
        end
    },
    [2] = { -- Global_2657971[bVar0 /*465*/].f_246 (jinxscript.pluto) [interior id]
        memory_type = "integer",
        default_value = 0,
        argument = true,
        tunable = false,
        script_global = function(integer: int): int
            return 2657971 + 1 + integer * 465 + 246
        end
    },
    [3] = { -- Global_1887305[PLAYER::PLAYER_ID() /*610*/].f_8 (freemode.c) [passive mode but also ghosted?]
        memory_type = "integer",
        default_value = 0,
        argument = true,
        tunable = false,
        script_global = function(integer: int): int
            return 1887305 + 1 + integer * 610 + 8
        end
    },
    [4] = { -- Global_1845281[PLAYER::PLAYER_ID() /*883*/].f_268.f_35 (freemode.c) [apartment id]
        memory_type = "integer",
        default_value = -1,
        argument = true,
        tunable = false,
        script_global = function(integer: int): int
            return 1845281 + 1 + integer * 883 + 268 + 35
        end
    },
    [5] = { -- 1575011 (jinxscript.pluto) [transition state]
        memory_type = "integer",
        default_value = 66,
        argument = false,
        tunable = false,
        script_global = function(): int
            return 1575011
        end
    },
    [6] = { -- XP_MULTIPLIER (tuneables_processing.c) [xp multiplier]
        memory_type = "float",
        default_value = 1.0,
        argument = false,
        tunable = true,
        script_global = function(): string
            return "XP_MULTIPLIER"
        end
    },
    [7] = { -- Global_1057440 (freemode.c) [job queue state]
        memory_type = "integer",
        default_value = 0,
        argument = false,
        tunable = false,
        script_global = function(): int
            return 1057440
        end
    },
    [8] = { -- Global_2657971[PLAYER::PLAYER_ID() /*465*/].f_38 (freemode.c) [personal vehicle]
        memory_type = "integer",
        default_value = 0,
        argument = true,
        tunable = false,
        script_global = function(integer: int): int
            return 2657971 + 1 + integer * 465 + 38
        end
    },
    [9] = { -- Global_1887305[PLAYER::PLAYER_ID() /*610*/].f_10.f_430 (freemode.c) [org type]
        memory_type = "integer",
        default_value = 0,
        argument = true,
        tunable = false,
        script_global = function(integer: int): int
            return 1887305 + 1 + integer * 610 + 10 + 430
        end
    },
    [10] = { -- Global_1887305[PLAYER::PLAYER_ID() /*610*/].f_10 (freemode.c) [org boss]
        memory_type = "integer",
        default_value = 0,
        argument = true,
        tunable = false,
        script_global = function(integer: int): int
            return 1887305 + 1 + integer * 610 + 10
        end
    },
    [11] = { -- Global_2648938.f_818.f_11[iParam0] (freemode.c) [org slot]
        memory_type = "integer",
        default_value = 0,
        argument = true,
        tunable = false,
        script_global = function(integer: int): int
            integer = players.get_boss(integer)
            return 2648938 + 818 + 11 + 1 + integer
        end
    },
    [12] = { -- Global_2648938.f_818.f_44[iParam1 /*2*/].f_1 (freemode.c) [org colour]
        memory_type = "integer",
        default_value = -1,
        argument = true,
        tunable = false,
        script_global = function(integer: int): int
            integer = memory.read_int(globals[11](integer))
            return 2648938 + 818 + 44 + 1 + integer * 2 + 1
        end
    },
    [13] = { -- Global_2647061[iVar0] (freemode.c) [blip id]
        memory_type = "integer",
        default_value = 0,
        argument = true,
        tunable = false,
        script_global = function(integer: int): int
            return 2647061 + 1 + integer
        end
    },
    [14] = { -- Global_2657971[bParam0 /*465*/].f_74.f_2
        memory_type = "short",
        default_value = 0,
        argument = true,
        tunable = false,
        script_global = function(integer: int): int
            return 2657971 + 1 + integer * 465 + 74 + 2
        end
    }
}
local afk = nil
local allocated_memory = {[1] = memory.alloc(8), [2] = memory.alloc_int(), [3] = memory.alloc(), [4] = memory.alloc_int(), [5] = memory.alloc(1), [6] = memory.alloc_int(), [7] = memory.alloc_int(), [8] = memory.alloc(13 * 8)}
local tick_handlers = {commandref_positions = {}, player_main = {}, player_teleport = {}, player_death = {}, detection_memory = {}, vehicle = {}, session = {}, vks = {filelisttime = 0, fileupdatetimes = {}}}
local my_chat_messages = {}
local module_functions = {        -- you can look at modules I made to understand this mess lmao
    loaded = {}, autoload = {}, -- this is not something modules will have access to.
    start = {},                 -- will have a bool for "loading" the module and the module root as arguments, this would be where you create commandrefs.
    stop = {},                  -- will have a bool for script stop and the module root (if script stop is false) as arguments, if you created any commandrefs this is the place to delete them.
    on_spawn = {},              -- will have a player id passed as an argument.
    on_death = {},              -- will have a player id passed as an argument.
    on_damage = {},             -- will have the killed player, player killer, died, weapon hash and damage passed as arguments.
    driving_vehicle = {},       -- will have a vehicle passed as an argument.
    on_join = {},               -- will have a player id and player root passed as an argument, along with any created lists.
    on_leave = {},              -- will have a player id passed as an argument.
    on_tick = {},               -- will have a player id passed as an argument.
    on_detection = {},          -- will have a player id, detection, and identifier passed as an argument.
    transition_finished = {}    -- wont have any arguments passed down to it.
    --[[
        you can also pass down a few arguments that will stop the lua from running in certain scenarios
        minimum_shadovis_version = "0.14"
        maximum_shadovis_version = "0.14"
        minimum_stand_version = "116"
        maximum_stand_version = "116.4"
        recommended_game_version = "1.69-3258"
        globals_upto_date = true / requires global_compatibility_mode to be false (out of date globals)
    ]]
}
local virtual_keycodes = {{"", 0x41, "A"}, {"", 0x42, "B"}, {"", 0x43, "C"}, {"", 0x44, "D"}, {"", 0x45, "E"}, {"", 0x46, "F"}, {"", 0x47, "G"}, {"", 0x48, "H"}, {"", 0x49, "I"}, {"", 0x4A, "J"}, {"", 0x4B, "K"}, {"", 0x4C, "L"}, {"", 0x4D, "M"}, {"", 0x4E, "N"}, {"", 0x4F, "O"}, {"", 0x50, "P"}, {"", 0x51, "Q"}, {"", 0x52, "R"}, {"", 0x53, "S"}, {"", 0x54, "T"}, {"", 0x55, "U"}, {"", 0x56, "V"}, {"", 0x57, "W"}, {"", 0x58, "X"}, {"", 0x59, "Y"}, {"", 0x5A, "Z"}, {"", 0x30, "0"}, {"", 0x31, "1"}, {"", 0x32, "2"}, {"", 0x33, "3"}, {"", 0x34, "4"}, {"", 0x35, "5"}, {"", 0x36, "6"}, {"", 0x37, "7"}, {"", 0x38, "8"}, {"", 0x39, "9"}, {"VK_LBUTTON", 0x01, "Left Mouse"}, {"VK_RBUTTON", 0x02, "Right Mouse"}, {"VK_MBUTTON", 0x04, "Middle Mouse"}, {"VK_XBUTTON1", 0x05, "X1 Mouse"}, {"VK_XBUTTON2", 0x06, "X2 Mouse"}, {"VK_SPACE", 0x20, "Spacebar"}, {"VK_LCONTROL", 0xA2, "Left Control"}, {"VK_RCONTROL", 0xA3, "Right Control"}}
local virtual_keycode_states = {}
local colours = {bullettracers = {r = 1, g = 1, b = 1, a = 1}, autodrive = {r = 1, g = 1, b = 1, a = 1}, autodriveoutline = {r = 0, g = 0, b = 0, a = 1}, scripthost = {r = 1, g = 1, b = 1, a = 1}, scripthostoutline = {r = 0, g = 0, b = 0, a = 1}, modernspectate = {r = 1, g = 1, b = 1, a = 1}, modernspectateoutline = {r = 0, g = 0, b = 0, a = 1}, thirdeye = {r = 1, g = 1, b = 1, a = 1}, thirdeyeoutline = {r = 0, g = 0, b = 0, a = 1}, skeleton = {r = 1, g = 1, b = 1, a = 1}, skeletonesp = {r = 1, g = 1, b = 1, a = 1}, playerespvisible = {r = 0, g = 1, b = 0, a = 1}, playeresphidden = {r = 1, g = 0, b = 0, a = 1}, playeresphpbar = {r = 0, g = 1, b = 0, a = 1}, playeresphpbarbackground = {r = 1, g = 0, b = 0, a = 1}}
local modder_types = {[1] = {name = "Modder", value = true}, [2] = {name = "Likely Modder", value = true}, [3] = {name = "Possible Modder", value = false}}
local languages = {[1] = {name = "Afrikaans", key = "af", ignore = false}, [2] = {name = "Albanian", key = "sq", ignore = false}, [3] = {name = "Arabic", key = "ar", ignore = false}, [4] = {name = "Azerbaijani", key = "az", ignore = false}, [5] = {name = "Basque", key = "eu", ignore = false}, [6] = {name = "Belarusian", key = "be", ignore = false}, [7] = {name = "Bengali", key = "bn", ignore = false}, [8] = {name = "Bulgarian", key = "bg", ignore = false}, [9] = {name = "Catalan", key = "ca", ignore = false}, [10] = {name = "Chinese Simplified", key = "zh-cn", ignore = false}, [11] = {name = "Chinese Traditional", key = "zh-tw", ignore = false}, [12] = {name = "Croatian", key = "hr", ignore = false}, [13] = {name = "Czech", key = "cs", ignore = false}, [14] = {name = "Danish", key = "da", ignore = false}, [15] = {name = "Dutch", key = "nl", ignore = false}, [16] = {name = "English", key = "en", ignore = false}, [17] = {name = "Esperanto", key = "eo", ignore = false}, [18] = {name = "Estonian", key = "et", ignore = false}, [19] = {name = "Filipino", key = "tl", ignore = false}, [20] = {name = "Finnish", key = "fi", ignore = false}, [21] = {name = "French", key = "fr", ignore = false}, [22] = {name = "Galician", key = "gl", ignore = false}, [23] = {name = "Georgian", key = "ka", ignore = false}, [24] = {name = "German", key = "de", ignore = false}, [25] = {name = "Greek", key = "el", ignore = false}, [26] = {name = "Gujarati", key = "gu", ignore = false}, [27] = {name = "Haitian Creole", key = "ht", ignore = false}, [28] = {name = "Hebrew", key = "iw", ignore = false}, [29] = {name = "Hindi", key = "hi", ignore = false}, [30] = {name = "Hungarian", key = "hu", ignore = false}, [31] = {name = "Icelandic", key = "is", ignore = false}, [32] = {name = "Indonesian", key = "id", ignore = false}, [33] = {name = "Irish", key = "ga", ignore = false}, [34] = {name = "Italian", key = "it", ignore = false}, [35] = {name = "Japanese", key = "ja", ignore = false}, [36] = {name = "Kannada", key = "kn", ignore = false}, [37] = {name = "Korean", key = "ko", ignore = false}, [38] = {name = "Latin", key = "la", ignore = false}, [39] = {name = "Latvian", key = "lv", ignore = false}, [40] = {name = "Lithuanian", key = "lt", ignore = false}, [41] = {name = "Macedonian", key = "mk", ignore = false}, [42] = {name = "Malay", key = "ms", ignore = false}, [43] = {name = "Maltese", key = "mt", ignore = false}, [44] = {name = "Norwegian", key = "no", ignore = false}, [45] = {name = "Persian", key = "fa", ignore = false}, [46] = {name = "Polish", key = "pl", ignore = false}, [47] = {name = "Portuguese", key = "pt", ignore = false}, [48] = {name = "Romanian", key = "ro", ignore = false}, [49] = {name = "Russian", key = "ru", ignore = false}, [50] = {name = "Serbian", key = "sr", ignore = false}, [51] = {name = "Slovak", key = "sk", ignore = false}, [52] = {name = "Slovenian", key = "sl", ignore = false}, [53] = {name = "Spanish", key = "es", ignore = false}, [54] = {name = "Swahili", key = "sw", ignore = false}, [55] = {name = "Swedish", key = "sv", ignore = false}, [56] = {name = "Tamil", key = "ta", ignore = false}, [57] = {name = "Telugu", key = "te", ignore = false}, [58] = {name = "Thai", key = "th", ignore = false}, [59] = {name = "Turkish", key = "tr", ignore = false}, [60] = {name = "Ukrainian", key = "uk", ignore = false}, [61] = {name = "Urdu", key = "ur", ignore = false}, [62] = {name = "Vietnamese", key = "vi", ignore = false}, [63] = {name = "Welsh", key = "cy", ignore = false}, [64] = {name = "Yiddish", key = "yi", ignore = false}}
screen_dimensions = {x = 0, y = 0}
http, sc = {}, {}
local interiors = {
    hairdressers = {165377, 140545, 155905, 171009, 198657, 180225, 199937},
    clothingshops = {179713, 183553, 175361, 201473, 202497, 176129, 166145, 165633, 140801, 169217, 171265, 137217, 198145, 235265},
    shops = {184065, 183809, 200449, 199169, 203265, 204801, 178945, 175873, 177153, 176641, 175105, 139777, 155649, 168449, 170753, 167937, 154113, 196865, 198401},
    gunshops = {153857, 168193, 164609, 140289, 178689, 176385, 175617, 200961, 180481, 248065, 137729},
    tattooshops = {251137, 171521, 140033, 176897, 199425, 180737},
    lscs = {179457, 201729, 234753, 153601, 164353}
}
local macros, sounds, outfits, modules = {}, {}, {}, {}
local sound_management = {
    device = soup.audDevice.getDefault(),
    mixer = soup.audMixer(),
    instances = {}
}
local ped_transformations = {}
local script_root_path, active_profile = "Stand>Lua Scripts", ""
package.path = $"{package.path};{main_path}?.pluto;{main_path}?.lua;{main_path}Modules\\?.lua;{main_path}Modules\\?.pluto"
local blur_instances = {[1] = directx.blurrect_new()}
local weapon_list = util.get_weapons()
local patterns = {
    SCI = "48 8B D3 48 8D 4C 24 ? 48 69 D2"
}
local scauth = {pointer = nil, ticket = nil}
local ihatebe = {player_id = nil, sss = nil, wsc = nil, ss = nil, sc = nil}



function read_file(path: string, default_response: ?string = ""): string
    return filesystem.exists(path) and filesystem.is_regular_file(path) and io.contents(path) or default_response
end

function write_file(path: string, content: string): bool
    return !filesystem.is_regular_file(path) or filesystem.is_regular_file(path) ? io.contents(path, content) or true : false 
end

for index, data in initialize_globals do
    global_cache[index], global_memory_for_compatibility[index] = data.argument ? {} : nil, memory.alloc(4)
    globals[index] = function(argument)
        if global_compatibility_mode then
            memory[data.memory_type == "integer" ? "write_int" : data.memory_type == "float" ? "write_float" : data.memory_type == "short" ? "write_short" : ""](global_memory_for_compatibility[index], data.default_value)
            return global_memory_for_compatibility[index]
        end

        if data.argument and !data.tunable and type(global_cache[index][argument]) != "integer" then
            global_cache[index][argument] = memory.script_global(data.script_global(argument))
        elseif (!data.argument or data.tunable) and type(global_cache[index]) != "integer" then
            global_cache[index] = data.tunable ? memory.tunable(data.script_global()) : memory.script_global(data.script_global())
        end
        return data.argument ? global_cache[index][argument] : global_cache[index]
    end
end

for {
    {"ptfx_list.txt", "ptfx.txt"},
    {"ped_transformations.txt", "ped_transformations.txt"},
    {"macros/drop_bst.txt", "Macros/Drop BST.txt"},
    {"macros/equip_armor.txt", "Macros/Equip Armor.txt"},
    {"macros/ewo.txt", "Macros/Ewo.txt"},
    {"macros/ghost_organization.txt", "Macros/Ghost Organization.txt"},
    {"macros/refill_ammo.txt", "Macros/Refill Ammo.txt"},
    {"macros/register_ceo.txt", "Macros/Register CEO.txt"},
    {"macros/retire.txt", "Macros/Retire.txt"},
    {"macros/toggle_helmet_thermal.txt", "Macros/Toggle Helmet Thermal.txt"},
    {"macros/toggle_passive_mode.txt", "Macros/Toggle Passive Mode.txt"},
    {"sounds/pew_pew.wav", "Sounds/Pew-Pew.wav"},
    {"sounds/bell.wav", "Sounds/Bell.wav"},
    {"sounds/arena_switch.wav", "Sounds/Arena Switch.wav"}
} as depency do
    update_config.dependencies[#update_config.dependencies + 1] = {source_url = $"{main_url}{depency[1]}", script_relpath = $"store\\Shadovis\\{depency[2]}", silent_updates = true, auto_restart = false}
end

for {"Macros", "Modules", "Sounds"} as folder do
    filesystem.mkdirs($"{main_path}{folder}")
end

do
    local parts = SCRIPT_RELPATH:split("\\")
    for i = 1, #parts - 1 do
        script_root_path = $"{script_root_path}>{parts[i]}"
    end
    script_root_path = $"{script_root_path}>{SCRIPT_NAME}"

    for path, value in util.read_colons_and_tabs_file($"{filesystem.stand_dir()}\\Meta State.txt") do
        if path != "Load On Inject" then continue end
        active_profile = value
    break end
    
    if active_profile != "" and filesystem.exists($"{filesystem.stand_dir()}\\Profiles\\{active_profile}.txt") and filesystem.is_regular_file($"{filesystem.stand_dir()}\\Profiles\\{active_profile}.txt") then
        for path, value in util.read_colons_and_tabs_file($"{filesystem.stand_dir()}\\Profiles\\{active_profile}.txt") do
            if value != "On" or !path:startswith($"{script_root_path}>Modules>") or !path:endswith(">Auto-Load") then continue end
            module_functions.autoload[path:gsub($"{script_root_path}>Modules>", ""):rstrip(">Auto-Load")] = {}
        end

        for path, value in util.read_colons_and_tabs_file($"{filesystem.stand_dir()}\\Profiles\\{active_profile}.txt") do
            if value == "" or !path:startswith($"{script_root_path}>Modules>") or path:endswith(">Auto-Load") then continue end
            local module = path:gsub($"{script_root_path}>Modules>", ""):split(">")[1]
            if module_functions.autoload[module] == nil then continue end
            module_functions.autoload[module][path:gsub($"{script_root_path}>Modules>{module}>", "")] = value
        end
    elseif active_profile == "" then
        util.toast("[SHADOVIS] Failed to find active profile.", !SCRIPT_SILENT_START ? TOAST_DEFAULT|TOAST_CONSOLE : 0)
    end
end

if filesystem.exists($"{main_path}fake_friends.txt") and filesystem.is_regular_file($"{main_path}fake_friends.txt") and !(filesystem.exists($"{main_path}players.txt") and filesystem.is_regular_file($"{main_path}players.txt")) then
    local fakefriends, playerinfo = json.decode(read_file($"{main_path}fake_friends.txt", "{}")), {}
    for fakefriends as fakefriend do
        playerinfo[fakefriend.rockstar_id] = {name = fakefriend.name, rockstar_id = fakefriend.rockstar_id, friend = true, blockjoin = false}
    end
    write_file($"{main_path}players.txt", json.encode(playerinfo, false))
end

local playerinfo = json.decode(read_file($"{main_path}players.txt", "{}"))
local possible_detections = json.decode(read_file($"{main_path}third_party_detections.txt", "{}"))

if filesystem.exists($"{main_path}ped_transformations.txt") and filesystem.is_regular_file($"{main_path}ped_transformations.txt") then
    for key, value in util.read_colons_and_tabs_file($"{main_path}ped_transformations.txt") do
        ped_transformations[key] = util.joaat(value)
    end
end

for dictionary, effects in json.decode(read_file($"{main_path}ptfx.txt", "{}")) do
    if type(ptfx_effects.full[dictionary]) != "table" then
        ptfx_effects.full[dictionary] = {}
    end
    for effects as effect do
        ptfx_effects.small[#ptfx_effects.small + 1], ptfx_effects.full[dictionary][#ptfx_effects.full[dictionary] + 1] = effect, effect
    end
end
ptfx_effects.small = table.sort(ptfx_effects.small, |a, b| -> a:lower() < b:lower())

if menu_version > 1 then
    crashes[1], crashes[3], crashes[4] = {name = "All", description = "Tries all crashes from most likely to least likely.", cooldown = 15}, {name = "Burger King Foot Lettuce", description = "", cooldown = 5}, {name = "Vehicular Manslaughter", description = "", cooldown = 15}
end
if menu_version > 2 then
    crashes[5] = {name = "Steamroller", description = "", cooldown = 10}
end

screen_dimensions.x, screen_dimensions.y = directx.get_client_size()

for menu.ref_by_path("Online>Protections>Events"):getChildren() as commandref do
    local full_name = lang.get_string(commandref.menu_name, "en")
    local name = string.match(full_name, "(.-)%s*%(") or full_name
    if !(name == "Modded Event" or name == "Unusual Event" or name == "Raw Network Events" or full_name == "Start Freemode Mission" or full_name == "Teleport To Interior" or full_name == "Give Collectible") then
        if !malicious_events:contains(name) then
            malicious_events[#malicious_events + 1] = name
        end
    end
    if !(name == "Raw Network Events" or full_name == "Start Freemode Mission" or full_name == "Teleport To Interior" or full_name == "Give Collectible") then
        if !all_detections:contains(name) then
            all_detections[#all_detections + 1] = name
        end
    end
end

for menu.ref_by_path("Online>Protections>Detections"):getChildren() as commandref do
    local full_name = lang.get_string(commandref.menu_name, "en")
    local name = string.match(full_name, "(.-)%s*%(") or full_name
    if full_name == "Classifications" or full_name == "Any Detection" or full_name == "Other User Identifications" or all_detections:contains(name) then continue end
    all_detections[#all_detections + 1] = name
end

function fake_commandref:isValid(): bool return false end
function fake_commandref:trigger(any: ?string|number|bool): void end

sound_management.mixer.stop_playback_when_done = true
for i = 1, 10 do
    sound_management.instances[#sound_management.instances + 1] = {file_path = nil, file_reader = nil, playback = nil}
end



local start_time_functions = util.current_time_millis()

local function hash_string(text: string): ?int
    if hashes[text] == nil then
        try
            local hash = crypto.djb2(text)
            hashes[text] = hash
        catch error then end
    end
    return hashes[text]
end

function io.fileextension(path: string): string
    path = path:contains("\\") ? {path:partition("\\", true)}[2] : path
    return path:contains(".") ? {path:partition(".", true)}[2] : path
end

function io.filename(path: string): string
    path = path:contains("\\") ? {path:partition("\\", true)}[2] : path
    return path:contains(".") ? {path:partition(".", true)}[1] : path
end


function math.round(number: number, decimal: ?int = 0): number
    return math.floor(number * (10 ^ decimal) + 0.5) / (10 ^ decimal)
end

function math.float_to_int(float: float): int
    return tonumber(tostring(float):split(".")[1])
end

function table.sort_by_name(strings: table): table
    return type(strings) == "table" ? table.sort(strings, function(string_1, string_2) return string_1:lower() < string_2:lower() end) : {}
end

function table.sort_by_number(numbers: table): table
    return type(numbers) == "table" ? table.sort(numbers, function(number_1, number_2) return number_1 < number_2 end) : {}
end

function table.combine_indexes(...lists): table
    if type(lists) != "table" then return {} end
    local new_list = {}
    for lists as list do
        for index, value in list do
            if type(new_list[index]) != "table" then
                new_list[index] = {}
            end
            new_list[index][#new_list[index] + 1] = value
        end
    end return new_list
end

function table.get_size(list: table, assume_at: ?int = 5): int -- i had to make this bullshit because :size() was falsely reporting a table size of 4 when it was 3.
    assume_at = assume_at < 5 ? 5 : assume_at
    local increments_by_one, previous_key, checked = true, nil, 0
    for key in list do
        ++checked
        increments_by_one = previous_key == nil or previous_key + 1 == key
        if !increments_by_one or checked >= assume_at then break end
        previous_key = key
    end
    return increments_by_one ? #list : list:size()
end

function menu.rbp(path: string, tree_version: ?int = 54): ?int
    switch commandrefs[1][path]?:isValid?() do
        case nil: case false:
            local commandref = menu.ref_by_path(path, tree_version)
            commandrefs[1][path] = commandref?:isValid?() ? commandref : nil
    end return commandrefs[1][path] or fake_commandref
end

function menu.rbrp(base: int, path: string): ?int
    if !base?:isValid?() then return fake_commandref end
    if commandrefs[2][base] == nil and base:isValid() then
        commandrefs[2][base] = {}
    end
    switch commandrefs[2][base][path]?:isValid?() do
        case nil: case false:
            local commandref = menu.ref_by_rel_path(base, path)
            commandrefs[2][base][path] = commandref?:isValid?() ? commandref : nil
    end
    return commandrefs[2][base][path] or fake_commandref
end

function menu.rbcn(command: string): ?int
    switch commandrefs[3][command]?:isValid?() do
        case nil: case false:
            if commandrefs[5][command] then break end
            commandrefs[5][command] = true
            functions.queue_function("rbcn", 1, function()
                local commandref = menu.ref_by_command_name(command)
                commandrefs[3][command], commandrefs[5][command] = commandref?:isValid?() ? commandref : nil, false
            end)
    end
    return commandrefs[3][command] or fake_commandref
end

function menu.pr(player_id: int): ?int
    if !players.exists(player_id) then return fake_commandref end
    switch commandrefs[6][player_id]?:isValid?() do
        case nil: case false:
            local commandref = menu.player_root(player_id)
            commandrefs[6][player_id] = commandref?:isValid?() ? commandref : nil
    end
    return commandrefs[6][player_id] or fake_commandref
end

function menu.table_to_list(list: ?table|string = {}, first_options: ?table|string = {}, last_options: ?table|string = {}): table
    local function a(a: ?table = {}, b: table|string)
        if type(b) == "string" then
            a[#a + 1] = {#a + 1, b}
        elseif type(b) == "table" then
            for b as c do
                if type(c) == "string" then
                    a[#a + 1] = {#a + 1, c}
                elseif type(c) == "table" then
                    a[#a + 1] = {#a + 1, c[1], type(c[2]) == "table" ? c[2] : {}, (type(c[2]) == "table" ? c[3] : c[2]) or ""}
                end
            end
        end
        return a
    end

    local new_list = a({}, first_options)
    new_list = a(new_list, list)
    new_list = a(new_list, last_options)
    return new_list
end

function menu.get_current_position(): int
    local commandref_list = menu.get_current_menu_list()
    local commandref_focused = menu.list_get_focus(commandref_list)
    return commandref_focused:isValid() ? commandref_focused : commandref_list
end

function menu.is_root(commandref: int): bool
    if !commandref?:isValid?() then return false end
    for {"Self", "Vehicle", "Online", "Players", "World", "Game", "Stand"} as root do
        if !commandref:equals(menu.rbp(root)) then continue end
        return true
    end return false
end

function menu.get_commandref_tab(commandref: int): ?string
    if !commandref?:isValid?() then return end
    for i = 1, 50 do -- artificial limit incase it ever goes wrong, nobody would actually nest 50 list options anyways
        commandref = commandref?:getParent?()
        if !commandref?:isValid?() then break end
        if !menu.is_root(commandref) then continue end
        return lang.get_string(commandref.menu_name, "en"):lower(1)
    end return "self"
end

function menu.focus_on_commandref(commandref: int, method: int, delay: ?int = 0, callback: ?function = function() end): void
    if !commandref:isValid() then return end
    tabpositions.save = false
    local current_commandref, tab_commandref = menu.get_current_position(), menu.get_commandref_tab(commandref)
    if method == 1 then
        commandref:focus()
    elseif method == 2 then
        commandref:trigger()
    end
    if delay != 0 then util.yield(delay) end
    callback()
    if tabpositions[tab_commandref]?:isValid?() then
        tabpositions[tab_commandref]:focus()
    end
    if current_commandref:isValid() then
        current_commandref:focus()
    elseif menu.get_commandref_tab(current_commandref) then
        tabpositions[menu.get_commandref_tab(current_commandref)]:focus()
    end
    tabpositions.save = true
end

function menu.ref_player_history(name: string): ?int
    return menu.rbp($"Online>Player History>{name}")
end

function memory.add(address: int, value: int, memory_type: ?string = "int"): void
    memory[$"write_{memory_type}"](address, memory[$"read_{memory_type}"](address) | value)
end

function memory.subtract(address: int, value: int, memory_type: ?string = "int"): void
    memory[$"write_{memory_type}"](address, memory[$"read_{memory_type}"](address) & ~value)
end

function util.notify(input: string|int, log: ?bool = false, console: ?bool = false, toast: ?bool = true): void
    input = type(input) == "number" and lang.get_string(input, "en") != "/!\\ STRING NOT FOUND /!\\" ? lang.get_string(input, "en") : input
    util.toast(input, (log ? TOAST_FILE : 0) | (console ? TOAST_CONSOLE : 0) | (toast and commandrefs[4].notificationmasterswitch.value ? TOAST_DEFAULT : 0))
end

function util.is_script_running(hash: string|int): bool
    hash = type(hash) == "string" ? util.joaat(hash) : hash
    return GET_NUMBER_OF_THREADS_RUNNING_THE_SCRIPT_WITH_THIS_HASH(hash) > 0
end

function util.in_session(): bool
    return !util.is_session_transition_active() and util.is_session_started() and NETWORK_IS_IN_SESSION()
end

function util.in_sp(): bool
    return !(util.is_session_transition_active() or util.is_session_started() or NETWORK_IS_IN_SESSION() or util.is_script_running("freemode"))
end

function util.in_heist(): bool
    return util.is_script_running("fm_mission_controller") or util.is_script_running("fm_mission_controller_2020") or players.get_interior_id(players.user()) == 276993
end

function util.in_activity(freemode_activies: ?bool = false): bool
    for {"fm_bj_race_controler", "fm_deathmatch_controler", "fm_hideout_controler", "fm_horde_controler", "fm_race_controler", "fm_survival_controller"} as activity do
        if !util.is_script_running(activity) then continue end
        return true
    end
    return util.in_heist() or freemode_activies and NETWORK_IS_ACTIVITY_SESSION()
end

function util.on_call(): bool
    return util.is_script_running("freemode") and memory.read_int(globals[7]()) == 21
end

function util.wait_time(time: int, callback: ?function = function() return false end, milli: ?bool = false): bool
    local target = util.current_time_millis() + (milli ? time : time * 1000)
    while util.current_time_millis() < target do
        if callback() then return false end
        util.yield()
    end
    return true
end

function util.get_lowest_ground_z(x: float, y: float, z_hint: ?float = 1000.0, z_limit: ?float = -200.0, depth: ?int = 5) -- probably overhaul this function lmao
    local lowest_z, state, new_z = z_hint, true, -200
    for i = 1, depth do
        REQUEST_COLLISION_AT_COORD(x, y, lowest_z)
        state, new_z = util.get_ground_z(x, y, lowest_z)
        if new_z < z_limit then
            if lowest_z == z_hint then
                lowest_z = new_z
            end
            break
        end
        if state then
            lowest_z = new_z
        else break end
    end
    return lowest_z
end

function util.is_key_pressed(key: string|int): ?bool
    for virtual_keycodes as vk do
        if type(key) == "number" and vk[2] == key or type(key) == "string" and vk[1] ~= "" and vk[1]:lower() == key:lower() or type(key) == "string" and vk[3]:lower() == key:lower() then
            return virtual_keycode_states[vk[2]].current
        end
    end
end

function util.is_key_just_pressed(key: string|int): ?bool
    for virtual_keycodes as vk do
        if type(key) == "number" and vk[2] == key or type(key) == "string" and vk[1] ~= "" and vk[1]:lower() == key:lower() or type(key) == "string" and vk[3]:lower() == key:lower() then
            return (!virtual_keycode_states[vk[2]].previous and virtual_keycode_states[vk[2]].current)
        end
    end
end

function util.is_key_just_released(key: string|int): ?bool
    for virtual_keycodes as vk do
        if type(key) == "number" and vk[2] == key or type(key) == "string" and vk[1] ~= "" and vk[1]:lower() == key:lower() or type(key) == "string" and vk[3]:lower() == key:lower() then
            return (virtual_keycode_states[vk[2]].previous and !virtual_keycode_states[vk[2]].current)
        end
    end
end

function util.get_screen_position(coords: userdata): bool|float
    return util.get_screen_coord_from_world_coord_no_adjustment(coords.x, coords.y, coords.z, allocated_memory[1], allocated_memory[1] + 4), memory.read_float(allocated_memory[1]), memory.read_float(allocated_memory[1] + 4)
end

function util.raycast(coords_1: userdata, coords_2: userdata, ignore_entity: ?int = 0, ray_type: ?int = 1, flags: ?int = 511): ?table -- ray_type 1 seems to not be able to pass vehicle glass, 2 does.
    local raycast_int, hit_coords, coords_normal = START_EXPENSIVE_SYNCHRONOUS_SHAPE_TEST_LOS_PROBE(coords_1, coords_2, flags, ignore_entity, ray_type), v3.new(), v3.new()
    GET_SHAPE_TEST_RESULT(raycast_int, allocated_memory[5], hit_coords, coords_normal, allocated_memory[6])
    local result = {hit = memory.read_int(allocated_memory[5]) == 1, hit_coords = hit_coords, coords_normal = coords_normal, hit_entity = memory.read_int(allocated_memory[6])}
    return result
end

function players.get_interior_id(player_id: int): int
    return NETWORK_IS_PLAYER_ACTIVE(player_id) ? memory.read_int(globals[2](player_id)) : 0
end

function players.get_orgs(): table
    local player_ids = {}
    for players.list() as player_id do
        if players.get_boss(player_id) != player_id then continue end
        player_ids[#player_ids + 1] = player_id
    end
    return player_ids
end

function players.get_ped(player_id: int): ?int
    return players.exists(player_id) ? GET_PLAYER_PED_SCRIPT_INDEX(player_id) : nil
end

function players.in_interior(player_id: int, ignore_things_like_shops: ?bool = false): bool
    if !players.exists(player_id) then return false end
    local interior = players.get_interior_id(player_id)
    for interiors as interior_list do
        if ignore_things_like_shops then break end
        for interior_list as interior_id do
            if interior != interior_id then continue end
        return false end
    end
    for {0, 233985, 169473, 169729, 169985, 170241, 177665, 177409, 185089, 184833, 184577, 163585, 167425, 167169, 138241} as interior_id do
        if interior != interior_id then continue end
    return false end
    return players.is_in_interior(player_id)
end

function players.in_transition(player_id: int): bool
    return players.exists(player_id) and !IS_PLAYER_DEAD(player_id) and (memory.read_int(globals[1](player_id)) == 0)
end

function players.cam_in_clouds(player_id: int): bool -- a really shitty function that barely works ngl
    return players.exists(player_id) and players.get_spectate_target(player_id) == -1 ? v3.distance(v3.setZ(players.get_position(player_id), players.get_cam_pos(player_id).z), players.get_cam_pos(player_id)) <= 15 and v3.distance(players.get_position(player_id), players.get_cam_pos(player_id)) >= 200 : false
end

function players.get_vehicle(player_id: int, driver: ?bool = false): ?int
    if !players.exists(player_id) then return end
    local ped = players.get_ped(player_id)
    local vehicle = GET_VEHICLE_PED_IS_USING(ped)
    if GET_VEHICLE_PED_IS_IN(ped, false) == vehicle then
        return vehicle != 0 and !(driver and GET_PED_IN_VEHICLE_SEAT(vehicle, -1, false) != ped) and vehicle or nil
    end
end

function players.get_personal_vehicle(player_id: int, return_network_id: ?bool = false): ?int
    if !players.exists(player_id) then return end
    local net = memory.read_int(globals[8](player_id))
    if return_network_id then return net != 0 ? net : nil end
    local vehicle = NET_TO_VEH(net)
    return DOES_ENTITY_EXIST(vehicle) ? vehicle : nil
end

function players.in_godmode(player_id: int): bool
    return players.exists(player_id) and !global_compatibility_mode and players.is_godmode(player_id) and GET_ENTITY_HEIGHT_ABOVE_GROUND(players.get_ped(player_id)) > 0.0 and !(functions.is_player_fading(player_id) or players.is_using_rc_vehicle(player_id) or players.in_interior(player_id, true) or players.in_transition(player_id))
end

function players.valid_position(player_id: int): bool
    return players.exists(player_id) and v3.distance(v3.setZ(players.get_position(player_id), 0), v3.new()) > 0
end

function players.get_waypoint_no_0(player_id: int): ?table
    if !players.exists(player_id) then return end
    local waypoint = v3.new(players.get_waypoint(player_id))
    return v3.distance(waypoint, v3.new()) > 0 ? waypoint : nil
end

function players.random_player(exclude_user: ?bool = true, exclude_interior: ?bool = false): int
    local player_ids, valid_ids = players.list_except(exclude_user), {}
    for player_ids as player_id do
        if exclude_interior and players.in_interior(player_id, true) then continue end
        valid_ids[#valid_ids + 1] = player_id
    end
    return #valid_ids > 0 and valid_ids[math.random(#valid_ids)] or players.user()
end

function players.is_passive_mode(player_id: int): bool
    return players.exists(player_id) and (memory.read_int(globals[3](player_id)) == 1)
end

function players.geo_ip(ip: int, country_only: ?bool = false): string
    local location = ip != 0 and util.is_soup_netintel_inited() ? util.ip_get_location(ip) : nil
    return location != nil ? $"{tostring(!country_only ? location.city : "")}{tostring(!country_only and location.state != "" and location.city != "" ? ", " : "")}{tostring(!country_only ? location.state : "")}{tostring(!country_only and lang.get_country_name(location.country_code, "EN") != "" and (location.city != "" or location.state != "") ? ", " : "")}{lang.get_country_name(location.country_code, "EN")}" : ""
end

function players.is_first_person(player_id: int): bool
    if !players.exists(player_id) then return false end
    local ped = players.get_ped(player_id)
    local bone_id = entities.get_bone(ped, "bonetag_head")
    if !bone_id then return false end
    return v3.distance(players.get_cam_pos(player_id), GET_WORLD_POSITION_OF_ENTITY_BONE(ped, bone_id)) <= 0.5
end

function players.is_marked_as_likely_modder(player_id: int): bool
    if !players.exists(player_id) or !shadovis(player_id):classification_root():isValid() then return false end
    return shadovis(player_id):classification_root().menu_name == "Classification: Likely Modder"
end

function players.is_preferred_as_modder(player_id: int): bool
    if !players.exists(player_id) or !shadovis(player_id):classification_root():isValid() then return false end
    local player_classification = shadovis(player_id):classification_root().menu_name:gsub("Classification: ", "")
    for modder_types as modder_type do
        if player_classification != modder_type.name then continue end
        return modder_type.value
    end return false
end

function players.is_stand_user(player_id: int): bool
    if !players.exists(player_id) then return false end
    local player = shadovis(player_id)
    if player.stand_user then return true end
    if players.is_marked_as_modder(player_id) and player:has_classification("Stand User", false) then
        player.stand_user = true
        return true
    elseif !commandrefs[4].standuseridentification.value then return false end
    for menu.rbp("Players>All Players>Excludes"):getChildren() as commandref do
        if commandref:getType() != COMMAND_TOGGLE then continue end
        commandref.value = commandref:equals(menu.rbp("Players>All Players>Excludes>Exclude Stand Users"))
    end
    for players.list_all_with_excludes() as excluded_id do
        if excluded_id != player_id then continue end
        return false
    end
    player.stand_user = true
    return true
end

function players.get_coords_camera_is_pointing_at(player_id: int, distance: ?int = 100): userdata
    if !players.exists(player_id) then return v3.new() end
    return players.get_cam_pos(player_id):add(players.get_cam_rot(player_id):toDir():mul(distance))
end

function players.has_clear_line_of_sight(player_id: int, expensive_check: ?bool = false): bool
    if !players.exists(player_id) then return false end
    local vehicle = players.get_vehicle(player_id)
    if vehicle and vehicle == players.get_vehicle(players.user()) then return true end
    local result = util.raycast(players.get_cam_pos(players.user()), GET_ENTITY_COORDS(vehicle or players.get_ped(player_id), true), player_id != players.user() and players.user_ped() or 0, vehicle ? 1 : 2)
    if result.hit and result.hit_entity == (vehicle or players.get_ped(player_id)) then return true end
    if !expensive_check then return false end
    for vehicle and {"chassis", "bumper_f", "bumper_r", "roof", "door_dside_f", "door_pside_f"} or {"bonetag_head", "bonetag_l_forearm", "bonetag_r_forearm", "bonetag_l_calf", "bonetag_r_calf"} as bone do
        local bone_id = entities.get_bone(vehicle or players.get_ped(player_id), bone)
        if !bone_id then continue end
        result = util.raycast(players.get_cam_pos(players.user()), GET_WORLD_POSITION_OF_ENTITY_BONE(vehicle or players.get_ped(player_id), bone_id), player_id != players.user() and players.user_ped() or 0, 2)
        if result.hit and result.hit_entity == (vehicle or players.get_ped(player_id)) then return true end
    end
    return false
end

function entities.has_clear_line_of_sight(entity: int): bool
    if !DOES_ENTITY_EXIST(entity) then return false end
    local vehicle = GET_ENTITY_TYPE(entity) == 1 and GET_VEHICLE_PED_IS_USING(entity) != 0 ? GET_VEHICLE_PED_IS_USING(entity) : nil
    if vehicle and vehicle == players.get_vehicle(players.user()) then return true end
    local result = util.raycast(players.get_cam_pos(players.user()), GET_ENTITY_COORDS(entity, true), entity != players.user_ped() ? players.user_ped() : 0, vehicle ? 1 : 2)
    return result.hit and result.hit_entity == (vehicle or entity)
end

function entities.get_bone(entity: int, bone: string): ?int
    if DOES_ENTITY_EXIST(entity) and (bone_id := GET_ENTITY_BONE_INDEX_BY_NAME(entity, bone)) != -1 then
        return bone_id
    end
end

function entities.is_vehicle_indestructible(vehicle: ?int = 0, stealth: ?bool = false): bool
    return DOES_ENTITY_EXIST(vehicle) and IS_ENTITY_A_VEHICLE(vehicle) and entities.is_invulnerable(vehicle) and (!stealth or GET_ENTITY_CAN_BE_DAMAGED(vehicle))
end

function entities.get_seat_ped_is_in(ped: int): int
    if !DOES_ENTITY_EXIST(ped) then return INVALID end
    local vehicle = GET_VEHICLE_PED_IS_USING(ped)
    if vehicle == 0 then return INVALID end
    for i = -1, (GET_VEHICLE_MODEL_NUMBER_OF_SEATS(entities.get_model_hash(vehicle)) - 2) do
        if GET_PED_IN_VEHICLE_SEAT(vehicle, i) != ped then continue end
        return i
    end return INVALID
end

function directx.get_ped_dimensions(ped: int, interpret_body_size: ?bool = true): table
    local dimensions = {x = {low = 1, high = 0}, y = {low = 1, high = 0}}
    if !(DOES_ENTITY_EXIST(ped) and IS_ENTITY_A_PED(ped)) then return dimensions end
    for {"bonetag_pelvis", "bonetag_l_thigh", "bonetag_l_calf", "bonetag_l_foot", "bonetag_l_ph_foot", "bonetag_r_thigh", "bonetag_r_calf", "bonetag_r_foot", "bonetag_r_ph_foot", "bonetag_spine_root", "bonetag_spine", "bonetag_spine1", "bonetag_spine2", "bonetag_spine3", "bonetag_l_clavicle", "bonetag_l_upperarm", "bonetag_l_forearm", "bonetag_l_hand", "bonetag_l_ph_hand", "bonetag_r_clavicle", "bonetag_r_upperarm", "bonetag_r_forearm", "bonetag_r_hand", "bonetag_r_ph_hand", "bonetag_neck", "bonetag_head"} as bone do
        local bone_id = entities.get_bone(ped, bone)
        if !bone_id then continue end
        local position = GET_WORLD_POSITION_OF_ENTITY_BONE(ped, bone_id)
        if (bone == "bonetag_l_ph_hand" or bone == "bonetag_r_ph_hand") and v3.distance(position, GET_WORLD_POSITION_OF_ENTITY_BONE(ped, entities.get_bone(ped, bone == "bonetag_l_ph_hand" and "bonetag_l_hand" or bone == "bonetag_r_ph_hand" and "bonetag_r_hand"))) > 0.5 then continue end
        local on_screen, x, y = util.get_screen_position(position)
        if !on_screen then continue end
        dimensions.x.low, dimensions.x.high, dimensions.y.low, dimensions.y.high = x < dimensions.x.low and x or dimensions.x.low, x > dimensions.x.high and x or dimensions.x.high, y < dimensions.y.low and y or dimensions.y.low, y > dimensions.y.high and y or dimensions.y.high
    end

    if interpret_body_size and (dimensions.x.low != 1 or dimensions.x.high != 0 or dimensions.y.low != 1 or dimensions.y.high != 0) then
        local original_dimensions = dimensions

        local adjustment = original_dimensions.y.low - (original_dimensions.y.high - original_dimensions.y.low) * 0.13
        dimensions.y.low = adjustment < 0 ? 0 : adjustment

        adjustment = original_dimensions.y.high + (original_dimensions.y.high - original_dimensions.y.low) * 0.03
        dimensions.y.high = adjustment > 1 ? 1 : adjustment

        adjustment = original_dimensions.x.low - (original_dimensions.x.high - original_dimensions.x.low) * 0.1
        dimensions.x.low = adjustment < 0 ? 0 : adjustment

        adjustment = original_dimensions.x.high + (original_dimensions.x.high - original_dimensions.x.low) * 0.1
        dimensions.x.high = adjustment > 1 ? 1 : adjustment
    end

    return dimensions
end

function directx.draw_ped_box(ped: int, colour: ?table = {r = 1, g = 1, b = 1, a = 1}): void
    if !(DOES_ENTITY_EXIST(ped) and IS_ENTITY_A_PED(ped)) then return end
    local dimensions = directx.get_ped_dimensions(ped, true)
    for {{x = {dimensions.x.low, dimensions.x.low}, y = {dimensions.y.low, dimensions.y.high}}, {x = {dimensions.x.high, dimensions.x.high}, y = {dimensions.y.low, dimensions.y.high}}, {x = {dimensions.x.low, dimensions.x.high}, y = {dimensions.y.low, dimensions.y.low}}, {x = {dimensions.x.low, dimensions.x.high}, y = {dimensions.y.high, dimensions.y.high}}} as line do
        directx.draw_line_client(line.x[1], line.y[1], line.x[2], line.y[2], colour.r, colour.g, colour.b, colour.a)
    end
end

function directx.draw_ped_skeleton(ped: int, colour: ?table = {r = 1, g = 1, b = 1, a = 1}): void
    if !(DOES_ENTITY_EXIST(ped) and IS_ENTITY_A_PED(ped)) then return end
    for {{"bonetag_head", "bonetag_neck"}, {"bonetag_neck", "bonetag_l_clavicle"}, {"bonetag_l_clavicle", "bonetag_spine3"}, {"bonetag_neck", "bonetag_r_clavicle"}, {"bonetag_r_clavicle", "bonetag_spine3"}, {"bonetag_spine3", "bonetag_pelvis"}, {"bonetag_l_clavicle", "bonetag_l_upperarm"}, {"bonetag_l_upperarm", "bonetag_l_forearm"}, {"bonetag_l_forearm", "bonetag_l_hand"}, {"bonetag_l_hand", "bonetag_l_ph_hand"}, {"bonetag_r_clavicle", "bonetag_r_upperarm"}, {"bonetag_r_upperarm", "bonetag_r_forearm"}, {"bonetag_r_forearm", "bonetag_r_hand"}, {"bonetag_r_hand", "bonetag_r_ph_hand"}, {"bonetag_pelvis", "bonetag_l_thigh"}, {"bonetag_l_thigh", "bonetag_l_calf"}, {"bonetag_l_calf", "bonetag_l_foot"}, {"bonetag_l_foot", "bonetag_l_ph_foot"}, {"bonetag_pelvis", "bonetag_r_thigh"}, {"bonetag_r_thigh", "bonetag_r_calf"}, {"bonetag_r_calf", "bonetag_r_foot"}, {"bonetag_r_foot", "bonetag_r_ph_foot"}} as connection do
        local position1, position2 = GET_WORLD_POSITION_OF_ENTITY_BONE(ped, entities.get_bone(ped, connection[1])), GET_WORLD_POSITION_OF_ENTITY_BONE(ped, entities.get_bone(ped, connection[2]))
        if (connection[2] == "bonetag_l_ph_hand" or connection[2] == "bonetag_r_ph_hand") and v3.distance(position1, position2) > 0.5 then continue end
        local on_screen1, x1, y1 = util.get_screen_position(position1)
        local on_screen2, x2, y2 = util.get_screen_position(position2)
        if !on_screen1 or !on_screen2 then continue end
        directx.draw_line_client(x1, y1, x2, y2, colour.r, colour.g, colour.b, colour.a)
    end
end

function directx.draw_text_with_shadow(x: number, y: number, text: string, align: ?int = ALIGN_CENTRE, scale: ?float = 1, colour: ?table = {r = 1, g = 1, b = 1, a = 1}, shadows: ?int = 0, standard_ratio: ?bool = true): void
    local gradient = commandrefs[4].shadowgradient.value
    x = x > 1 ? 1 / screen_dimensions.x * x : x
    y = y > 1 ? 1 / screen_dimensions.y * y : y
    for i = shadows, 1, -1 do
        local pixel, shadow = i / 2, {r = 0, g = 0, b = 0, a = 1}
        if gradient then
            shadow.r = colour.r / 100 * (100 / shadows * (shadows - i))
            shadow.g = colour.g / 100 * (100 / shadows * (shadows - i))
            shadow.b = colour.b / 100 * (100 / shadows * (shadows - i))
        end
        directx[standard_ratio ? "draw_text" : "draw_text_client"](x + 1 / screen_dimensions.x * i, y + 1 / screen_dimensions.y * i, text, align, scale, shadow.r, shadow.g, shadow.b, shadow.a, true)
    end
    directx[standard_ratio ? "draw_text" : "draw_text_client"](x, y, text, align, scale, colour.r, colour.g, colour.b, colour.a, true)
end

function directx.draw_text_with_outline(x: float, y: float, text: string, align: ?int = ALIGN_CENTRE, scale: ?float = 1, colour: ?table = {r = 1, g = 1, b = 1, a = 1}, outline: ?table = {r = 0, g = 0, b = 0, a = 1}, standard_ratio: ?bool = true): void
    x = x > 1 ? 1 / screen_dimensions.x * x : x
    y = y > 1 ? 1 / screen_dimensions.y * y : y
    for i = 1, 4 do
        local angle = (i - 1) * (2 * math.pi / 4)
        directx[standard_ratio ? "draw_text" : "draw_text_client"](x + math.cos(angle) * 0.001, y + math.sin(angle) * 0.001, text, align, scale, outline.r, outline.g, outline.b, outline.a, true)
    end
    directx[standard_ratio ? "draw_text" : "draw_text_client"](x, y, text, align, scale, colour.r, colour.g, colour.b, colour.a, true)
end

function directx.get_scale_for_text_width(text: string, width: ?float = 1): float
    return 1 / directx.get_text_size_client(text, 1) * width
end

function http.get_response(url: string, default_response: ?string = "", headers: ?table = {}, post: ?table = {content_type = "", payload = ""}, ipv6: ?bool = false): string
    if !async_http.have_access() then return default_response end

    -- im assuming no one is stupid enough to put this in there, but just incase
    if url:startswith("https://") then
        url = {url:partition("https://")}[2]
    elseif url:startswith("http://") then
        url = {url:partition("http://")}[2]
    end

    local host, path = url:partition("/")
    local result, response = nil, false
    async_http.init(host, $"/{path}", function(body, header_fields, status_code)
        result, response = status_code == 200 ? body : default_response, true
    end, function()
        result, response = default_response, true
    end)
    for key, value in headers do
        async_http.add_header(key, value)
    end
    if post.content_type != "" or post.payload != "" then
        async_http.set_post(post.content_type, post.payload)
    end
    if ipv6 then
        async_http.prefer_ipv6()
    end
    async_http.dispatch()
    repeat util.yield() until response
    return result
end

function sc.get_auth_ticket(): ?string
    if !scauth.ticket then
        if !scauth.pointer then
            local pattern = patterns.SCI
            local address = memory.scan(pattern)
            if address == 0 then
                util.notify($"Failed to find 'SCI'.", true, true, dev)
            return end

            scauth.pointer = memory.rip(address - 4)
        end

        local sci = memory.read_string(scauth.pointer)
        if #sci == 0 then
            util.notify("'SCI' length is 0.", true, true, dev)
        return end

        scauth.ticket = sci
    end return scauth.ticket
end

function sc.get_rockstar_id_from_name(name: string): ?int
    name = name:lower()

    for playerinfo as player_information do
        if !player_information?.name or name != player_information.name:lower() then continue end
        return player_information.rockstar_id, player_information?.name
    end

    local auth_ticket = sc.get_auth_ticket()
    if !auth_ticket then
        util.notify("Failed to get social club authentication.", false, false, true)
    return end

    local response = json.decode(http.get_response("scui.rockstargames.com/api/friend/accountsearch", "{\"Total\":0}", {["Authorization"] = $"SCAUTH val=\"{auth_ticket}\"", ["X-Requested-With"] = "XMLHttpRequest"}, {content_type = "application/json", payload = $"\{\"searchNickname\":\"{name}\"}"}))

    if response.Total == 0 then return end
    return response.Accounts[1].RockstarId, response.Accounts[1].Nickname
end

function sc.get_name_from_rockstar_id(rockstar_id: int): ?string
    if playerinfo[rockstar_id]?.name then return playerinfo[rockstar_id].name, rockstar_id end

    local auth_ticket = sc.get_auth_ticket()
    if !auth_ticket then
        util.notify("Failed to get social club authentication.", false, false, true)
    return end

    local response = json.decode(http.get_response("scui.rockstargames.com/api/friend/getprofile", "{\"Accounts\":[]]}", {["Authorization"] = $"SCAUTH val=\"{auth_ticket}\"", ["X-Requested-With"] = "XMLHttpRequest", ["Content-Type"] = "application/json"}, {content_type = "application/json", payload = $"\{\"RockstarId\":\"{rockstar_id}\"}"}))

    return response?.Accounts[1]?.RockstarAccount?.Name, response?.Accounts[1]?.RockstarAccount?.RockstarId
end

function shadovis(player_id: ?int = 0): table -- literally just a wrapper
    return player_list[player_id]
end

function functions.queue_function(name: string, cooldown: ?int = 0, callback: function, cancel: ?function = function() end): ?bool
    local function queue(name: string, cooldown: int, key): ?bool|int
        if !queues[name] then
            queues[name] = {entries = {}, cooldown = cooldown, timeout = 0, busy = false}
        end
        if key then
            for queues[name].entries as entry do
                if !entry.state then
                    if entry.ignore then
                        if entry.key == key then
                            return
                        end
                        continue
                    end
                    if util.current_time_millis() > entry.alive then
                        entry.ignore = true
                        continue
                    end
                    return entry.key == key
                end
            end
        else
            key = #queues[name].entries > 0 and (queues[name].entries[#queues[name].entries].key + 1) or 1
            queues[name].entries[key] = {key = key, alive = util.current_time_millis() + 3000, state = false, ignore = false}
            return key
        end
    end

    local function edit_entry(name: string, key: int, entry: table): void
        if queues[name]?.entries[key] then
            queues[name].entries[key][entry[1]] = entry[2]
        end
    end

    local function wait_for_queue(name: string, state: ?bool): ?bool
        if !queues[name] then return end
        if state != nil then
            queues[name].busy, queues[name].timeout = state, util.current_time_millis() + (queues[name].cooldown * 1000)
        end
        return queues[name].busy or util.current_time_millis() < queues[name].timeout
    end

    local key, output = 0, false
    key = queue(name, cooldown)
    repeat
        output = queue(name, cooldown, key)
        edit_entry(name, key, {"alive", util.current_time_millis() + 3000})
        if util.can_continue() then util.yield() end
    until output or output == nil or !util.can_continue()
    if output == nil or !util.can_continue() then return false end
    while wait_for_queue(name) do
        edit_entry(name, key, {"alive", util.current_time_millis() + 3000})
        if !util.can_continue() or cancel() then break end
        util.yield()
    end
    if !cancel() and !wait_for_queue(name) then
        wait_for_queue(name, true)
        edit_entry(name, key, {"state", true})
        callback()
        wait_for_queue(name, false)
        return true
    end
    return false
end

local function compare_strings_similarity(string_1: string, string_2: string): float
    local length_1, length_2, solutions = string_1:len(), string_2:len(), {}
    for i = 1, length_1 do solutions[i] = {} for i2 = 1, length_2 do
        solutions[i][i2] = string_1:sub(i, i) == string_2:sub(i2, i2) ? (solutions[i - 1] and solutions[i - 1][i2 - 1] or 0) + 1 : math.max(solutions[i - 1] and solutions[i - 1][i2] or 0, solutions[i] and solutions[i][i2 - 1] or 0)
    end end
    return (solutions[length_1][length_2] * 2) / (length_1 + length_2) * 100
end

local function CHANGE_PED_HEALTH(ped: int, health: number, hp_mismatch: ?bool = false): void
    if !(DOES_ENTITY_EXIST(ped) and IS_ENTITY_A_PED(ped)) then return nil end
    local max_health = GET_PED_MAX_HEALTH(ped)
    SET_PED_MAX_HEALTH(ped, health > max_health and health or max_health)
    SET_ENTITY_HEALTH(ped, health, 0, 0)
    SET_PED_MAX_HEALTH(ped, hp_mismatch and max_health or health)
end

function GET_PED_WEAPON_DATA(ped: int, include_unarmed: ?bool = false): ?table
    if !(DOES_ENTITY_EXIST(ped) and IS_ENTITY_A_PED(ped)) then return nil end
    local weapon_hash = GET_SELECTED_PED_WEAPON(ped)
    if include_unarmed and weapon_hash == util.joaat("weapon_unarmed") then
        return {hash = weapon_hash, label_key = "WT_UNARMED", category = "Melee Weapons", category_id = 0}
    end
    for weapon_list as weapon do
        if weapon.hash != weapon_hash then continue end
        return weapon
    end
    return nil
end

local function outfit_function(): void
    if commandrefs[4].outfit_changer.value == 1 or IS_PLAYER_DEAD(players.user()) then return end
    local outfit, max_health, health, armour, vehicle, modded_health = commandrefs[4].outfit_changer:getState(), GET_PED_MAX_HEALTH(players.user_ped()), GET_ENTITY_HEALTH(players.user_ped()), GET_PED_ARMOUR(players.user_ped()), players.get_vehicle(players.user(), true), shadovis(players.user()):has_classification("Modded Health", false)

    local function transform(name: string): void
        for {"Playable Characters", "Ground Animals", "Water Animals", "Flying Animals", "NPCs"} as path do
            if !menu.rbp($"Self>Appearance>Transform>{path}>{name}"):isValid() then continue end
            menu.rbp($"Self>Appearance>Transform>{path}>{name}"):trigger()
        break end
    end

    local function apply_outfit(name: string): bool
        for {"", " [Current Model]"} as entry do
            if !menu.rbp($"Self>Appearance>Outfit>Wardrobe>{outfit}{entry}"):isValid() then continue end
            menu.rbp($"Self>Appearance>Outfit>Wardrobe>{outfit}{entry}"):trigger()
            return true
        end return false
    end

    if !filesystem.exists($"{filesystem.stand_dir()}Outfits\\{outfit}.txt") or !filesystem.is_regular_file($"{filesystem.stand_dir()}Outfits\\{outfit}.txt") then return end

    local model = nil
    for path, value in util.read_colons_and_tabs_file($"{filesystem.stand_dir()}Outfits\\{outfit}.txt") do
        if path != "Model" then continue end
        model = value
    break end

    -- i hate the fact i have to do all this just so it doesnt stall when you switch in a vehicle youre driving
    if vehicle and (seat := entities.get_seat_ped_is_in(players.user_ped())) == -1 and ped_transformations[model] and !IS_PED_MODEL(players.user_ped(), ped_transformations[model]) then
        local velocity = GET_ENTITY_VELOCITY(vehicle)
        SET_ENTITY_VELOCITY(vehicle, 0, 0, 0)
        CLEAR_PED_TASKS_IMMEDIATELY(players.user_ped())
        transform(model)
        util.yield()
        SET_PED_INTO_VEHICLE(players.user_ped(), vehicle, seat)
        SET_ENTITY_COORDS_NO_OFFSET(vehicle, v3.add(GET_ENTITY_COORDS(vehicle, true), v3.new(0, 0, 0.1)), false, false, false)
        util.yield()
        SET_ENTITY_VELOCITY(vehicle, velocity)
    elseif !ped_transformations[model] or !IS_PED_MODEL(players.user_ped(), ped_transformations[model]) then -- may as well do it like this.
        transform(model)
    end

    if !apply_outfit(outfit) then
        util.notify("Couldn't find outfit in wardrobe, refreshing it.")
        menu.focus_on_commandref(menu.rbp("Self>Appearance>Outfit>Wardrobe"), 2, 100, function() end)
        apply_outfit(outfit)
    end

    while GET_PED_MAX_HEALTH(players.user_ped()) != max_health do
        SET_PED_MAX_HEALTH(players.user_ped(), max_health)
        util.yield()
    end
    CHANGE_PED_HEALTH(players.user_ped(), health)
    SET_PED_ARMOUR(players.user_ped(), armour)

    if modded_health then return end -- if it was previously modded then just ignore it
    shadovis(players.user()):has_classification("Modded Health", false, true):trigger()
end

local function spawn_function(delays: ?bool = false): void
    gender = IS_PED_MODEL(players.user_ped(), util.joaat("mp_m_freemode_01")) ? 0 : IS_PED_MODEL(players.user_ped(), util.joaat("mp_f_freemode_01")) ? 1 : -1
    if delays then util.wait_time(1) end
    if util.in_session() and !util.in_heist() and commandrefs[4].outfit_changer.value != 1 then
        functions.queue_function("outfit_changer", 0, outfit_function)
    end
    if commandrefs[4].spawnmaxhealth.value and GET_PED_MAX_HEALTH(players.user_ped()) < 328 then
        CHANGE_PED_HEALTH(players.user_ped(), 328)
    end
    if GET_PLAYER_MAX_ARMOUR(players.user()) > 50 or commandrefs[4].spawnfullarmour.value then
        SET_PLAYER_MAX_ARMOUR(players.user(), 50)
        ADD_ARMOUR_TO_PED(players.user_ped(), commandrefs[4].spawnfullarmour.value ? 50 : 0)
    end
    if delays then util.wait_time(15) end
    if util.in_session() and commandrefs[4].spawnrefillinventory.value then
        menu.rbp("Online>Quick Progress>Refill Snacks & Armour"):trigger()
    end
    if commandrefs[4].spawnallweapons.value then
        menu.rbp("Self>Weapons>Get Weapons>All Weapons"):trigger()
    end
end

function request_entity_control(entity: ?int = 0, timeout: ?int = 3, migrate: ?bool = true): bool
    if !(util.in_session() and DOES_ENTITY_EXIST(entity)) then return false end
    if entities.get_owner(entity) != players.user() then
        entities.set_can_migrate(entity, true)
        entities.request_control(entity, timeout * 1000)
    end
    entities.set_can_migrate(entity, migrate)
    return entities.get_owner(entity) == players.user()
end

function ignore_this_detection(detection: string): bool
    for ignored_detections as compare_detection do
        if compare_detection == detection then return true end
    end return false
end

function create_detection_commands(name: string, root: ?int): void
    if type(detections[name]) != "table" then return end
    local detection = detections[name]
    root = root or commandrefs[4].root_detections
    local root_detection, look_up_table = menu.rbrp(root, detection.name):isValid() ? menu.rbrp(root, detection.name) : root:list(detection.name, {}, detection.description), {notify = "Notification", log = "Write To Log", console = "Write To Console", allchat = "Announce In Chat", teamchat = "Announce In Team Chat", note = "Note", addnote = "Add Note", blockjoins = "Block Joins", track = "Track", timeout = "Timeout", block = "Block", kick = "Kick", crash = "Crash"}

    local function full_name(short_name: string): string
        for short, full in look_up_table do
            if short != short_name then continue end
            return full
        end return ""
    end

    if detection?.options != nil then
        for {"notify", "log", "console", "allchat", "teamchat"} as option do
            if detection?.options?[option] == nil or menu.rbrp(root_detection, full_name(option)):isValid() then continue end
            root_detection:list_select(full_name(option), {}, "", {{1, "Enabled"}, {2, "Friends & Strangers"}, {3, "Strangers"}, {4, "Disabled"}}, detection.options[option], function(state) detection.options[option] = state end)
        end
    end
    
    if detection?.reactions != nil then
        local reactions = 0
        for detection.reactions as reaction do
            ++reactions
            if reactions > 1 then break end
        end
        local divider_exists = false
        for root_detection:getChildren() as commandref do
            if commandref:getType() != COMMAND_DIVIDER then continue end
            divider_exists = true
        break end
        if detection?.options != nil and !divider_exists then
            root_detection:divider(reactions > 1 ? "Player Reactions" : "Player Reaction")
        end
        for {"addnote", "blockjoins", "track", "timeout", "block", "kick", "crash"} as option do
            if detection.reactions?[option] == nil or menu.rbrp(root_detection, full_name(option)):isValid() then continue end
            if option == "addnote" and (detection.reactions?.note == nil or menu.rbrp(root_detection, full_name("note")):isValid()) then continue end
            if option == "addnote" then
                root_detection:text_input(full_name("note"), {name.."note"}, "The name of the note that will be added into the \"Player History > Player > Note\".", function(state) detection.reactions.note = state end, detection.reactions.note)
            end
            local commandref commandref = root_detection:list_select(full_name(option), {}, option == "track" ? "This option requires Stand Ultimate." : "", {{1, "Friends & Strangers"}, {2, "Strangers"}, {3, "Disabled"}}, detection.reactions[option], function(state)
                if option == "track" and menu_version != 3 then
                    util.notify("Tracking can only be enabled with Stand Ultimate.")
                    commandref.value = detection.reactions[option]
                return end
                detection.reactions[option] = state
            end)
        end
    end

    if !ignore_this_detection(detection.name) and root != commandrefs[4].root_reactions and !menu.rbrp(commandrefs[4].root_detectionmemory_genericdetections, detection.name):isValid() then
        generic_detections[detection.name] = false
        commandrefs[4].root_detectionmemory_genericdetections:toggle(detection.name, {}, "", function(state) generic_detections[detection.name] = state end, false)
    end

    return root_detection
end

function delete_detection_commands(name: string, root: ?int): void
    if type(detections[name]) != "table" then return end

    root = root or commandrefs[4].root_detections
    local detection = detections[name]

    if menu.rbrp(root, detection.name):isValid() then
        menu.rbrp(root, detection.name):delete()
    end

    if menu.rbrp(commandrefs[4].root_detectionmemory_genericdetections, detection.name):isValid() then
        menu.rbrp(commandrefs[4].root_detectionmemory_genericdetections, detection.name):delete()
    end
end

local function player_affected_detection(player_id: int, name: string, type: string): bool
    local player = shadovis(player_id)
    return detections[name]?.reactions?[type] != nil and players.exists(player_id) and player_id != players.user() and (detections[name].reactions[type] == 1 or detections[name].reactions[type] == 2 and !(player.friend or commandrefs[4].preferencefakefriend.value and player:fakefriend() or commandrefs[4].preferencewhitelistjoin.value and player:whitelistedjoin()))
end

function do_affected_detection(player_id: int, name: string, kick: ?bool = true, crash: ?bool = true, extra: ?string): void
    if detections[name] == nil then return end
    local player = shadovis(player_id)
    if detections[name]?.severity != nil then
        if !players.exists(player_id) and player_id != players.user() and !ignore_this_detection(detections[name].name) then
            util.notify($"{player.name} triggered a detection when they already left: {detections[name].name}{tostring(extra != nil ? $" ({extra})" : "")}", false, true, true)
            if !all_players[player.rockstar_id].detections[hash_string(detections[name].name)] then
                all_players[player.rockstar_id].detections[hash_string(detections[name].name)] = {name = detections[name].name, hash = hash_string(detections[name].name), extras = {}, fake = {commandref = nil, bypass = false}}
            end
            if extra != nil then
                local add_detection_extra = true
                for all_players[player.rockstar_id].detections[hash_string(detections[name].name)].extras as detection_extra do
                    if extra == detection_extra then add_detection_extra = false break end
                end
                if add_detection_extra then
                    all_players[player.rockstar_id].detections[hash_string(detections[name].name)].extras[#all_players[player.rockstar_id].detections[hash_string(detections[name].name)].extras + 1] = extra
                end
            end
        end
        
        player:add_detection(name, extra)
    end
    if !(players.exists(player_id) and player.ready) then return end
    if player_affected_detection(player_id, name, "addnote") and (!commandrefs[4].overrideplayernote.value or menu.rbrp(player:history_root(), "Note").value == "") then
        player:history_edit({{path = "Note", state = detections[name].reactions.note}})
    end
    if player_affected_detection(player_id, name, "blockjoins") then
        player:history_edit({{path = "Whitelist Join", state = false}, {path = "Player Join Reactions>Notification", state = true}, {path = "Player Join Reactions>Block Join", state = true}})
    end
    if player_affected_detection(player_id, name, "track") then
        player:history_edit({{path = "Player Join Reactions>Notification", state = true}, {path = "Tracking", state = 1}})
    end
    if player_affected_detection(player_id, name, "timeout") then
        menu.rbrp(menu.pr(player_id), "Timeout").value = true
    end
    if player_affected_detection(player_id, name, "block") then
        player.toggle_loops.block.value = true
    end
    if player_affected_detection(player_id, name, "kick") and kick then
        player:kick(false, false, true, detections[name]?.reason)
    end
    if player_affected_detection(player_id, name, "crash") and crash then
        player:crash(false, false, true, detections[name]?.reason)
    end
end

local function export_list_data(list: table, entries: table|string, redo_indexes: ?bool = false): table
    local temp_list = {}
    if redo_indexes then
        for list as entry do
            temp_list[#temp_list + 1] = entry
        end
        list, temp_list = temp_list, {}
    end
    for i = 1, #list do
        if type(entries) == "table" then
            temp_list[i] = {}
            for entries as entry do
                if list[i][entry] then
                    temp_list[i][entry] = list[i][entry]
                end
            end
        elseif type(entries) == "string" and list[i][entries] then
            temp_list[i] = list[i][entries]
        end
    end
    return temp_list
end

local function average_from_list(list: table, length: ?int = 100, zero: ?bool = false, extra: ?table = {})
    local total, zeros, amount = 0, 0, 0
    for list as entry do
        if length and amount >= length then break end
        total += zero and entry == 0 and (extra.max * extra.penalty) or entry
        ++amount
    end
    return (total / amount)
end

local function update_player_data(player_id: int): void
    if !(players.exists(player_id) and util.in_session() and players.valid_position(player_id)) then return end
    local player, ped, vehicle = shadovis(player_id), players.get_ped(player_id), players.get_vehicle(player_id, false)

    player.antitp.position = players.get_position(player_id)
    player.antitp.nearby = v3.distance(players.get_position(players.user()), players.get_position(player_id)) <= 50

    player.antitp.interior.state = players.in_interior(player_id, true)

    player.antitp.cutscene.state = IS_PLAYER_IN_CUTSCENE(player_id) or NETWORK_IS_PLAYER_IN_MP_CUTSCENE(player_id)
    player.antitp.dead.state = IS_PLAYER_DEAD(player_id)
    player.antitp.transition.state = players.in_transition(player_id)

    if util.current_time_millis() > player.antitp.timeout.ref_time then
        player.antitp.timeout.ref_time, player.antitp.timeout.state = util.current_time_millis() + 1000, (menu.rbrp(menu.pr(player_id), "Timeout").value or menu.rbrp(menu.pr(player_id), "Incoming Syncs>Block").value)
    end

    player.antitp.vehicle.state = vehicle or (GET_VEHICLE_PED_IS_TRYING_TO_ENTER(ped) != 0)
    player.antitp.vehicle.vehicle = player.antitp.vehicle.state and (vehicle or GET_VEHICLE_PED_IS_TRYING_TO_ENTER(ped)) or nil
    local local_attach, attach = GET_ENTITY_ATTACHED_TO(players.user_ped()), GET_ENTITY_ATTACHED_TO(ped)
    player.antitp.attached.state = local_attach != 0 and local_attach == vehicle or attach != 0 and attach == players.get_vehicle(players.user(), false)
end

function check_player_data(player_id: int, ignore_vehicle: ?bool = false): bool
    local time, value = util.current_time_millis(), true
    if !(players.exists(player_id) and util.in_session() and players.valid_position(player_id)) then return false end
    local player = shadovis(player_id)
    for (player_id == players.user() ? {"interior", "cutscene", "transition"} : {"interior", "cutscene", "dead", "transition", "timeout", "vehicle", "attached"}) as method do
        if method == "vehicle" and (player.antitp.vehicle.state != player.antitp.vehicle.last_state or player.antitp.vehicle.vehicle != player.antitp.vehicle.last_vehicle or player.antitp.vehicle.time == -1) then
            player.antitp.vehicle.last_state, player.antitp.vehicle.last_vehicle, player.antitp.vehicle.time = player.antitp.vehicle.state, player.antitp.vehicle.vehicle, time + 1000
        elseif method != "vehicle" and player.antitp[method].state or player.antitp[method].time == -1 then
            player.antitp[method].time = time + (player_id == players.user() ? 1 : 2) * 1000
        end
        if time >= player.antitp[method].time then
            player.antitp[method].time = 0
        end
        if player.antitp[method].time != 0 and !(ignore_vehicle and method == "vehicle") then value = false end
    end
    return value
end

local function detectionmemory_create_player_entry(player: table): void
    local player_root = menu.rbrp(commandrefs[4].root_detectionmemory, player.name)
    for player.detections as detection do
        if detection != nil and !(commandrefs[4].filtergenericdetections.value and generic_detections[detection.name]) then
            for player_root:getChildren() as commandref do
                if commandref:getType() < COMMAND_FIRST_PHYSICAL then continue end
                local classification = lang.get_string(commandref.menu_name, "en")
                if (string.match(classification, "(.-)%s*%(") or classification) == detection.name then continue 2 end
            end

            local detection_extra;
            for detection.extras as extra do
                detection_extra = detection_extra != nil ? $"{detection_extra}, {extra}" : $" ({extra}"
            end

            local root_detection; root_detection = player_root:action(detection.name..(detection_extra != nil ? $"{detection_extra})" : ""), {}, removedetectioncommand, function()
                for players.list_except(true) as player_id do
                    if players.get_rockstar_id(player_id) == player.rockstar_id then
                        if shadovis(player_id):has_classification(detection.name, false) then return end
                        break
                    end
                end

                local valid_detections = 0
                for all_players[player.rockstar_id].detections as detection_2 do
                    if detection_2 != nil and !(commandrefs[4].filtergenericdetections.value and generic_detections[detection_2.name]) then ++valid_detections end
                end

                all_players[player.rockstar_id].detections[detection.hash] = nil

                if valid_detections == 1 then
                    local player_commandrefs = commandrefs[4].root_detectionmemory:getChildren()
                    if #player_commandrefs == 5 then
                        for i = 3, #player_commandrefs do
                            player_commandrefs[i]:delete()
                        end
                    else
                        player_root:delete()
                    end
                else
                    root_detection:delete()
                end
            end)
            if commandrefs[4].preferenceupdatelive.value then
                local detection_commandrefs = player_root:getChildren()
                for i = 1, #detection_commandrefs do
                    if !root_detection:equals(detection_commandrefs[i]) or (i - 1) % menu.rbp("Stand>Settings>Appearance>Max Visible Commands").value != 0 then continue end
                    root_detection:onTickInViewport(|| -> detectionmemory_create_player_entry(player))
                end
            end
        end
    end
end

local function detectionmemory_create_entry(): void
    for all_players as player do
        local root, filter = commandrefs[4].root_detectionmemory, true
        for player.detections as detection do
            if detection != nil and !(commandrefs[4].filtergenericdetections.value and generic_detections[detection.name]) then filter = false break end
        end
        if filter then
            if (commandref := menu.rbrp(root, player.name)):isValid() then
                local detection_commandrefs = root:getChildren()
                if #detection_commandrefs == 5 then
                    for i = 3, #detection_commandrefs do
                        detection_commandrefs[i]:delete()
                    end
                else
                    commandref:delete()
                end
            end continue
        elseif menu.rbrp(root, player.name):isValid() then continue end

        if !menu.rbrp(root, "Clear"):isValid() then
            root:action("Clear", {}, "", function()
                for all_players as player_info do
                    all_players[player_info.rockstar_id].detections = {}
                end
                local detection_commandrefs = root:getChildren()
                for i = 3, #detection_commandrefs do
                    detection_commandrefs[i]:delete()
                end
            end)
            root:divider("Memory")
        end

        local commandref = root:list(player.name, {}, $"Name: {player.name}\nRockstar ID: {player.rockstar_id}", function()
            local player_root = menu.rbrp(root, player.name)
            if commandrefs[4].preferenceshowplayerhistoryshortcut.value then
                if player.history_root and player.history_root:isValid() then
                    player_root:link(player.history_root)
                else
                    player_root:action($"{player.name} [Unknown]", {}, "Unable to find Player History.", function() end)
                end
            end
            if commandrefs[4].preferenceshowchatmessage.value != 1 then
                local chat_commandref chat_commandref = player_root:list("Chat Messages", {}, "", function()
                    local unparsed_messages, used_messages, export_commandref, export_message, scroll = player.messages, {}, nil, "", commandrefs[4].preferenceshowchatmessage.value
                    repeat
                        local messages, timestamp = {}, {timestamp = scroll == 2 ? 0 : math.huge}
                        for i = 1, #unparsed_messages do
                            if scroll == 2 and unparsed_messages[i].timestamp > timestamp.timestamp or scroll == 3 and unparsed_messages[i].timestamp < timestamp.timestamp then
                                timestamp = {index = i, timestamp = unparsed_messages[i].timestamp}
                            end
                        end
                        if timestamp?.index != nil then
                            for i = 1, #unparsed_messages do
                                if i == timestamp.index then continue end
                                messages[#messages + 1] = unparsed_messages[i]
                            end
                            used_messages[#used_messages + 1] = {user = false, index = timestamp.index, timestamp = unparsed_messages[timestamp.index].timestamp, message = unparsed_messages[timestamp.index].message}

                            local local_messages = {}
                            for i = 1, #my_chat_messages do
                                if my_chat_messages[i]?.timestamp == nil then continue end
                                for used_messages as message_data do
                                    if message_data.user and i == message_data.index then continue 2 end
                                end

                                if (milli_time := my_chat_messages[i].timestamp - timestamp.timestamp) and (milli_time < 0 ? milli_time * -1 : milli_time) <= 30000 then
                                    used_messages[#used_messages + 1] = {user = true, index = i, timestamp = my_chat_messages[i].timestamp, message = my_chat_messages[i].message}
                                end
                            end
                        end
                        unparsed_messages = messages
                    until #unparsed_messages == 0

                    repeat
                        local messages, timestamp = {}, {timestamp = scroll == 2 ? 0 : math.huge}
                        for i = 1, #used_messages do
                            if scroll == 2 and used_messages[i].timestamp > timestamp.timestamp or scroll == 3 and used_messages[i].timestamp < timestamp.timestamp then
                                timestamp = {index = i, timestamp = used_messages[i].timestamp}
                            end
                        end
                        if timestamp?.index != nil then
                            for i = 1, #used_messages do
                                if i == timestamp.index then continue end
                                messages[#messages + 1] = used_messages[i]
                            end
                            if export_commandref == nil or !export_commandref:isValid() then
                                export_commandref = chat_commandref:action("Export Chat Messages", {}, "", || -> util.copy_to_clipboard(export_message))
                            end
                            export_message = $"{tostring(export_message == "" ? "" : $"{export_message}\n")}[{os.date("%H:%M:%S", timestamp.timestamp)}] {tostring(used_messages[timestamp.index].user ? shadovis(players.user()).name : player.name)}: {used_messages[timestamp.index].message}"
                            chat_commandref:readonly(used_messages[timestamp.index].user ? shadovis(players.user()).actual_name : player.name, used_messages[timestamp.index].message)
                        end
                        used_messages = messages
                    until #used_messages == 0
                end, function()
                    for chat_commandref:getChildren() as commandref do commandref:delete() end
                end)
            end
            if commandrefs[4].preferenceshowname.value then
                player_root:readonly("Name", player.name)
            end
            if commandrefs[4].preferenceshowrockstarid.value then
                player_root:readonly("Rockstar ID", player.rockstar_id)
            end
            if commandrefs[4].preferenceshowhosttoken.value then
                player_root:readonly("Host Token", player.host_token)
            end
            if commandrefs[4].preferenceshowgeoip.value != 1 then
                if (geo_ip := players.geo_ip(player.ip, commandrefs[4].preferenceshowgeoip.value == 2)) != "" then
                    player_root:readonly("GeoIP", geo_ip)
                    player_root:readonly("VPN", player.vpn ? "True" : "False")
                else
                    player_root:readonly("GeoIP", "N/A")
                end
            end
            if commandrefs[4].preferenceshowip.value then
                player_root:readonly("IP Address", player.ip != 0 ? util.ip_to_string(player.ip) : "N/A")
            end
            if commandrefs[4].preferenceshowclassification.value then
                player_root:readonly("Classification", player.classification or "None")
            end
            if commandrefs[4].preferenceshowseenat.value then
                player_root:readonly(all_players[player.rockstar_id].seen_first == all_players[player.rockstar_id].seen_last and "Seen" or "First Seen", os.date("%H:%M:%S", all_players[player.rockstar_id].seen_first))
                if all_players[player.rockstar_id].seen_first != all_players[player.rockstar_id].seen_last then
                    player_root:readonly("Last Seen", os.date("%H:%M:%S", all_players[player.rockstar_id].seen_last))
                end
            end

            player_root:action("Delete", {}, "", function()
                all_players[player.rockstar_id].detections = {}
                player_root:delete()
            end)
            local commandref = player_root:divider("Detections")

            detectionmemory_create_player_entry(player)
            if commandrefs[4].preferenceupdatelive.value then
                commandref:onTickInViewport(|| -> detectionmemory_create_player_entry(player))
            end
        end, function()
            for menu.rbrp(root, player.name):getChildren() as commandref do
                commandref:delete()
            end
        end)
        if commandrefs[4].preferenceupdatelive.value then
            local player_commandrefs = commandrefs[4].root_detectionmemory:getChildren()
            for i = 3, #player_commandrefs do
                if !commandref:equals(player_commandrefs[i]) or (i - 3) % menu.rbp("Stand>Settings>Appearance>Max Visible Commands").value != 0 then continue end
                commandref:onTickInViewport(detectionmemory_create_entry)
            end
        end
    end
end

local function detectionmemory_scan(): void
    for players.list_except(true) as player_id do
        local player = shadovis(player_id)
        if !players.exists(player_id) or !player.ready then continue end
        local classifications = player:classification_root()
        if !classifications then continue end
        for classifications:getChildren() as classification do
            if !classification:isValid() then continue end
            local classification_name = lang.get_string(classification.menu_name, "en")
            local detection, detection_extra = string.match(classification_name, "(.-)%s*%(") or classification_name, string.match(classification_name, "%((.-)%)")
            if ignore_this_detection(detection) or detection == "Presence Spoofing" and lang.get_string(classification.help_text, "en") == "This is a pre-emptive detection." then continue end
            for {"Script Host Kick", "Explosive User", "Arcade Game", "Removed Freemode Activity", "Session Breaking", "Service", "Open Interaction Menu", "Flight School", "Lightning Strike For Random Player", "Disable Passive Mode", "Darts", "Impromptu Deathmatch", "Slasher", "Cutscene"} as method do
                if detection == method then continue 2 end
            end

            if !all_players[player.rockstar_id].detections[hash_string(detection)] then
                all_players[player.rockstar_id].detections[hash_string(detection)] = {name = detection, hash = hash_string(detection), extras = {}, fake = {commandref = nil, bypass = false}}
            elseif (commandref := all_players[player.rockstar_id].detections[hash_string(detection)].fake.commandref) and commandref:isValid() and !classification:equals(commandref) then
                commandref:trigger()
                all_players[player.rockstar_id].detections[hash_string(detection)].fake.commandref, all_players[player.rockstar_id].detections[hash_string(detection)].fake.bypass = nil, false
            end

            if !detection_extra then continue end
            for all_players[player.rockstar_id].detections[hash_string(detection)].extras as extra do
                if detection_extra == extra then continue 2 end
            end
            all_players[player.rockstar_id].detections[hash_string(detection)].extras[#all_players[player.rockstar_id].detections[hash_string(detection)].extras + 1] = detection_extra
        end

        util.yield()
    end
end

local function detectionmemory_check(): void
    if commandrefs[4].detectionmemory.value then
        detectionmemory_create_entry()
    end
end

function functions.is_player_fading(player_id: int): bool
    return players.exists(player_id) and NETWORK_IS_PLAYER_FADING(player_id) and !check_player_data(player_id, true)
end

function spectate_if_needed(player_id: int, override: ?bool = false, callback: ?function = function() end): void
    if !players.exists(player_id) then return end
    local should_spectate, spectating_beforehand = override or (
        GET_ENTITY_HEIGHT_ABOVE_GROUND(players.get_ped(player_id)) <= 0.0 or
        IS_REMOTE_PLAYER_IN_NON_CLONED_VEHICLE(player_id) and
        players.get_vehicle(player_id, false) == nil
    ), menu.rbrp(menu.pr(player_id), "Spectate>Nuts Method").value
    if should_spectate then
        if spectateplayer != nil and spectateplayer != player_id then repeat util.yield() until spectateplayer == nil or spectateplayer == player_id end
        if !players.exists(player_id) then return end
        if !menu.rbrp(menu.pr(player_id), "Spectate>Nuts Method").value then
            spectateplayer = player_id
            util.wait_time(10, function()
                if commandrefs[4].thirdeyeoverlay.value then
                    directx[commandrefs[4].thirdeyedraw.value != 3 ? "draw_text_with_shadow" : "draw_text_with_outline"](commandrefs[4].textpositionthirdeyex.value, commandrefs[4].textpositionthirdeyey.value, "Opening the third eye...", ALIGN_CENTRE, 0.9, colours.thirdeye, commandrefs[4].thirdeyedraw.value != 3 ? (commandrefs[4].thirdeyedraw.value == 2 ? commandrefs[4].shadowdepth.value : 0) : colours.thirdeyeoutline)
                end
                menu.rbrp(menu.pr(player_id), "Spectate>Nuts Method").value = true
                return players.exists(player_id) and GET_ENTITY_HEIGHT_ABOVE_GROUND(players.get_ped(player_id)) > 0.0
            end)
        end
    end
    if GET_ENTITY_HEIGHT_ABOVE_GROUND(players.get_ped(player_id)) > 0.0 then
        local continue_running = true
        util.create_tick_handler(function()
            if !(should_spectate and continue_running) then return false end
            menu.rbrp(menu.pr(player_id), "Spectate>Nuts Method").value = true
        end)
        try
            callback()
        catch error then
            util.notify(error, true, true, true)
        end
        continue_running = false
    end
    if spectateplayer == player_id then
        spectateplayer = nil
        util.yield(100)
        menu.rbrp(menu.pr(player_id), "Spectate>Nuts Method").value = spectating_beforehand
    end
end

local function execute_macro(macro_path: string): void
    local ran = false
    for macros as macro do
        if macro_path != macro.path then continue end
        for macro.macro as data do
            for i = 1, (type(data.button) == "table" and data.button[2] or 1) do
                SET_CONTROL_VALUE_NEXT_FRAME(2, type(data.button) == "table" and data.button[1] or data.button, 1)
                if type(data.button) == "table" then
                    util.yield(25)
                end
            end
            util.yield(data?.wait or 0)
        end
        ran = true
    break end
    if !ran then util.notify("Something went wrong trying to run this macro.") end
end

local function create_ped(hash: ?int, godmode: ?bool = true, collision: ?bool = true, weapon_hash: ?int|string, always_exist: ?int)
    local ped = hash and IS_MODEL_VALID(hash) and entities.create_ped(28, hash, players.get_position(players.user()), 0) or CREATE_RANDOM_PED(players.get_position(players.user()))
    weapon_hash = type(weapon_hash) == "string" ? util.joaat(weapon_hash) : weapon_hash
    SET_ENTITY_AS_MISSION_ENTITY(ped, true, false)
    request_entity_control(ped, 1, false)
    SET_ENTITY_CAN_BE_DAMAGED(ped, !godmode)
    SET_ENTITY_HAS_GRAVITY(ped, collision)
    SET_ENTITY_COLLISION(ped, collision, true)
    if weapon_hash and IS_WEAPON_VALID(weapon_hash) then
        GIVE_WEAPON_TO_PED(ped, weapon_hash, 9999, false, false)
        SET_CURRENT_PED_WEAPON(ped, weapon_hash, true)
        SET_PED_ACCURACY(ped, 100)
    end
    if always_exist and players.exists(always_exist) then
        local network_id = NETWORK_GET_NETWORK_ID_FROM_ENTITY(ped)
        SET_NETWORK_ID_ALWAYS_EXISTS_FOR_PLAYER(network_id, players.user(), true)
        SET_NETWORK_ID_ALWAYS_EXISTS_FOR_PLAYER(network_id, always_exist, true)
    end
    return ped
end

local function fakefriend_create_ref(player_data: table): void
    local player_root, path, timeout = commandrefs[4].root_fake_friends:list(player_data?.name or tostring(player_data.rockstar_id), {}, $"{tostring(player_data?.name ? $"Name: {player_data.name}\n" : "")}"..$"Rockstar ID: {player_data.rockstar_id}"), player_data?.name ? menu.ref_player_history(player_data.name) : fake_commandref, 0
    if player_data?.name then
        if path:isValid() then
            player_root:link(path)
            player_root:onTickInViewport(function()
                if util.current_time_millis() < timeout or menu_version != 3 then return end
                local wait_for_result, current_state = path:getState() != "", path:getState()
                if wait_for_result then
                    player_root.menu_name = $"{player_data.name} [{path:getState()}]"
                    player_root.help_text = $"Name: {player_data.name}\nRockstar ID: {player_data.rockstar_id}{tostring(path.help_text != "" ? $"\n{path.help_text}" : "")}"
                end
                timeout = math.huge
                util.wait_time(5, function() return wait_for_result and path:getState() != current_state end)
                timeout = util.current_time_millis() + 10000
                if !player_root:isValid() or !path:isValid() then return end
                player_root.menu_name = $"{player_data.name} [{path:getState()}]"
                player_root.help_text = $"Name: {player_data.name}\nRockstar ID: {player_data.rockstar_id}{tostring(path.help_text != "" ? $"\n{path.help_text}" : "")}"
            end)
        end
        player_root:readonly("Username", player_data.name)
    end
    player_root:readonly("Rockstar ID", player_data.rockstar_id)
    player_root:action("Join", {}, "", function()
        for players.list() as player_id do
            if shadovis(player_id).rockstar_id == player_data.rockstar_id then
                util.notify($"You are already in {tostring(player_data?.name or player_data.rockstar_id)}'s session.") return
            end
        end
        if path:isValid() and (join_commandref := menu.rbrp(path, "Session>Join")):isValid() then
            util.notify($"Attempting to join {tostring(player_data?.name or player_data.rockstar_id)} directly.")
            join_commandref:trigger()
        else
            util.notify($"Attempting to join {tostring(player_data?.name or player_data.rockstar_id)} through their rockstar id.")
            menu.trigger_commands($"ridjoin {player_data.rockstar_id}")
        end
    end)
    player_root:action("Invite", {}, "", function()
        for players.list() as player_id do
            if shadovis(player_id).rockstar_id == player_data.rockstar_id then
                util.notify($"{tostring(player_data?.name or player_data.rockstar_id)} is already in your session.") return
            end
        end
        if path:isValid() and (invite_commandref := menu.rbrp(path, "Invite To Session")):isValid() then
            util.notify($"Inviting {tostring(player_data?.name or player_data.rockstar_id)} directly.")
            invite_commandref:trigger()
        else
            util.notify($"Inviting {tostring(player_data?.name or player_data.rockstar_id)} through their rockstar id.")
            menu.trigger_commands($"ridinvite {player_data.rockstar_id}")
        end
    end)
    player_root:action("Unfriend", {}, "", function()
        playerinfo[player_data.rockstar_id].friend = false
        player_root:delete()

        local friends = 0
        for playerinfo as player_information do
            if !player_information.friend then continue end
            ++friends
        end
        if friends == 0 then
            commandrefs[4].fakefriend_divider:delete()
        else
            commandrefs[4].fakefriend_divider.menu_name = $"Fake Friends ({friends})"
        end
    end)
end

local function execute_modules(exec_type: string, module_override: ?string, ...arguments): void
    if module_functions[exec_type] == nil or module_override != nil and module_functions[exec_type][module_override] == nil then return end
    util.create_tick_handler(function()
        for module_functions[exec_type] as module do
            if !module.state or module_override != nil and module.name != module_override then continue end
            for module.functions as callback do
                try
                    callback(table.unpack(arguments))
                catch error then
                    util.notify($"Module: {module.name}, Function: {exec_type}; Failed to execute: {error}", commandrefs[4].reportmoduleerrors.value, commandrefs[4].reportmoduleerrors.value, commandrefs[4].reportmoduleerrors.value)
                end
            end
            if module_override != nil and module.name == module_override then break end
        end
        return false
    end)
end

local function load_module(module: string): bool
    local module_function_list = {}
    for name, _ in module_functions do
        if name == "loaded" or name == "autoload" then continue end
        module_function_list[#module_function_list + 1] = name
    end

    if !module_functions.loaded[module] then
        local output; try
            output = require(module)
        catch error then
            util.notify($"Module: {module}; Failed to load: {error}", commandrefs[4].reportmoduleerrors.value, commandrefs[4].reportmoduleerrors.value, commandrefs[4].reportmoduleerrors.value) return false
        end

        if type(output) == "table" then
            if type(output?.minimum_shadovis_version) == "string" and compareversions(output.minimum_shadovis_version, lua_version) == 1 then
                util.notify($"Module: {module}; Is asking for the Lua version to atleast be {output.minimum_shadovis_version}.")
                return false
            elseif type(output?.maximum_shadovis_version) == "string" and compareversions(output.maximum_shadovis_version, lua_version) == -1 then
                util.notify($"Module: {module}; Is asking for the Lua version to be {output.maximum_shadovis_version}.")
                return false
            elseif type(output?.minimum_stand_version) == "string" and compareversions(output.minimum_stand_version, menu.get_version().version) == 1 then
                util.notify($"Module: {module}; Is asking for the Stand version to atleast be {output.minimum_stand_version}.")
                return false
            elseif type(output?.maximum_stand_version) == "string" and compareversions(output.maximum_stand_version, menu.get_version().version) == -1 then
                util.notify($"Module: {module}; Is asking for the Stand version to be {output.maximum_stand_version}.")
                return false
            elseif type(output?.recommended_game_version) == "string" and compareversions(output.recommended_game_version, menu.get_version().game) != 0 then
                util.notify($"Module: {module}; Is asking for the game version to be {output.recommended_game_version}.")
                return false
            elseif output?.globals_upto_date == true and global_compatibility_mode then
                util.notify($"Module: {module}; Is asking for the globals to be upto date.")
                return false
            end
        else
            util.notify($"Module: {module}; No matching output found, is this an error?", commandrefs[4].reportmoduleerrors.value, commandrefs[4].reportmoduleerrors.value, commandrefs[4].reportmoduleerrors.value)
        end

        for module_function_list as module_function_name do
            if type(output) != "table" then break end
            if !output?[module_function_name] then continue end
            module_functions[module_function_name][module] = {name = module, state = true, functions = {}}
            if type(output[module_function_name]) == "table" then
                for output[module_function_name] as module_function do
                    if type(module_function) != "function" then continue end
                    module_functions[module_function_name][module].functions[#module_functions[module_function_name][module].functions + 1] = module_function
                end
            elseif type(output[module_function_name]) == "function" then
                module_functions[module_function_name][module].functions[#module_functions[module_function_name][module].functions + 1] = output[module_function_name]
            end
        end
    else
        for module_function_list as module_function_name do
            if module_functions[module_function_name][module] == nil then continue end
            module_functions[module_function_name][module].state = true
        end
    end

    if module_functions.start[module] != nil then
        execute_modules("start", module, module_functions.loaded[module] != true, commandrefs[4][$"root_module_{module}"])
        if module_functions.loaded[module] != true and (module_functions.autoload[module] or {}):size() > 0 then
            util.yield(100) -- assume a max time of 100ms
            local total_values_set = 0
            for path, value in module_functions.autoload[module] do
                local commandref = menu.rbrp(commandrefs[4][$"root_module_{module}"], path)
                if !commandref:isValid() then continue end

                local commandref_type = switch commandref:getType() do
                    case COMMAND_TOGGLE_NO_CORRELATION -> 1
                    case COMMAND_TOGGLE -> 1
                    case COMMAND_TOGGLE_CUSTOM -> 1
                    case COMMAND_SLIDER -> 2
                    case COMMAND_SLIDER_FLOAT -> 2
                    case COMMAND_INPUT -> 3
                    case COMMAND_TEXTSLIDER -> 3
                    case COMMAND_TEXTSLIDER_STATEFUL -> 3
                    case COMMAND_LIST_SELECT -> 4
                    default -> -1
                end
                if commandref_type == -1 then continue end

                if commandref_type == 1 and (value == "On" or value == "Off") then
                    commandref.value = value == "On"
                    ++total_values_set
                elseif commandref_type == 2 and tonumber(value) != nil then
                    commandref.value = tonumber(value)
                    ++total_values_set
                elseif commandref_type == 3 then
                    commandref:trigger(value)
                    ++total_values_set
                elseif commandref_type == 4 and menu.rbrp(commandref, value):isValid() then
                    menu.rbrp(commandref, value):trigger()
                    ++total_values_set
                end
            end
        end
    end

    if script_start and module_functions.on_join[module] != nil then
        for players.list() as player_id do
            local player = shadovis(player_id)
            while players.exists(player_id) and !player.ready do util.yield() end
            if !players.exists(player_id) then continue end
            execute_modules("on_join", module, player_id, menu.pr(player_id), player.commandrefs.friendly, player.commandrefs.trolling, player.commandrefs.misc)
        end
    end

    module_functions.loaded[module] = true
    return true
end

local function stop_module(module: string): void
    local module_function_list = {}
    for name, _ in module_functions do
        if name == "loaded" then continue end
        module_function_list[#module_function_list + 1] = name
    end

    if module_functions.stop[module] != nil then
        for players.list() as player_id do
            if !players.exists(player_id) then continue end
            execute_modules("on_leave", module, player_id)
        end
        execute_modules("stop", module, false, commandrefs[4][$"root_module_{module}"])
    end

    for module_function_list as module_function_name do
        if type(module_functions[module_function_name][module]) != "table" then continue end
        module_functions[module_function_name][module].state = false
    end
end

function play_sound_file(file_path: string, wait_for_finish: ?bool = false): bool
    if !(filesystem.exists(file_path) and filesystem.is_regular_file(file_path)) then return false end
    for sound_management.instances as instance do
        if instance.playback?:isPlaying?() then continue end
        if instance.file_path != file_path then
            instance.file_reader, instance.file_path = soup.FileReader(file_path), file_path
        end
        local wav = soup.audWav(instance.file_reader)
        local playback =  sound_management.device:open(wav.channels)
        instance.playback = playback
        sound_management.mixer:setOutput(instance.playback)
        sound_management.mixer:playSound(wav)
        if wait_for_finish then
            while playback?:isPlaying?() do util.yield() end
        end
        return wait_for_finish or playback
    end return false
end



for i = 0, 31 do
    local player = {player_id = i, ready = false, first_seen = 0, last_seen = 0, name = "", actual_name = nil, rockstar_id = nil, ip = nil, port = nil, friend = nil, crew = nil, root_classification = nil, root_history = nil, vpn = nil, kick_active = nil, crash_active = nil, blockingloveletters = nil, kills = 0, deaths = 0, ping = {}, packet_loss = {}, unstable = {state = nil, amount = 0, timeout = 0}, otr = {active = nil, time = nil, blip = nil}, dead = nil, antitp = {position = nil, nearby = nil, interior = {state = nil, time = 0}, cutscene = {state = nil, time = 0}, dead = {state = nil, time = 0}, transition = {state = nil, time = 0}, timeout = {state = nil, time = 0, ref_time = 0}, vehicle = {state = nil, last_state = nil, vehicle = nil, last_vehicle = nil, time = 0}, attached = {state = nil, time = 0}}, ghost = nil, shghosted = nil, ghosted = nil, toggle_loops = {}, blockedjoin = nil, vehicletakeover = 0, ped_health = 0, hostshare = 0, detections = {}, commandrefs = {}, stand_user = false, personal_vehicle = nil, previous_personal_vehicle = nil, org_manage_delay = 0}

    function player:ready_data(): void
        self.first_seen, self.last_seen = util.current_time_millis(), 0
        self.name, self.rockstar_id = players.get_name(self.player_id), players.get_rockstar_id(self.player_id)
        self.actual_name = players.get_name(self.player_id, true)
        self.host_token = players.get_host_token_hex(self.player_id)
        self.vpn = players.is_using_vpn(self.player_id)
        self.ip = players.get_ip(self.player_id) != 4294967295 ? players.get_ip(self.player_id) : 0
        self.port = self.ip != 0 ? players.get_port(self.player_id) : 0

        self.friend, self.crew = false, false
        for players.list_only(false, true, false, false) as pid do
            if player_id != pid then continue end
            self.friend = true
        break end

        for players.list_only(false, false, true, false) as pid do
            if player_id != pid then continue end
            self.crew = true
        break end

        self.kills, self.deaths = 0, 0
        self.ping, self.packet_loss = {}, {}
        self.unstable.state, self.unstable.amount, self.unstable.timeout = false, 0, 0
        
        self.root_history = all_players[self.rockstar_id]?.history_root
        self.kick_active = false
        self.crash_active = false
        self.blockingloveletters = false
        self.otr.active = false
        self.otr.time = 0
        self.dead = false
        self.ghost = false
        self.shghosted = false
        self.ghosted = false
        self.toggle_loops = {}
        self.vehicletakeover = 0
        self.ped_health = 0
        self.hostshare = 0
        self.detections, self.commandrefs = {}, {}
        self.stand_user = false
        self.personal_vehicle, self.previous_personal_vehicle = nil, nil
        self.org_manage_delay = 0

        self.antitp.position = v3.new()
        self.antitp.nearby = false
        self.antitp.interior.state, self.antitp.interior.time = false, -1
        self.antitp.cutscene.state, self.antitp.cutscene.time = false, -1
        self.antitp.dead.state, self.antitp.dead.time = false, -1
        self.antitp.transition.state, self.antitp.transition.time = false, -1
        self.antitp.timeout.state, self.antitp.timeout.time, self.antitp.timeout.ref_time = false, -1, -1
        self.antitp.vehicle.state, self.antitp.vehicle.last_state, self.antitp.vehicle.vehicle, self.antitp.vehicle.last_vehicle, self.antitp.vehicle.time = false, false, nil, nil, -1
        self.antitp.attached.state, self.antitp.attached.time = false, -1

        if playerinfo[self.rockstar_id] != nil and (!playerinfo[self.rockstar_id].name or playerinfo[self.rockstar_id].name != self.actual_name) then
            playerinfo[self.rockstar_id].name = self.actual_name
        end

        if self.player_id != players.user() and !all_players[self.rockstar_id] then
            all_players[self.rockstar_id] = {name = self.actual_name, rockstar_id = self.rockstar_id, ip = self.ip, vpn = self.vpn, host_token = self.host_token, history_root = nil, seen_amount = 0, seen_first = 0, seen_last = 0, session = session, removed = false, remove_reason = nil, detections = {}, messages = {}, players = {}, classification = nil}
            all_players[self.rockstar_id].history_root = self:history_root()
        end

        self.blockedjoin = self:blocked_join()
        self.ready = true
    end

    function player:applicable(): bool
        for {0x9E69C8D, 0xD1FF4D4} as rid do
            if self.rockstar_id != rid then continue end
            return false
        end return true
    end

    function player:active_detections(): int
        if !players.exists(self.player_id) then return 0 end
        local amount = 0
        for self.detections as detection do
            if !detection:isValid() then continue end
            ++amount
        end
        return amount
    end

    function player:classification_root(): ?int
        if !(players.exists(self.player_id) and menu.pr(self.player_id):isValid()) then return end
        if self.root_classification == nil or !self.root_classification:isValid() then
            for menu.pr(self.player_id):getChildren() as commandref do
                if commandref:getType() != COMMAND_LIST_CUSTOM_SPECIAL_MEANING or string.match(commandref.menu_name, "(.-)%s*%:") != "Classification" then continue end
                self.root_classification = commandref
            end
        end
        return self.root_classification
    end

    function player:classification_root(): ?int
        if !players.exists(self.player_id) or !menu.pr(self.player_id):isValid() then return end
        if (self.root_classification == nil or !self.root_classification:isValid()) and players.detections_root(self.player_id)?:isValid?() then
            self.root_classification = players.detections_root(self.player_id)
        end
        return self.root_classification
    end

    function player:has_classification(classification: string, strict: ?bool = true, return_commandref: ?bool = false): bool
        if !players.exists(self.player_id) or !self:classification_root():isValid() then return false end

        if strict then
            return menu.rbrp(self:classification_root(), classification):isValid()
        end
        
        local detection = string.match(classification, "(.-)%s*%(") or classification
        for self:classification_root():getChildren() as commandref do
            local menu_name = commandref:isValid() ? commandref.menu_name : nil
            local name = menu_name != nil ? lang.get_string(menu_name, "en") : ""
            if (name:match("(.-)%s*%(") or name) == detection then return return_commandref ? commandref : true end
        end
        return return_commandref ? fake_commandref : false
    end

    function player:add_detection(name: string, extra: ?string): void
        if !players.exists(self.player_id) or type(detections[name]) != "table" then return end

        local function player_affected(name: string): table
            local output = {notify = false, log = false, console = false, allchat = false, teamchat = false}
            for {"notify", "log", "console", "allchat", "teamchat"} as option do
                if detections[name]?.options?[option] == nil then continue end
                output[option] = detections[name].options[option] and (detections[name].options[option] == 1 or detections[name].options[option] == 2 and self.player_id != players.user() or detections[name].options[option] == 3 and self.player_id != players.user() and !(self.friend or commandrefs[4].preferencefakefriend.value and self:fakefriend() or commandrefs[4].preferencewhitelistjoin.value and self:whitelistedjoin()))
            end
            return output
        end

        local detection, detection_name = detections[name], extra ? $"{detections[name].name} ({extra})" : detections[name].name
        local {log, console, notify, allchat, teamchat} = player_affected(name)
        local toast_flag, add_detection, backup = ((log ? TOAST_FILE : 0)|(console ? TOAST_CONSOLE : 0)|((notify and commandrefs[4].notificationmasterswitch.value) ? TOAST_DEFAULT : 0)|(allchat ? TOAST_CHAT : 0)|(teamchat ? TOAST_CHAT_TEAM : 0)), !self:has_classification(detection.name, !extra), false

        if (add_detection or !menu.get_current_position():getParent():equals(self:classification_root())) and commandref := players.add_detection(self.player_id, detection_name, add_detection and toast_flag or 0, add_detection ? detection.severity : 0) then
            if !add_detection and commandref:isValid() then
                commandref:trigger()
            elseif add_detection and commandref:isValid() then
                self.detections[#self.detections + 1] = commandref
            end
            if !commandref:isValid() then backup = true end
        elseif !add_detection then backup = true end
        local spam_level, prefered_level = detection?.spam or 1, commandrefs[4].preferencespamlevel.value
        if backup and (prefered_level == 1 or prefered_level == 2 and spam_level != 3 or prefered_level == 3 and spam_level == 1) then
            util.toast($"{self.name} triggered a detection: {detection_name}", toast_flag)
        end
        execute_modules("on_detection", nil, player_id, detection, extra)
    end

    function player:history_root(): ?int
        if !players.exists(self.player_id) or self.player_id == players.user() then return end
        if self.root_history == nil or not self.root_history:isValid() then
            if self.actual_name and commandrefs[4].preferenceplayerhistorysoftest.value then
                self.root_history = menu.ref_player_history(self.actual_name)
            end
            if (self.root_history == nil or !self.root_history:isValid()) and self.actual_name and commandrefs[4].preferenceplayerhistorysoft.value then
                local path = menu.rbcn($"historynote{self.actual_name}")
                self.root_history = path:isValid() and path:getParent() or nil
            end
            if (self.root_history == nil or !self.root_history:isValid()) and commandrefs[4].preferenceplayerhistoryhard.value then
                functions.queue_function("playerhistory", 0, function()
                    menu.focus_on_commandref(menu.rbrp(menu.pr(self.player_id), "In Player History"), 2, 0, function()
                        self.root_history = menu.get_current_menu_list()
                    end)
                end)
            end
        end
        return self.root_history
    end

    function player:history_edit(entries: table): void
        if !players.exists(self.player_id) or self.player_id == players.user() then return end

        local commandref = self:history_root()
        for entries as entry do
            local path = menu.rbrp(commandref, entry.path)
            if !path:isValid() then
                if entry.path == "Whitelist Join" and !entry.state then continue end
                functions.queue_function("playerhistory", 0, function()
                    menu.focus_on_commandref(self:history_root(), 2, 0)
                end)
                path = menu.rbrp(commandref, entry.path)
                if !path:isValid() then continue end
            end
            if path.value == entry.state then continue end
            if type(entry.state) == "string" then
                path:trigger(entry.state)
            else
                path.value = entry.state
            end
        end
    end

    function player:fakefriend(): bool
        if !players.exists(self.player_id) or self.player_id == players.user() then return false end
        if playerinfo[self.rockstar_id]?.friend then return true end
        local commandref = self:history_root()
        if !(commandref and commandref:isValid()) then return false end
        if !menu.rbrp(commandref, "Tracking"):isValid() then
            for commandref:getChildren() as i do end
        end
        return menu.rbrp(commandref, "Tracking").value == 2 or false
    end

    function player:whitelistedjoin(): bool
        if !players.exists(self.player_id) or self.player_id == players.user() then return false end
        local commandref = self:history_root()
        if !(commandref and commandref:isValid()) then return false end
        if !menu.rbrp(commandref, "Whitelist Join"):isValid() then
            for commandref:getChildren() as i do end
        end
        return menu.rbrp(commandref, "Whitelist Join").value or false
    end

    function player:blocked_join(): bool
        if !players.exists(self.player_id) or self.player_id == players.user() then return false end
        local commandref = self:history_root()
        if !(commandref and commandref:isValid()) then return false end
        if !menu.rbrp(commandref, "Player Join Reactions>Block Join"):isValid() then
            for commandref:getChildren() as i do end
        end
        return menu.rbrp(commandref, "Player Join Reactions>Block Join").value or false
    end

    function player:kick(manual: ?bool = false, wait_for_result: ?bool = false, add_to_removed_list: ?bool = true, reason: ?string = "", hostshare: ?bool = true, override_kick: ?string = ""): ?bool
        if !(players.exists(self.player_id) and shadovis(self.player_id).ready) then return false end
        if self.player_id == players.user() then util.notify("You can't kick yourself.", false, false, commandrefs[4].kicknotificationonfail.value) return false end
        if !self:applicable() then util.notify($"Couldn't kick {self.name}{tostring(reason != "" ? $" {reason}" : "")}.", false, false, commandrefs[4].kicknotificationonfail.value) return false end
        if players.get_host() == self.player_id and !manual and players.is_preferred_as_modder(self.player_id) and commandrefs[4].kickneverchallengemodderhost.value then return false end

        if add_to_removed_list then
            all_players[self.rockstar_id].removed = true
            all_players[self.rockstar_id].remove_reason = all_players[self.rockstar_id].remove_reason == nil ? reason != "" ? $"{reason:upper(1)}." : nil : all_players[self.rockstar_id].remove_reason
        end

        local function kick(manual, reason, hostshare): bool
            while players.exists(self.player_id) and players.get_script_host() == -1 and !util.in_session() and !self.kick_active do
                util.yield()
            end
            if players.get_script_host() == -1 and !players.exists(self.player_id) then
                util.notify($"Couldn't kick {self.name}{tostring(reason != "" ? $" {reason}" : "")}.\nThey left before you fully joined.", false, true, commandrefs[4].kicknotificationonfail.value)
                return false
            end
            if !players.exists(self.player_id) or players.get_host() == self.player_id and !manual and players.is_preferred_as_modder(self.player_id) and commandrefs[4].kickneverchallengemodderhost.value then return false end

            if self.kick_active then
                util.notify($"A kick is already ongoing for {self.name}, please wait for it to finish.", manual, manual, manual and commandrefs[4].kicknotificationonfail.value)
                return false
            end
            self.kick_active = true

            local kick_type = players.get_host() == players.user() and "nonhostashost" or players.get_host() == self.player_id and "hostasnonhost" or "nonhostasnonhost"
            local selection = kicks[kick_type]
            local method, cooldown, timeoutoverride = nil, nil, -1

            if selection[commandrefs[4][$"kick{kick_type}"].value].name == "Love Letter" and commandrefs[4].kicksmartblockloveletters.value and shadovis(players.get_host()).blockingloveletters then
                selection = selection[1]
            else
                selection = selection[commandrefs[4][$"kick{kick_type}"].value]
            end

            if !manual and selection.name == "Love Letter" and shadovis(players.get_host()).blockingloveletters then
                self.kick_active = false
            return end

            if override_kick != "" then
                method, cooldown = override_kick, 15
            elseif hostshare and kick_type == "nonhostasnonhost" and players.is_stand_user(players.get_host()) and (commandrefs[4].hostsharetestfriends.value and (shadovis(players.get_host()).friend or shadovis(players.get_host()):fakefriend()) or commandrefs[4].hostshareteststrangers.value and !(shadovis(players.get_host()).friend or shadovis(players.get_host()):fakefriend())) then
                method, cooldown, timeoutoverride = "Smart", 5, 5
            end
            
            util.notify(successfulcommand, false, false, manual)

            method, cooldown = method or selection.name, cooldown or selection.cooldown
            for attempt = 1, ((timeoutoverride == -1 ? commandrefs[4].kicktimeout.value : timeoutoverride) / cooldown) do
                if commandrefs[4].kickprolongloveletter.value and (method == "Smart" or method == "Love Letter") and kick_type != "nonhostashost" then
                    functions.queue_function("loveletterkick", 15, function() menu.rbrp(menu.pr(self.player_id), $"Kick>{method}"):trigger() end, function() return !players.exists(self.player_id) or (method == "Love Letter" and players.get_host() == self.player_id) end)
                else
                    menu.rbrp(menu.pr(self.player_id), $"Kick>{method}"):trigger()
                end
                util.wait_time(cooldown, function()
                    return !players.exists(self.player_id) or (method == "Love Letter" and players.get_host() == self.player_id)
                end)
                if !players.exists(self.player_id) or method == "Love Letter" and shadovis(players.get_host()).blockingloveletters then break end
                if method == "Love Letter" and players.get_host() == self.player_id then
                    util.notify($"Exited kick early due to {self.name} becoming the host.\nMethod: {method}", true, true, commandrefs[4].kicknotificationonfail.value)
                    self.kick_active = false
                    return false
                end
            end

            self.kick_active = false
            if !util.can_continue() then
                util.notify($"Stopped trying to kick {self.name}.\nMethod: {method}", false, true, commandrefs[4].kicknotificationonfail.value)
            return false end

            if players.exists(self.player_id) and method == "Love Letter" then
                shadovis(players.get_host()).blockingloveletters = true
                do_affected_detection(players.get_host(), "loveletterblock")
                if commandrefs[4].kicksmartblockloveletters.value then
                    util.notify($"The host is blocking Love Letter kicks, attempting a Smart kick on {self.name}.", false, true, commandrefs[4].kicknotificationonfail.value)
                    return self:kick(false, true, false, reason, hostshare)
                end
            end

            if hostshare and method == "Smart" and kick_type == "nonhostasnonhost" and players.is_stand_user(players.get_host()) and timeoutoverride == 5 and cooldown == 5 then
                if players.exists(self.player_id) and commandrefs[4].hostsharepreferredkick.value and kicks[kick_type][commandrefs[4][$"kick{kick_type}"].value].name != "Smart" then
                    return self:kick(false, true, false, reason, false)
                elseif !players.exists(self.player_id) then
                    ++shadovis(players.get_host()).hostshare
                end
                if shadovis(players.get_host()).hostshare > 2 then
                    do_affected_detection(players.get_host(), "hostshare")
                end
            end

            local total_players_1, total_players_2 = 0, 0
            for i = 1, 2 do
                for player_list as player_data do
                    if player_data.player_id == self.player_id or player_data.player_id == players.user() then continue end
                    if i == 1 and (util.current_time_millis() - player_data.last_seen) < 500 then
                        ++total_players_1
                    elseif i == 2 and players.exists(player_data.player_id) then
                        ++total_players_2
                    end
                end
            end
            local entropy_chance = (100 / (total_players_1 > 0 ? total_players_1 : 1) * (total_players_2 > 0 ? total_players_2 : 1))
            entropy_chance = entropy_chance > 100 ? 100 : entropy_chance
            local entropy = entropy_chance >= 50

            util.notify($"{tostring(!entropy or players.exists(self.player_id) ? "Couldn't kick" : "Kicked")} {self.name}{tostring(reason != "" ? $" {reason}" : "")}.\nMethod: {method}{tostring(commandrefs[4].kicknotificationconfidence.value ? $"\nConfidence: {math.float_to_int(entropy ? entropy_chance : 100 - entropy_chance)}" : "")}", true, true, !entropy or players.exists(self.player_id) ? commandrefs[4].kicknotificationonfail.value : commandrefs[4].kicknotificationonsucces.value)
            return !(!entropy or players.exists(self.player_id))
        end

        if wait_for_result then
            return kick(manual, reason, hostshare)
        else
            util.create_tick_handler(function()
                kick(manual, reason, hostshare)
                return false
            end)
            return true
        end
    end

    function player:crash(manual: bool, wait_for_result: ?bool = false, add_to_removed_list: bool, reason: ?string = "", override_crash: ?string = ""): ?bool
        if !(players.exists(self.player_id) and shadovis(self.player_id).ready) then return false end
        if self.player_id == players.user() then util.notify("You can't crash yourself.", false, false, commandrefs[4].crashnotificationonfail.value) return false end
        if !self:applicable() then util.notify($"Couldn't crash {self.name}{tostring(reason != "" ? $" {reason}" : "")}.", false, false, commandrefs[4].crashnotificationonfail.value) return false end

        if add_to_removed_list then
            all_players[self.rockstar_id].removed = true
            all_players[self.rockstar_id].remove_reason = all_players[self.rockstar_id].remove_reason == nil ? reason != "" ? $"{reason:upper(1)}." : nil : all_players[self.rockstar_id].remove_reason
        end

        local function crash(manual, reason): bool
            while players.exists(self.player_id) and !util.in_session() and !self.crash_active do
                util.yield()
            end
            if !(util.in_session() and players.exists(self.player_id)) then
                util.notify($"Couldn't crash {self.name}{tostring(reason != "" ? $" {reason}" : "")}.\nThey left before you spawned in.", false, true, commandrefs[4].crashnotificationonfail.value)
                return false
            end
            while players.exists(self.player_id) and !players.valid_position(self.player_id) do
                util.yield()
            end
            if !(players.valid_position(self.player_id) or players.exists(self.player_id)) then
                util.notify($"Couldn't crash {self.name}{tostring(reason != "" ? $" {reason}" : "")}.\nThey left before they loaded in.", false, true, commandrefs[4].crashnotificationonfail.value)
                return false
            end
            if !players.exists(self.player_id) then return false end

            if self.crash_active then
                util.notify($"A crash is already ongoing for {self.name}, please wait for it to finish.", manual, manual, manual and commandrefs[4].crashnotificationonfail.value)
                return false
            end
            self.crash_active = true

            local selection = crashes[commandrefs[4].crash.value]

            if override_crash != "" then
                selection = {name = override_crash, cooldown = 15}
            end

            if selection.name == "Vehicular Manslaughter" and !players.get_vehicle(self.player_id, false) then
                util.notify($"{self.name} is not in a vehicle!", false, false, commandrefs[4].crashnotificationonfail.value)
            return false end

            util.notify(successfulcommand, false, false, manual)

            local method, cooldown = selection.name, selection.cooldown
            for attempt = 1, (commandrefs[4].crashtimeout.value / cooldown) do
                menu.rbrp(menu.pr(self.player_id), $"Crash>{method}"):trigger()
                util.wait_time(cooldown, function()
                    return !players.exists(self.player_id)
                end)
                if !players.exists(self.player_id) then break end
            end

            self.crash_active = false
            if !util.can_continue() then
                util.notify($"Stopped trying to crash {self.name}.\nMethod: {method}", false, true, commandrefs[4].crashnotificationonfail.value)
                return false
            end

            local total_players_1, total_players_2 = 0, 0
            for i = 1, 2 do
                for player_list as player_data do
                    if player_data.player_id == self.player_id or player_data.player_id == players.user() then continue end
                    if i == 1 and (util.current_time_millis() - player_data.last_seen) < 500 then
                        ++total_players_1
                    elseif i == 2 and players.exists(player_data.player_id) then
                        ++total_players_2
                    end
                end
            end
            local entropy_chance = (100 / (total_players_1 > 0 ? total_players_1 : 1) * (total_players_2 > 0 ? total_players_2 : 1))
            entropy_chance = entropy_chance > 100 ? 100 : entropy_chance
            local entropy = entropy_chance >= 50

            util.notify($"{tostring(!entropy or players.exists(self.player_id) ? "Couldn't crash" : "Crashed")} {self.name}{tostring(reason != "" ? $" {reason}" : "")}.\nMethod: {method}{tostring(commandrefs[4].crashnotificationconfidence.value ? $"\nConfidence: {math.float_to_int(entropy ? entropy_chance : 100 - entropy_chance)}" : "")}", true, true, !entropy or players.exists(self.player_id) ? commandrefs[4].crashnotificationonfail.value : commandrefs[4].crashnotificationonsucces.value)
            return !(!entropy or players.exists(self.player_id))
        end

        if wait_for_result then
            local crash_return = crash(manual, reason)
            self.crash_considered = false
            return crash_return
        else
            util.create_tick_handler(function()
                crash(manual, reason)
                return false
            end)
            self.crash_considered = false
            return true
        end
    end

    function player:match_ip(sub_check: ?bool = false, ignore_player_ids: ?table = {}): void
        if !players.exists(self.player_id) then return end
        local player_names, previously_removed = nil, false
        ignore_player_ids[#ignore_player_ids + 1] = self.player_id
        for all_players as player_info do
            if self.rockstar_id == player_info.rockstar_id or self.ip == 0 or self.ip != player_info.ip then continue end

            player_names, previously_removed = player_names != nil ? $"{player_names}, {tostring(player_info.actual_name ? player_info.actual_name : player_info.name)}" : (player_info.actual_name ? player_info.actual_name : player_info.name), player_info.removed or previously_removed
            if !sub_check and #ignore_player_ids > 1 then continue end

            for players.list_except(true) as player_id do
                if shadovis(player_id).rockstar_id != player_info.rockstar_id then continue end
                for ignore_player_ids as ignore_player_id do
                    if ignore_player_id != player_id then continue end
                    break 2
                end
                shadovis(player_id):match_ip(true, ignore_player_ids)
            break end
        end
        if player_names != nil then
            do_affected_detection(self.player_id, "ipmatch", nil, nil, player_names)
            if previously_removed and commandrefs[4].ipmatch_previouslyremoved.value then
                do_affected_detection(self.player_id, "previouslyremoved", (commandrefs[4].previouslyremovedevent.value == 2 or players.exists(players.get_script_host()) and !(commandrefs[4].kickignorejoindetectiononblockjoin.value and self.blockedjoin)), (commandrefs[4].previouslyremovedevent.value == 2 or players.exists(players.get_script_host())))
            end
        end
    end

    function player:match_account(): void
        if !players.exists(self.player_id) then return end

        local previously_removed, player_ids, marked_players = false, players.list_except(true), {}

        for player_ids as player_id do while !all_players[shadovis(player_id).rockstar_id] do util.yield() end end
        for player_ids as player_id do
            local player = shadovis(player_id)
            if self.player_id == player_id or !player.ready or self.ip == 0 or !self.actual_name or !player.actual_name then continue end
            if self.ip != player.ip and compare_strings_similarity(self.actual_name, player.actual_name) < 70 then continue end
            all_players[self.rockstar_id].players[player.rockstar_id], all_players[player.rockstar_id].players[self.rockstar_id] = true, true
        end

        for all_players as player do
            if self.rockstar_id == player.rockstar_id then continue end
            if player.players[self.rockstar_id] then continue end
            local confidence = 0
            if self.actual_name and player.actual_name and compare_strings_similarity(self.actual_name, player.actual_name) >= 70 then confidence += 25 end
            if self.ip != 0 and self.ip == player.ip then
                local current_ips = false
                for player_ids as player_id do
                    if shadovis(player_id).rockstar_id != player.rockstar_id then continue end
                    current_ips = true
                break end
                if !current_ips then confidence += 50 end
            end
            if !self:has_classification("Spoofed Host Token", false) and self.host_token == player.host_token then confidence += 25 end
            if confidence >= 25 then
                marked_players[#marked_players + 1], previously_removed = {id = player.rockstar_id, confidence = confidence}, player.removed or previously_removed
            end
        end

        local most_confident = {id = 0, confidence = 0}
        for marked_players as data do
            if previously_removed and !all_players[data.id].removed or data.confidence <= most_confident.confidence then continue end
            most_confident = data
        end
        if most_confident.id == 0 then return end

        do_affected_detection(self.player_id, "altaccounts", !(commandrefs[4].kickignorejoindetectiononblockjoin.value and self.blockedjoin), nil, $"{all_players[most_confident.id].name} [{most_confident.confidence >= 75 ? "High" : most_confident.confidence >= 50 ? "Medium" : most_confident.confidence >= 25 ? "Low" : "N/A"}]")
        if previously_removed and commandrefs[4].altaccounts_previouslyremoved.value then
            do_affected_detection(self.player_id, "previouslyremoved", (commandrefs[4].previouslyremovedevent.value == 2 or players.exists(players.get_script_host()) and !(commandrefs[4].kickignorejoindetectiononblockjoin.value and self.blockedjoin)), (commandrefs[4].previouslyremovedevent.value == 2 or players.exists(players.get_script_host())))
        end
    end

    function player:is_org_member(): bool
        for players.list_only(false, false, false, true) as pid do
            if self.player_id != pid then continue end
            return true
        end return false
    end

    player_list[i] = player
end



local start_time_commands = util.current_time_millis()

commandrefs[4].root = menu.my_root()
commandrefs[4].root:divider($"Shadovis {lua_version} - {menu_version == 0 ? "Free" : menu_version == 1 ? "Basic" : menu_version == 2 ? "Regular" : "Ultimate"}")

commandrefs[4].root:action("Detach", {"detach"}, "", function()
    local entity = GET_ENTITY_ATTACHED_TO(players.user_ped())
    if !(entity and DOES_ENTITY_EXIST(entity)) then return end
    DETACH_ENTITY(players.user_ped(), true, false)
    util.notify(successfulcommand)
end).visible = false

commandrefs[4].ihatebe = commandrefs[4].root:list_select("Anti BattlEye Kick", {}, "This only works if you're not the host.\nThis will block syncs and network events to the host.", {{1, "Disabled"}, {2, "First Host", {}, "Will stop working if the host changes."}, {3, "Auto Rejoin", {}, "Will automatically rejoin incase the host changes."}}, 1, function() end)

commandrefs[4].root_self = commandrefs[4].root:list("Self", {}, "")

commandrefs[4].outfit_changer = commandrefs[4].root_self:list_select("Outfit Changer", {}, "Apply an outfit when entering sessions or respawning.", {{1, "Disabled"}}, 1, function(state)
    if state != 1 and !util.in_heist() and util.in_session() and script_start then
        functions.queue_function("outfit_changer", 0, outfit_function, function() return commandrefs[4].outfit_changer.value != state end)
    end
end)

commandrefs[4].undead_otr = commandrefs[4].root_self:toggle("Undead OTR", {"undeadotr"}, "Off The Radar, but it's faked.", function() end)

commandrefs[4].health_mod = commandrefs[4].root_self:list_select("Health Mod", {"hpmod"}, "This will modify your health.", {{1, "Disabled", {"none", "off", "disabled"}}, {2, "Demi Godmode", {"demigodmode", "demi", "godmode"}}, {3, "Difficulty Tweak", {"skillissue"}}}, 1, function(state)
    if state != 3 and (health := GET_ENTITY_HEALTH(players.user_ped()) == 100) then
        CHANGE_PED_HEALTH(players.user_ped(), state == 2 ? 65535 : 328, true)
    end
end)

commandrefs[4].autoswitcher = commandrefs[4].root_self:list_select("Automatic Switcher", {"autoswitcher"}, "This will automate switching to C4 and back for shooting explosives very quickly.", {{1, "Disabled", {"off"}}, {2, "Legit", {"legit"}}, {3, "Instant", {"instant"}}}, 1, function(state)
    if state == 2 then
        local commandref = commandrefs[4].autoswitchercooldown:detach()
        commandrefs[4].autoswitchercooldown = commandrefs[4].autoswitcher:attachAfter(commandref)
    end
    commandrefs[4].autoswitchercooldown.visible = state == 2

    local weapon_hashes = {[1] = util.joaat("weapon_stickybomb"), [2] = util.joaat("weapon_grenadelauncher"), [3] = util.joaat("weapon_rpg"), [4] = util.joaat("weapon_firework"), [5] = util.joaat("weapon_railgun"), [6] = util.joaat("weapon_hominglauncher"), [7] = util.joaat("weapon_compactlauncher"), [8] = util.joaat("weapon_emplauncher"), [9] = util.joaat("weapon_railgunxm3")}
    while state != 1 and commandrefs[4].autoswitcher.value == state do
        if !util.is_session_transition_active() and !HAS_PED_GOT_WEAPON(players.user_ped(), weapon_hashes[1], false) then
            GIVE_WEAPON_TO_PED(players.user_ped(), weapon_hashes[1], 20, false, false)
        end

        for weapon_hashes as hash do
            if util.is_session_transition_active() or hash == weapon_hashes[1] then continue end
            if IS_CONTROL_PRESSED(0, 24) and GET_SELECTED_PED_WEAPON(players.user_ped()) == hash and IS_PED_WEAPON_READY_TO_SHOOT(players.user_ped()) then
                repeat
                    util.yield()
                until !IS_PED_WEAPON_READY_TO_SHOOT(players.user_ped()) or GET_SELECTED_PED_WEAPON(players.user_ped()) != hash
                if GET_SELECTED_PED_WEAPON(players.user_ped()) != hash then break end
                if state == 2 and !util.wait_time(200, || -> IS_CONTROL_JUST_RELEASED(0, 24), true) then break end
                DISABLE_PLAYER_FIRING(players.user(), true)
                SET_CURRENT_PED_WEAPON(players.user_ped(), weapon_hashes[1], true)
                TASK_PAUSE(players.user_ped(), 10)
                CLEAR_PED_TASKS(players.user_ped())
                util.wait_time(commandrefs[4].autoswitchercooldown.value, function()
                    DISABLE_PLAYER_FIRING(players.user(), true)
                    return state == 3
                end, true)
                SET_CURRENT_PED_WEAPON(players.user_ped(), hash, true)
                util.wait_time(100, function()
                    DISABLE_PLAYER_FIRING(players.user(), true)
                    return GET_SELECTED_PED_WEAPON(players.user_ped()) != hash
                end, true)
            break end
        end
        util.yield()
    end
end)

commandrefs[4].autoswitchercooldown = commandrefs[4].root_self:slider("Automatic Switcher Cooldown (ms)", {"autoswitchercooldown"}, "", 250, 2500, 500, 10, function() end)
commandrefs[4].autoswitchercooldown.visible = false

commandrefs[4].root_spawn_options = commandrefs[4].root_self:list("Spawn Options", {}, "Options that apply when entering sessions or respawning.")

commandrefs[4].spawnrefillinventory = commandrefs[4].root_spawn_options:toggle("Refill Snacks & Armour", {"spawnrefillinventory"}, "", function() end)

commandrefs[4].spawnfullarmour = commandrefs[4].root_spawn_options:toggle("Full Armour", {"spawnfullarmour"}, "", function() end)

commandrefs[4].spawnallweapons = commandrefs[4].root_spawn_options:toggle("Give All Weapons", {"spawnallweapons"}, "", function() end)

commandrefs[4].spawnmaxhealth = commandrefs[4].root_spawn_options:toggle("Max Health", {"spawnmaxhealth"}, "Sets your health to the max of 328 if the stat isn't maxed out yet.", function(state)
    if !state then return end
    CHANGE_PED_HEALTH(players.user_ped(), 328)
end)

commandrefs[4].root_bullettracers = commandrefs[4].root_self:list("Bullet Tracers", {}, "")

commandrefs[4].bullettracers = commandrefs[4].root_bullettracers:toggle("Enable", {}, "", function() end)

commandrefs[4].root_bullettracers:colour("Colour", {}, "", colours.bullettracers, true, function(state) colours.bullettracers = state end):inline_rainbow()

commandrefs[4].bullettracerstime = commandrefs[4].root_bullettracers:slider_float("Time (ms)", {}, "", 10, 500, 50, 10, function() end)

commandrefs[4].root_skeleton = commandrefs[4].root_self:list("Skeleton", {}, "")

commandrefs[4].skeleton = commandrefs[4].root_skeleton:toggle("Draw", {}, "", function() end)

commandrefs[4].root_skeleton:colour("Colour", {}, "", colours.skeleton, true, function(state) colours.skeleton = state end):inline_rainbow()

commandrefs[4].hitsound = commandrefs[4].root_self:list_select("Hit Sound", {}, "", {{1, "Disabled"}}, 1, function() end)

commandrefs[4].killsound = commandrefs[4].root_self:list_select("Kill Sound", {}, "", {{1, "Disabled"}}, 1, function() end)

commandrefs[4].root_vehicle = commandrefs[4].root:list("Vehicle", {}, "")

commandrefs[4].radio_off = commandrefs[4].root_vehicle:toggle("Radio Off", {}, "Force the radio to be off.", function() end)

commandrefs[4].fill_car_with_peds = commandrefs[4].root_vehicle:list_select("Seat Peds", {}, "Fills your vehicle seats with peds.", {{1, "Disabled"}, {2, "Clones"}, {3, "Other Players"}, {4, "Custom"}}, 1, function(state)
    commandrefs[4].fillcarwithpedsmodel.visible = state == 4
end)

commandrefs[4].fillcarwithpedsmodel = commandrefs[4].root_vehicle:text_input("Model", {"seatpedmodel"}, "", function(state)
    if not IS_MODEL_VALID(util.joaat(state)) then
        commandrefs[4].fillcarwithpedsmodel:trigger("a_c_rat")
        menu.show_command_box("seatpedmodel "..state)
        util.notify("This model is invalid.")
    end
end, "a_c_rat")
commandrefs[4].fillcarwithpedsmodel.visible = false

commandrefs[4].wheel_peds = commandrefs[4].root_vehicle:list_select("Wheel Peds", {}, "Attaches peds to your wheels.", {{1, "Disabled"}, {2, "Clones"}, {3, "Other Players"}, {4, "Custom"}}, 1, function(state)
    if state == 4 then
        local commandref = commandrefs[4].wheel_peds_model:detach()
        commandrefs[4].wheel_peds_model = commandrefs[4].wheel_peds:attachAfter(commandref)
    end
    commandrefs[4].wheel_peds_model.visible = state == 4
end)

commandrefs[4].wheel_peds_model = commandrefs[4].root_vehicle:text_input("Model", {"wheelpedmodel"}, "", function(state)
    if not IS_MODEL_VALID(util.joaat(state)) then
        commandrefs[4].wheel_peds_model:trigger("a_c_deer")
        menu.show_command_box("wheelpedmodel "..state)
        util.notify("This model is invalid.")
    end
end, "a_c_deer")
commandrefs[4].wheel_peds_model.visible = false

commandrefs[4].root_ptfxtrails = commandrefs[4].root_vehicle:list("PTFX Trails", {}, "")

commandrefs[4].ptfxtrailseffect = commandrefs[4].root_ptfxtrails:list_select("Particle", {}, "", menu.table_to_list(ptfx_effects.small, "None"), 1, function() end)

commandrefs[4].ptfxtrailsinterval = commandrefs[4].root_ptfxtrails:slider("Interval (ms)", {}, "", 0, 1000, 0, 10, function() end)

commandrefs[4].ptfxtrailsscale = commandrefs[4].root_ptfxtrails:slider_float("Scale", {}, "", 10, 1000, 15, 5, function() end)

commandrefs[4].root_ptfxtrails:divider("Bones")

commandrefs[4].ptfxtrailsflw = commandrefs[4].root_ptfxtrails:toggle("Front Left Wheel", {}, "", function() end, true)

commandrefs[4].ptfxtrailsfrw = commandrefs[4].root_ptfxtrails:toggle("Front Right Wheel", {}, "", function() end, true)

commandrefs[4].ptfxtrailsrlw = commandrefs[4].root_ptfxtrails:toggle("Rear Left Wheel", {}, "", function() end, true)

commandrefs[4].ptfxtrailsrrw = commandrefs[4].root_ptfxtrails:toggle("Rear Right Wheel", {}, "", function() end, true)

commandrefs[4].ptfxtrailsexhaust = commandrefs[4].root_ptfxtrails:toggle("Exhaust", {}, "", function() end, true)

commandrefs[4].root_autodrive = commandrefs[4].root_vehicle:list("Auto-Drive", {}, "")

commandrefs[4].autodriveenable = commandrefs[4].root_autodrive:toggle("Enable", {}, "", function() end)

commandrefs[4].autodriveoverlay = commandrefs[4].root_autodrive:toggle("Overlay", {}, "", function() end, true)

commandrefs[4].autodrivedraw = commandrefs[4].root_autodrive:list_select("Draw", {}, "", {{1, "Disabled"}, {2, "Shadow"}, {3, "Outline"}}, 2, function() end)

commandrefs[4].root_autodrive:colour("Colour", {}, "", colours.autodrive, true, function(state) colours.autodrive = state end):inline_rainbow()

commandrefs[4].root_autodrive:colour("Outline Colour", {}, "", colours.autodriveoutline, true, function(state) colours.autodriveoutline = state end)

commandrefs[4].root_autodrivedestination = commandrefs[4].root_autodrive:list("Drive To...", {}, "")

commandrefs[4].autodrivewaypoint = commandrefs[4].root_autodrivedestination:toggle("Waypoint", {}, "", function() end, true)

commandrefs[4].autodriveobjective = commandrefs[4].root_autodrivedestination:toggle("Objective", {}, "", function() end, true)

commandrefs[4].root_autodrive:slider("Driving Speed", {}, "", 0, 80, previous_vehicle.autodrivespeed, 5, function(state) previous_vehicle.autodrivespeed = state end)

commandrefs[4].autodriveautospeed = commandrefs[4].root_autodrive:toggle("Auto-Speed", {}, "Automatically changes the speed of the vehicle on static goals.", function() end, true)

commandrefs[4].autodrivebeacon = commandrefs[4].root_autodrive:list_select("Show Beacon", {}, "", {{1, "Disabled"}, {2, "Target", {}, "Where the current target is."}, {3, "Goal", {}, "Where the end of the path is."}}, 3, function() end)

commandrefs[4].autodriveinput = commandrefs[4].root_autodrive:toggle("Stop On Input", {}, "", function() end)

commandrefs[4].autodrivedisablecollision = commandrefs[4].root_autodrive:toggle("No Vehicle Collision While Auto-Driving", {}, "", function() end, true)

commandrefs[4].root_drivingstyle = commandrefs[4].root_autodrive:list("Driving Style", {}, "")

for {{"Stop Before Vehicles", 1 << 0}, {"Stop Before Peds", 1 << 1}, {"Avoid Vehicles", 1 << 2, true}, {"Avoid Empty Vehicles", 1 << 3, true}, {"Avoid Peds", 1 << 4, true}, {"Avoid Objects", 1 << 5, true}, {"Stop At Traffic Lights", 1 << 7}, {"Reverse Only", 1 << 10}, {"Take Shortest Path", 1 << 18, true}, {"Ignore Roads", 1 << 22}, {"Ignore All Pathing", 1 << 24}} as style do
    commandrefs[4].root_drivingstyle:toggle(style[1], {}, "", function(state)
        previous_vehicle.driving_style = state ? (previous_vehicle.driving_style | style[2]) : (previous_vehicle.driving_style & ~style[2])
    end, style[3])
    if style[3] then
        previous_vehicle.driving_style = (previous_vehicle.driving_style | style[2])
    end
end

commandrefs[4].root_online = commandrefs[4].root:list("Online", {}, "")

commandrefs[4].root_preferences = commandrefs[4].root_online:list("Preferences", {}, "")

commandrefs[4].root_kick_preferences = commandrefs[4].root_preferences:list("Kicks", {}, "")

commandrefs[4].root_kick_notification_preferences = commandrefs[4].root_kick_preferences:list("Info Notification", {}, "")

commandrefs[4].kicknotificationonsucces = commandrefs[4].root_kick_notification_preferences:toggle("On Success", {}, "Show info notification on success.", function() end, true)

commandrefs[4].kicknotificationonfail = commandrefs[4].root_kick_notification_preferences:toggle("On Fail", {}, "Show info notification on fail.", function() end, true)

commandrefs[4].kicknotificationconfidence = commandrefs[4].root_kick_notification_preferences:toggle("Confidence", {}, "Show info notification with confidence.", function() end, true)

commandrefs[4].kicknonhostashost = commandrefs[4].root_kick_preferences:list_select("Non-Host As Host", {}, "", menu.table_to_list(table.combine_indexes(export_list_data(kicks.nonhostashost, "name"), export_list_data(kicks.nonhostashost, "description"))), 1, function() end)

commandrefs[4].kickhostasnonhost = commandrefs[4].root_kick_preferences:list_select("Host As Non-Host", {}, "", menu.table_to_list(table.combine_indexes(export_list_data(kicks.hostasnonhost, "name"), export_list_data(kicks.hostasnonhost, "description"))), 1, function() end)

commandrefs[4].kicknonhostasnonhost = commandrefs[4].root_kick_preferences:list_select("Non-Host As Non-Host", {}, "", menu.table_to_list(table.combine_indexes(export_list_data(kicks.nonhostasnonhost, "name"), export_list_data(kicks.nonhostasnonhost, "description"))), 1, function() end)

commandrefs[4].kicktimeout = commandrefs[4].root_kick_preferences:slider("Timeout", {}, "", 30, 120, 30, 15, function() end)

commandrefs[4].kickprolongloveletter = commandrefs[4].root_kick_preferences:toggle("Prolong Love Letter", {}, "If you're Love Letter kicking a player as a non-host, it'll extend the kick time and take turns so Stand doesn't get upset you're \"Doing this way too fast\".", function() end, true)

commandrefs[4].kickignorejoindetectiononblockjoin = commandrefs[4].root_kick_preferences:toggle("Ignore Reactions On Blocked Join", {}, "Ignores triggerable join detection reactions on blocked joins.", function() end, true)

commandrefs[4].kicksmartblockloveletters = commandrefs[4].root_kick_preferences:toggle("Smart Kick If Host Is Blocking Love Letters", {}, "If you have setup Love Letter as your prefered non-host as non-host kick, it'll automatically try a smart kick if the host is blocking them.", function() end, true)

commandrefs[4].kickneverchallengemodderhost = commandrefs[4].root_kick_preferences:toggle("Never Try To Kick A Modder Host", {}, "If a host is detected as a modder, any automated kicks will be disregarded.", function() end, true)

commandrefs[4].root_hostshare = commandrefs[4].root_kick_preferences:list("HostShareâ„¢", {}, "HostShareâ„¢ is limited to a \"Smart\" kick, so it will tell the player that you're trying to kick them.\nIf this isn't working at all, try enabling an option in settings.")

commandrefs[4].hostsharepreferredkick = commandrefs[4].root_hostshare:toggle("Preferred Kick", {}, "Do your preferred kick if HostShareâ„¢ doesn't kick them.", function() end, true)

commandrefs[4].root_hostshare:divider("Test With")

commandrefs[4].hostsharetestfriends = commandrefs[4].root_hostshare:toggle("Test Friends", {}, "Test friends for HostShareâ„¢.", function() end)

commandrefs[4].hostshareteststrangers = commandrefs[4].root_hostshare:toggle("Test Strangers", {}, "Test strangers for HostShareâ„¢.", function() end)

commandrefs[4].root_crash_preferences = commandrefs[4].root_preferences:list("Crashes", {}, "")

commandrefs[4].root_crash_notification_preferences = commandrefs[4].root_crash_preferences:list("Info Notification", {}, "")

commandrefs[4].crashnotificationonsucces = commandrefs[4].root_crash_notification_preferences:toggle("On Success", {}, "Show info notification on success.", function() end, true)

commandrefs[4].crashnotificationonfail = commandrefs[4].root_crash_notification_preferences:toggle("On Fail", {}, "Show info notification on fail.", function() end, true)

commandrefs[4].crashnotificationconfidence = commandrefs[4].root_crash_notification_preferences:toggle("Confidence", {}, "", function() end, true)

commandrefs[4].crash = commandrefs[4].root_crash_preferences:list_select("Crash", {}, "", menu.table_to_list(table.combine_indexes(export_list_data(crashes, "name"), export_list_data(crashes, "description"))), menu_version > 1 ? 2 : 1, function() end)

commandrefs[4].crashtimeout = commandrefs[4].root_crash_preferences:slider("Timeout", {}, "", 30, 120, 30, 15, function() end)

if menu_version > 2 then
    commandrefs[4].preferencesteamrollercrash = commandrefs[4].root_crash_preferences:toggle("Steamroller With All Crash", {}, "This will enable/disable the crash from triggering within the \"All\" crash.\nYou should keep this off if you don't want the possibility of it crashing others as well.", function() end)
end

commandrefs[4].preferencefakefriend = commandrefs[4].root_preferences:toggle("Consider \"Fake Friend\" As Friend", {}, "Whether any detections will consider fake friends as friends.", function() end, true)

commandrefs[4].preferencewhitelistjoin = commandrefs[4].root_preferences:toggle("Consider \"Whitelist Join\" As Friend", {}, "Whether any detections will consider whitelisted joins as friends.", function() end)

commandrefs[4].root_playerhistory_preferences = commandrefs[4].root_preferences:list("Player History", {}, "The method used to find a player in \"Online > Player History\".")

commandrefs[4].preferenceplayerhistorysoftest = commandrefs[4].root_playerhistory_preferences:toggle("Check Player History", {}, "This method is the best overall.", function() end, true)

commandrefs[4].preferenceplayerhistorysoft = commandrefs[4].root_playerhistory_preferences:toggle("Change Note", {}, "This method has the drawback of causing stutters, this is because of how Stand refs commands.", function() end)

commandrefs[4].preferenceplayerhistoryhard = commandrefs[4].root_playerhistory_preferences:toggle("In Player History", {}, "This method forces open the menu, however this should never fail.", function() end)

commandrefs[4].root_detectionmemory_preferences = commandrefs[4].root_preferences:list("Detection Memory", {}, "")

commandrefs[4].detectionmemory_method = commandrefs[4].root_detectionmemory_preferences:list_select("Detections Method", {}, "Heavy can detect anything as long as it's in the users respective classifications. Light works by using on_flow_event which means if it happens once it won't get it again, it also has a draw back of detecting more then just detections.", {{1, "Light"}, {2, "Heavy"}}, 1, function(state) if state == 1 and commandrefs[4].detectionmemory.value then detectionmemory_scan() end end)

commandrefs[4].root_detectionmemory_genericdetections = commandrefs[4].root_detectionmemory_preferences:list("Generic Detections", {}, "")

for {"Shadovis Developer", "HostShareâ„¢", "Alt Account", "IP Match", "Attacking While Godmode", "Undead OTR", "Following You", "Blocking Love Letters", "Killed Someone While Godmode", "Teleported On You", "Blocking Vehicle Takeover Request", "Love Letter Lube", "Presence Spoofing", "Unusual Event", "Modded Event", "Rockstar Anti Cheat", "Modded Health", "Dead For Too Long", "Off The Radar For Too Long", "Too Much Armour", "Modded Character Model", "Attacking While Invulnerable", "Damage Multiplier", "Super Jump", "Invalid Rank/RP", "RP-Rank Mismatch", "Spoofed Rank", "Spoofed K/D", "Blocked Network Event", "Chatting Without Typing", "Modded Organisation Name", "Hidden From Player List", "Bypassed Message Filter", "Modded Data", "Rockstar Developer Flag", "Rockstar QA Flag", "Cheater Flag"} as detection do
    generic_detections[detection] = true
    if ignore_this_detection(detection) then continue end
    commandrefs[4].root_detectionmemory_genericdetections:toggle(detection, {}, "", function(state) generic_detections[detection] = state end, true)
end

commandrefs[4].root_detectionmemory_thirdpartydetections = commandrefs[4].root_detectionmemory_preferences:list("Third-Party Detections", {}, "Generic detection filter, but for third party detections.")

for possible_detections as detection do
    generic_detections[detection] = false
    commandrefs[4].root_detectionmemory_thirdpartydetections:toggle(detection, {}, "", function(state) generic_detections[detection] = state end, false)
end

commandrefs[4].preferenceupdatelive = commandrefs[4].root_detectionmemory_preferences:toggle("Update Live", {}, "This will likely have a performance hit.", function() end)

commandrefs[4].preferenceshowplayerhistoryshortcut = commandrefs[4].root_detectionmemory_preferences:toggle("Show Player History Shortcut", {}, "", function() end, true)

commandrefs[4].preferenceshowchatmessage = commandrefs[4].root_detectionmemory_preferences:list_select("Show Chat Message Type", {}, "", {{1, "Disabled"}, {2, "Latest", {}, "This will show the latest chat messages first."}, {3, "Earliest", {}, "This will show the earliest chat messages first."}}, 2, function() end)

commandrefs[4].preferenceshowname = commandrefs[4].root_detectionmemory_preferences:toggle("Show Name", {}, "", function() end, true)

commandrefs[4].preferenceshowrockstarid = commandrefs[4].root_detectionmemory_preferences:toggle("Show Rockstar ID", {}, "", function() end, true)

commandrefs[4].preferenceshowhosttoken = commandrefs[4].root_detectionmemory_preferences:toggle("Show Host Token", {}, "", function() end)

commandrefs[4].preferenceshowgeoip = commandrefs[4].root_detectionmemory_preferences:list_select("Show GeoIP", {}, "", {{1, "Disabled", {}, ""}, {2, "Country Only", {}, "Because some people can't handle some GeoIP data, as if this shit has ever been so accurate."}, {3, "Full GeoIP", {}, ""}}, 2, function() end)

commandrefs[4].preferenceshowip = commandrefs[4].root_detectionmemory_preferences:toggle("Show IP", {}, "", function() end)

commandrefs[4].preferenceshowclassification = commandrefs[4].root_detectionmemory_preferences:toggle("Show Classification", {}, "", function() end)

commandrefs[4].preferenceshowseenat = commandrefs[4].root_detectionmemory_preferences:toggle("Seen At", {}, "", function() end, true)

commandrefs[4].preferencespamlevel = commandrefs[4].root_preferences:list_select("Acceptable Spam", {}, "The acceptable level detections can repeat themselves.", {{1, "All"}, {2, "Some"}, {3, "None"}}, 2, function() end)

commandrefs[4].preferenceaddpreviousdetections = commandrefs[4].root_preferences:toggle("Add Previous Detections", {}, "If a player joins that had detections previously, add them automatically. This won't classify them as a modder.", function() end)

commandrefs[4].root_positionspoofoffset = commandrefs[4].root_preferences:list("Position Spoof Offset", {}, "")

commandrefs[4].psox = commandrefs[4].root_positionspoofoffset:slider_float("X", {"psox"}, "", -5000, 5000, 0, 10, function() end)

commandrefs[4].psoy = commandrefs[4].root_positionspoofoffset:slider_float("Y", {"psoy"}, "", -5000, 5000, 0, 10, function() end)

commandrefs[4].psoz = commandrefs[4].root_positionspoofoffset:slider_float("Z", {"psoz"}, "", -5000, 5000, -1000, 10, function() end)

commandrefs[4].psol = commandrefs[4].root_positionspoofoffset:toggle("Use Lowest Z Point As Position", {}, "This will only have an effect if the collisions have loaded.", function() end, true)

commandrefs[4].overrideplayernote = commandrefs[4].root_preferences:toggle("Don't Override Note", {}, "If a player has an already existing note, don't override it.", function() end, true)

commandrefs[4].root_moddertypes = commandrefs[4].root_preferences:list("Modder Types", {}, "The classification type that will be considered a modder by other functions.")

for i = 1, #modder_types do
    commandrefs[4].root_moddertypes:toggle(modder_types[i].name, {}, "", function(state) modder_types[i].value = state end, modder_types[i].value)
end

commandrefs[4].root_thirdeye = commandrefs[4].root_preferences:list("Third Eye", {}, "Forced spectating to receive entities around the player.")

commandrefs[4].thirdeyeoverlay = commandrefs[4].root_thirdeye:toggle("Overlay", {}, "", function() end, true)

commandrefs[4].thirdeyedraw = commandrefs[4].root_thirdeye:list_select("Draw", {}, "", {{1, "Disabled"}, {2, "Shadow"}, {3, "Outline"}}, 2, function() end)

commandrefs[4].root_thirdeye:colour("Colour", {}, "", colours.thirdeye, true, function(state) colours.thirdeye = state end):inline_rainbow()

commandrefs[4].root_thirdeye:colour("Outline Colour", {}, "", colours.thirdeyeoutline, true, function(state) colours.thirdeyeoutline = state end)

commandrefs[4].root_detections = commandrefs[4].root_online:list("Detections", {}, "")

create_detection_commands("followingyou")

create_detection_commands("attackingwhilegodmode")

create_detection_commands("killedsomeonewhilegodmode")

create_detection_commands("undeadotr")

create_detection_commands("teleportedonyou")

commandrefs[4].tpoyshortrange = menu.rbrp(commandrefs[4].root_detections, $"{detections.teleportedonyou.name}>Notification"):attachBefore(
    menu.shadow_root():toggle("Enable Short Range", {}, "This detection can be inaccurate at close range, I'd recommend keeping this off.", function() end)
)

create_detection_commands("blockingvehicletakeover")

commandrefs[4].checkforvehicletakeover = menu.rbrp(commandrefs[4].root_detections, $"{detections.blockingvehicletakeover.name}>Notification"):attachBefore(
    menu.shadow_root():toggle("Enable Detection", {}, "This detection sends out events, so if you don't wanna be seen requesting access to someones vehicle you should keep this off.", function() end)
)

create_detection_commands("ipmatch")

commandrefs[4].ipmatch_previouslyremoved = menu.rbrp(commandrefs[4].root_detections, detections.ipmatch.name):toggle("Previously Removed", {}, "If a player with a matched ip was previously removed, take the same actions on this player.", function() end, true)

create_detection_commands("altaccounts")

commandrefs[4].altaccounts_previouslyremoved = menu.rbrp(commandrefs[4].root_detections, $"{detections.altaccounts.name}>Note"):attachBefore(
    menu.shadow_root():toggle("Previously Removed", {}, "", function() end, true)
)

commandrefs[4].root_reactions = commandrefs[4].root_online:list("Reactions", {}, "")

create_detection_commands("previouslyremoved", commandrefs[4].root_reactions)

commandrefs[4].previouslyremovedevent = menu.rbrp(commandrefs[4].root_reactions, $"{detections.previouslyremoved.name}>Kick"):attachBefore(
    menu.shadow_root():list_select("On Event", {}, "", {{1, "Join"}, {2, "Existance"}}, 1, function() end)
)

create_detection_commands("spoofinghosttoken", commandrefs[4].root_reactions)

commandrefs[4].spoofinghosttokenignorehost = menu.rbrp(commandrefs[4].root_reactions, $"{detections.spoofinghosttoken.name}>Kick"):attachBefore(
    menu.shadow_root():toggle("Ignore Host", {}, "", function() end, true)
)

create_detection_commands("kickevent", commandrefs[4].root_reactions)

commandrefs[4].kickeventforgiveness = menu.rbrp(commandrefs[4].root_reactions, $"{detections.kickevent.name}>Kick"):attachBefore(
    menu.shadow_root():toggle("Forgive Next In Queue", {}, "If you're the host, it will ignore a newly joined player that's next in queue.", function() end)
)

create_detection_commands("crashevent", commandrefs[4].root_reactions)

commandrefs[4].ignoretraincrash = menu.rbrp(commandrefs[4].root_reactions, $"{detections.crashevent.name}>Note"):attachBefore(
    menu.shadow_root():toggle("Ignore Train Crash", {}, "This crash can be synced by other players, thus false positiving. It can happen in a few different ways that are just false positives.", function() end, true)
)

create_detection_commands("maliciousevents", commandrefs[4].root_reactions)

commandrefs[4].ignorekickandcrashevents = menu.rbrp(commandrefs[4].root_reactions, $"{detections.maliciousevents.name}>Note"):attachBefore(
    menu.shadow_root():toggle("Ignore Kicks & Crashes", {}, "Incase you don't have kick reactions to kick events, this way this reaction won't do anything either.", function() end, true)
)

create_detection_commands("fuckchatreactions", commandrefs[4].root_reactions)

commandrefs[4].root_customreactions = commandrefs[4].root_online:list("Custom Reactions", {}, "Allows you to add reactions to detections made by other Lua Scripts.")

for possible_detections as detection do
    detections[$"possible_detection_{detection}"] = {name = detection, description = "", reason = $"for triggering {detection}", reactions = {note = detection, addnote = 3, blockjoins = 3, track = 3, timeout = 3, block = 3, kick = 3, crash = 3}}
    create_detection_commands($"possible_detection_{detection}", commandrefs[4].root_customreactions)
end

commandrefs[4].root_enhancements = commandrefs[4].root_online:list("Enhancements", {}, "")

commandrefs[4].notifyonrespawn = commandrefs[4].root_enhancements:toggle("Notify On Respawn", {}, "This will send a notification when a player has respawned.", function() end)

commandrefs[4].customdeathmessage = commandrefs[4].root_enhancements:text_input("Minimap Death Message", {"minimapdeath"}, "This won't replace your death message.", function() end, "")

commandrefs[4].root_scripthost = commandrefs[4].root_enhancements:list("Script Host", {}, "")

commandrefs[4].kleptomaniac = commandrefs[4].root_scripthost:toggle("Kleptomaniac", {}, "You're a little whore if you use this, but you do you.", function() end)

commandrefs[4].root_connectioninfo = commandrefs[4].root_scripthost:list("Connection Info", {}, "")

commandrefs[4].root_connectioninfo:toggle_loop("Overlay", {}, "Display who's the current script host with their ping and packet loss.", function()
    if util.in_session() and players.exists(players.get_script_host()) and players.get_script_host() != players.user() and #shadovis(players.get_script_host()).ping > 0 then
        local average = average_from_list(shadovis(players.get_script_host()).ping, 30, true, {max = 300, penalty = 1.5})

        if commandrefs[4].scripthostdraw.value != 3 then
            directx.draw_text_with_shadow(commandrefs[4].textpositionconnectioninfox.value, commandrefs[4].textpositionconnectioninfoy.value, $"{shadovis(players.get_script_host()).name} ({math.float_to_int(average)} / {math.round(average_from_list(shadovis(players.get_script_host()).packet_loss, 30), 2)}){tostring(#shadovis(players.get_script_host()).ping != 30 and $" [{#shadovis(players.get_script_host()).ping}]" or "")}", ALIGN_TOP_CENTRE, 1, colours.scripthost, commandrefs[4].scripthostdraw.value == 2 ? commandrefs[4].shadowdepth.value : 0)
        else
            directx.draw_text_with_outline(commandrefs[4].textpositionconnectioninfox.value, commandrefs[4].textpositionconnectioninfoy.value, $"{shadovis(players.get_script_host()).name} ({math.float_to_int(average)} / {math.round(average_from_list(shadovis(players.get_script_host()).packet_loss, 30), 2)}){tostring(#shadovis(players.get_script_host()).ping != 30 and $" [{#shadovis(players.get_script_host()).ping}]" or "")}", ALIGN_TOP_CENTRE, 1, colours.scripthost, colours.scripthostoutline)
        end
    end
end)

commandrefs[4].scripthostdraw = commandrefs[4].root_connectioninfo:list_select("Draw", {}, "", {{1, "Disabled"}, {2, "Shadow"}, {3, "Outline"}}, 2, function() end)

commandrefs[4].root_connectioninfo:colour("Colour", {}, "", colours.scripthost, true, function(state) colours.scripthost = state end):inline_rainbow()

commandrefs[4].root_connectioninfo:colour("Outline Colour", {}, "", colours.scripthostoutline, true, function(state) colours.scripthostoutline = state end)

commandrefs[4].automaticmigration = commandrefs[4].root_scripthost:list_select("Automatic Migration", {}, "If the current script host has a bad connection to you, attempt to get a better script host.", {{1, "Disabled"}, {2, "Others"}, {3, "Yourself"}}, 1, function() end)

commandrefs[4].root_enhancements:toggle_loop("Stop Freemode Scripts", {}, "This will stop things like business battles and such.", function()
    local ss_commandrefs = menu.rbp("Online>Session>Session Scripts"):getChildren()
    for i = 3, #ss_commandrefs do
        menu.rbrp(ss_commandrefs[i], "Stop Script"):trigger()
    end
    util.yield(5000)
end)

commandrefs[4].root_killdeath = commandrefs[4].root_enhancements:list("Kill/Death Reactions", {}, "Pretty self-explanatory, but this will send messages if you kill or get killed.")

commandrefs[4].killmessage = commandrefs[4].root_killdeath:list_select("Kill Message", {}, "", {{1, "Disabled"}, {2, "Score"}, {3, "Nice"}, {4, "Toxic"}, {5, "Advertisement"}}, 1, function(state)
    if (commandref := menu.rbrp(commandrefs[4].root_killdeath, "Menu Advertisement")):isValid() then
        if state == 5 then
            commandref = menu.attach_after(commandrefs[4].deathmessage, menu.detach(commandref))
        end
        commandref.visible = state == 5 or commandrefs[4].deathmessage.value == 5
    end
end)

commandrefs[4].deathmessage = commandrefs[4].root_killdeath:list_select("Death Message", {}, "", {{1, "Disabled"}, {2, "Score"}, {3, "Nice"}, {4, "Toxic"}, {5, "Advertisement"}}, 1, function(state)
    if (commandref := menu.rbrp(commandrefs[4].root_killdeath, "Menu Advertisement")):isValid() then
        if state == 5 then
            commandref = menu.attach_after(commandrefs[4].deathmessage, menu.detach(commandref))
        end
        commandref.visible = state == 5 or commandrefs[4].killmessage.value == 5
    end
end)

commandrefs[4].menuadvertisement = commandrefs[4].root_killdeath:list_select("Menu Advertisement", {}, "", menu.table_to_list(export_list_data(killreactions[3], "name")), 1, function() end)
commandrefs[4].menuadvertisement.visible = false

commandrefs[4].killmessagedelay = commandrefs[4].root_killdeath:slider("Delay", {}, "", 0, 10, 3, 1, function() end)

commandrefs[4].root_enhancements:toggle_loop("Pause Rendering When Afk", {}, "This will pause rendering after 60 seconds of not interacting with the game or Stand.\nIf you interact with Stand in any way it will see you as active.", function()
    if util.in_session() and GET_CONTROL_HOW_LONG_AGO(0) > 50 and GET_CONTROL_HOW_LONG_AGO(1) > 50 then
        afk = afk or util.current_time_millis() + 60000
        if util.current_time_millis() >= afk then
            directx.draw_text_with_outline(commandrefs[4].textpositionpauserendererx.value, commandrefs[4].textpositionpauserenderery.value, "Renderer is paused...")
            if GET_TOGGLE_PAUSED_RENDERPHASES_STATUS() then
                TOGGLE_PAUSED_RENDERPHASES(false)
            end
        end
    else
        if not GET_TOGGLE_PAUSED_RENDERPHASES_STATUS() then
            TOGGLE_PAUSED_RENDERPHASES(true)
        end
        afk = nil
    end
end, || -> TOGGLE_PAUSED_RENDERPHASES(true))

commandrefs[4].root_modern_spectate = commandrefs[4].root_enhancements:list("Modern Spectate")

commandrefs[4].root_modern_spectate:toggle_loop("Modern Spectate", {"modernspectate"}, "Just gives GTA's spectating a fresh coat of functionality.", function()
    local spectate_id, spectate_type;
    for players.list_except(true) as player_id do
        if !(menu.rbrp(menu.pr(player_id), "Spectate>Nuts Method").value or menu.rbrp(menu.pr(player_id), "Spectate>Legit Method").value) then continue end
        spectate_id, spectate_type = player_id, menu.rbrp(menu.pr(player_id), "Spectate>Nuts Method").value and 1 or menu.rbrp(menu.pr(player_id), "Spectate>Legit Method").value and 2 break
    end
    if !(spectate_id and players.exists(spectate_id)) then
        if cam_active then
            RENDER_SCRIPT_CAMS(false, false, 0, true, true, 0) cam_active = false
        end
    return end

    if commandrefs[4].modernspectateoverlay.value then
        local x, y = commandrefs[4].textpositionmodernspectatex.value, commandrefs[4].textpositionmodernspectatey.value
        local offsets = {
            [1] = 1 / screen_dimensions.x * x + 0.2,
            [2] = 1 / screen_dimensions.x * x - 0.2,
            [3] = 1 / screen_dimensions.x * x + 0.4,
            [4] = 1 / screen_dimensions.y * y - 0.025,
            [5] = 1 / screen_dimensions.y * y - 0.05
        }
        if commandrefs[4].modernspectatedraw.value != 3 then
            local shadow, shadowdepth = commandrefs[4].modernspectatedraw.value == 2, commandrefs[4].shadowdepth.value
            directx.draw_text_with_shadow(offsets[1], offsets[4], "Next [LM]", ALIGN_CENTRE, 1, colours.modernspectate, shadow ? shadowdepth : 0)
            directx.draw_text_with_shadow(offsets[2], offsets[4], "Previous [RM]", ALIGN_CENTRE, 1, colours.modernspectate, shadow ? shadowdepth : 0)
            directx.draw_text_with_shadow(offsets[3], offsets[4], "Exit [V]", ALIGN_CENTRE, 1, colours.modernspectate, shadow ? shadowdepth : 0)
            directx.draw_text_with_shadow(x, offsets[5], $"Camera [Spacebar]: {tostring(cam_lock ? "Locked" : "Freecam")}", ALIGN_CENTRE, 1, colours.modernspectate, shadow ? shadowdepth : 0)
            directx.draw_text_with_shadow(x, y, $"Spectating: {shadovis(spectate_id).name}", ALIGN_CENTRE, 1, colours.modernspectate, shadow ? shadowdepth : 0)
        else
            directx.draw_text_with_outline(offsets[1], offsets[4], "Next [LM]", ALIGN_CENTRE, 1, colours.modernspectate, colours.modernspectateoutline)
            directx.draw_text_with_outline(offsets[2], offsets[4], "Previous [RM]", ALIGN_CENTRE, 1, colours.modernspectate, colours.modernspectateoutline)
            directx.draw_text_with_outline(offsets[3], offsets[4], "Exit [V]", ALIGN_CENTRE, 1, colours.modernspectate, colours.modernspectateoutline)
            directx.draw_text_with_outline(x, offsets[5], $"Camera [Spacebar]: {tostring(cam_lock ? "Locked" : "Freecam")}", ALIGN_CENTRE, 1, colours.modernspectate, colours.modernspectateoutline)
            directx.draw_text_with_outline(x, y, $"Spectating: {shadovis(spectate_id).name}", ALIGN_CENTRE, 1, colours.modernspectate, colours.modernspectateoutline)
        end
    end

    if !(cam and DOES_CAM_EXIST(cam)) then
        cam = CREATE_CAM_WITH_PARAMS("DEFAULT_SCRIPTED_CAMERA", v3.new(), v3.new(), 60, true, 0)
    end

    local cam_pos, cam_rot = players.get_cam_pos(spectate_id), players.get_cam_rot(spectate_id)
    local main_cam_pos, main_cam_rot = GET_CAM_COORD(cam), GET_CAM_ROT(cam, 2)
    local interpolation = commandrefs[4].modernspectateinterpolate.value

    if interpolation == 1 or v3.distance(main_cam_pos, cam_pos) > 50 then
        SET_CAM_COORD(cam, cam_pos)
        SET_CAM_ROT(cam, cam_rot, 2)
    else
        SET_CAM_COORD(cam, main_cam_pos:addNew(cam_pos:subNew(main_cam_pos):mul(interpolation == 2 and 0.5 or interpolation == 3 and 0.25)))
        SET_CAM_ROT(cam, main_cam_rot:addNew(cam_rot:subNew(main_cam_rot):mul(interpolation == 2 and 0.25 or interpolation == 3 and 0.1)), 2)
    end

    if cam_lock and players.is_first_person(spectate_id) then
        SET_ENTITY_LOCALLY_INVISIBLE(players.get_ped(spectate_id))
    end

    RENDER_SCRIPT_CAMS(cam_lock, false, 0, true, true, 0)
    if cam_lock then cam_active = true end

    if !IS_PAUSE_MENU_ACTIVE() and !players.is_using_rc_vehicle(spectate_id) and menu.rbp("World>Inhabitants>Player ESP>Bone ESP").value == 0 and commandrefs[4].modernspectateesp.value then
        directx.draw_ped_skeleton(players.get_ped(spectate_id), colours.skeletonesp)
    end

    local control = !(chat.is_open() or menu.command_box_is_open()) and (util.is_key_just_pressed("left mouse") and 1 or util.is_key_just_pressed("right mouse") and 2 or util.is_key_just_pressed("v") and 3 or util.is_key_just_pressed("spacebar") and 4) or 0
    if control == 0 or control >= 3 then
        if control == 3 then
            menu.rbp("Players>Settings>Stop Spectating"):trigger()
        elseif control == 4 then
            cam_lock = !cam_lock
        end
        return
    end
    
    local imaginary_id = spectate_id
    repeat
        if (control == 1 and imaginary_id + 1 or control == 2 and imaginary_id - 1) == spectate_id then return end
        imaginary_id = (control == 1 and (imaginary_id == 31 and 0 or imaginary_id + 1) or control == 2 and (imaginary_id == 0 and 31 or imaginary_id - 1))
    until players.exists(imaginary_id) and imaginary_id != players.user() and players.valid_position(imaginary_id) and !players.in_transition(imaginary_id)
    if !players.exists(imaginary_id) or imaginary_id == players.user() or !players.valid_position(imaginary_id) then return end
    menu.rbrp(menu.pr(imaginary_id), $"Spectate>{tostring(spectate_type == 1 and "Nuts" or spectate_type == 2 and "Legit")} Method").value = true
end, || -> RENDER_SCRIPT_CAMS(false, false, 0, true, true, 0))

commandrefs[4].modernspectateinterpolate = commandrefs[4].root_modern_spectate:list_select("Interpolation", {}, "", {{1, "Disabled"}, {2, "Light"}, {3, "Heavy"}}, 2, function() end)

commandrefs[4].modernspectateoverlay = commandrefs[4].root_modern_spectate:toggle("Overlay", {}, "", function() end, true)

commandrefs[4].modernspectatedraw = commandrefs[4].root_modern_spectate:list_select("Draw", {}, "", {{1, "Disabled"}, {2, "Shadow"}, {3, "Outline"}}, 2, function() end)

commandrefs[4].root_modern_spectate:colour("Colour", {}, "", colours.modernspectate, true, function(state) colours.modernspectate = state end):inline_rainbow()

commandrefs[4].root_modern_spectate:colour("Outline Colour", {}, "", colours.modernspectateoutline, true, function(state) colours.modernspectateoutline = state end)

commandrefs[4].modernspectateesp = commandrefs[4].root_modern_spectate:toggle("Skeleton ESP", {}, "This is basically as far as I know atleast, the same as \"Legacy Rendering\" within Stand.", function() end, true)

commandrefs[4].root_modern_spectate:colour("Skeleton Colour", {}, "", colours.skeletonesp, true, function(state) colours.skeletonesp = state end):inline_rainbow()

commandrefs[4].fixtransitions = commandrefs[4].root_enhancements:toggle("Fix Broken Session State", {}, "EXPERIMENTAL!\nIn a perfect world, after a heist the session state should be switched. R* decided no, so this will fix that.", function() end)

commandrefs[4].root_automaticallymanage = commandrefs[4].root_enhancements:list("Automatically Manage", {}, "")

commandrefs[4].groupoverride = commandrefs[4].root_automaticallymanage:toggle("Group Override", {}, "EXPERIMENTAL!\nThis will manage the group override setting for you, it will ignore any value you've set to it.\nThis is purely meant to just solve issues joining heists, you do not need to use this if you don't override your group.", function() end)

commandrefs[4].lockweapons = commandrefs[4].root_automaticallymanage:toggle("Lock Weapons", {}, "This will manage your locked weapon state so you can get the correct weapons for your heist.", function() end)

commandrefs[4].lockoutfit = commandrefs[4].root_automaticallymanage:toggle("Lock Outfit", {}, "This will manage your locked outfit state.", function() end)

commandrefs[4].restartonnosh = commandrefs[4].root_enhancements:toggle("Restart FM Script", {}, "Restart your freemode script if there's no script host for some reason.", function() end)

commandrefs[4].root_enhancements:toggle_loop("Disable RP", {"norp"}, "Sets your rp multiplier to 0 so you never gain any.", function()
    if util.can_continue() and memory.read_float(globals[6]()) > 0 then
        memory.write_float(globals[6](), 0)
    end
end, || -> memory.write_float(globals[6](), 1))

commandrefs[4].root_organization = commandrefs[4].root_enhancements:list("Organization", {}, "")

commandrefs[4].forceorg = commandrefs[4].root_organization:list_select("Force Organization", {}, "Makes sure you get into an organization.", {{1, "Disabled"}, {2, "CEO"}, {3, "MC"}, {4, "Neither", {}, "Seems to act like CEO, but is actually invalid.\nThis is not networked."}}, 1, function() end)

commandrefs[4].orgrainbow = commandrefs[4].root_organization:toggle("Rainbow Organization", {}, "I like colours.\nOnly networked if you're script host.", function() end)

commandrefs[4].orgcolour = commandrefs[4].root_organization:slider("Organization Colour", {}, "Only networked if you're script host.", -2, 14, -2, 1, function() end)
commandrefs[4].orgcolour:addValueReplacement(-2, "Default") commandrefs[4].orgcolour:addValueReplacement(-1, "White")

commandrefs[4].root_translator = commandrefs[4].root_enhancements:list("Translator", {}, "")

commandrefs[4].translateothers = commandrefs[4].root_translator:toggle("Translate Others", {}, "This will translate all other players messages in your lobby.", function() end)

commandrefs[4].incomingtargetlanguage = commandrefs[4].root_translator:list_select("Incoming Target Language", {}, "", menu.table_to_list(export_list_data(languages, "name")), 1, function() end)

commandrefs[4].translateme = commandrefs[4].root_translator:toggle("Translate Me", {}, "This will translate your messages in your lobby.\nThis will always network the messages.", function() end)

commandrefs[4].outgoingtargetlanguage = commandrefs[4].root_translator:list_select("Outgoing Target Language", {}, "", menu.table_to_list(export_list_data(languages, "name")), 1, function() end)

commandrefs[4].root_messagedisplay = commandrefs[4].root_translator:list("Message Display", {}, "")

commandrefs[4].messagenotification = commandrefs[4].root_messagedisplay:toggle("Notification", {}, "", function() end, true)

commandrefs[4].messagemessage = commandrefs[4].root_messagedisplay:toggle("Message", {}, "", function() end)

commandrefs[4].messageteam = commandrefs[4].root_messagedisplay:toggle("Team Chat", {}, "", function() end)

commandrefs[4].messagenetwork = commandrefs[4].root_messagedisplay:toggle("Network", {}, "", function() end)

commandrefs[4].root_ignorelanguages = commandrefs[4].root_translator:list("Ignore Languages", {}, "")

commandrefs[4].sendtranslation = commandrefs[4].root_translator:action("Send Translation", {"translate"}, "", || -> menu.show_command_box("translate "), function(state)
    if !util.can_continue() or state == "" then return end
    local translation = json.decode(http.get_response($"translate.googleapis.com/translate_a/t?client=dict%2Dchrome%2Dex&q={url.encode(state):gsub("%%20", "+")}&tl={languages[commandrefs[4].translatetargetlanguage.value].key}&sl=auto", "[]"))[1]
    if translation and translation[1] then
        if commandrefs[4].messagenotification.value then
            util.notify($"{shadovis(players.user()).name}: {translation[1]}")
        end
        chat.send_message(translation[1], commandrefs[4].messageteam.value, true, true)
    end
end)
commandrefs[4].sendtranslation:setTemporary()

commandrefs[4].translatetargetlanguage = commandrefs[4].root_translator:list_select("Target Language", {}, "", menu.table_to_list(export_list_data(languages, "name")), 1, function() end)

for i = 1, #languages do
    commandrefs[4].root_ignorelanguages:toggle(languages[i].name, {}, "", function(state) languages[i].ignore = state end, languages[i].ignore)
end

commandrefs[4].seenbefore = commandrefs[4].root_online:toggle("Previously Seen", {}, "This will tell you if someone this script has previously seen joins your lobby.", function() end)

commandrefs[4].antimoddedotr = commandrefs[4].root_online:toggle("Anti Modded OTR", {}, "This will create a new blip on players that have modded their Off The Radar.", function(state) if state and menu.rbp("Online>Reveal Off The Radar Players").value then util.notify("Anti Modded OTR won't have an effect if \"Reveal Off The Radar Players\" is on.") end end)

commandrefs[4].root_ghost = commandrefs[4].root_online:list("Ghosting", {}, "")

commandrefs[4].ghostplayers = commandrefs[4].root_ghost:list_select("Players", {}, "", {{1, "Disabled"}, {2, "Everyone"}, {3, "Strangers"}, {4, "Friends"}}, 1, function() end)

commandrefs[4].ghostgodmode = commandrefs[4].root_ghost:toggle("Godmode Players", {}, "Ghost godmode players, what can I say? This should be a relatively accurate function.", function() end)

commandrefs[4].ghostvehiclegodmode = commandrefs[4].root_ghost:toggle("Vehicle Godmode Players", {}, "", function() end)

commandrefs[4].ghostmk2 = commandrefs[4].root_ghost:toggle("Mosquitoes", {}, "This should be pretty obvious.", function() end, true)

commandrefs[4].root_fake_friends = commandrefs[4].root_online:list("Fake Friends", {}, "This won't make players ingame appear as if they were friends.", function()
    local player_commandrefs, current, focus_on = commandrefs[4].root_fake_friends:getChildren(), menu.get_current_position(), nil
    for i = 4, #player_commandrefs do
        if player_commandrefs[i]:equals(current) then focus_on = player_commandrefs[i] end
        player_commandrefs[i]:delete()
    end

    local friends = {}
    for playerinfo as player_information do
        if !player_information?.friend then continue end
        friends[player_information.rockstar_id] = player_information
    end

    local sorted = {}
    if commandrefs[4].fakefriend_sort.value == 1 then
        local names = {}
        for friends as fakefriend do names[#names + 1] = fakefriend?.name or tostring(fakefriend.rockstar_id) end
        for table.sort_by_name(names) as target do
            for friends as fakefriend do
                if (fakefriend?.name or tostring(fakefriend.rockstar_id)) != target then continue end
                sorted[#sorted + 1] = fakefriend
            end
        end
    elseif commandrefs[4].fakefriend_sort.value == 2 then
        for table.sort_by_number(export_list_data(friends, "rockstar_id", true)) as target do
            for friends as fakefriend do
                if fakefriend.rockstar_id != target then continue end
                sorted[#sorted + 1] = fakefriend
            end
        end
    elseif commandrefs[4].fakefriend_sort.value == 3 then
        local sessions, session_types = {}, {"Public", "Invite", "Crew", "Closed Friend", "Closed Crew", "Solo", "Story Mode", "Unknown", "Offline"}
        for session_types as session_type do sessions[session_type] = {} end

        for friends as fakefriend do
            if fakefriend?.name and (path := menu.ref_player_history(fakefriend.name)):isValid() and path:getState() != "" then
                sessions[path:getState()][#sessions[path:getState()] + 1] = fakefriend.name
            else
                sessions["Unknown"][#sessions["Unknown"] + 1] = fakefriend?.name or tostring(fakefriend.rockstar_id)
            end
        end

        for session_types as session_type do
            for table.sort_by_name(sessions[session_type]) as target do
                for friends as fakefriend do
                    if (fakefriend?.name or tostring(fakefriend.rockstar_id)) != target then continue end
                    sorted[#sorted + 1] = fakefriend
                end
            end
        end
    end

    for sorted as fakefriend do
        if !(commandrefs[4]?.fakefriend_divider and commandrefs[4].fakefriend_divider:isValid()) then
            commandrefs[4].fakefriend_divider = commandrefs[4].root_fake_friends:divider("")
        end

        fakefriend_create_ref(fakefriend)
    end

    if commandrefs[4]?.fakefriend_divider?:isValid?() then
        commandrefs[4].fakefriend_divider.menu_name = $"Fake Friends ({table.get_size(friends)})"
    end
end)

commandrefs[4].fakefriend_name = commandrefs[4].root_fake_friends:action("Add Player By Name", {"fakefriendname"}, "", || -> menu.show_command_box("fakefriendname "), function(state)
    if !util.can_continue() or state == "" then return end
    if state == shadovis(players.user()).name then return end

    local rockstar_id, name = -1, state:lower()
    for playerinfo as player_information do
        if name == player_information.name:lower() then
            rockstar_id = player_information.rockstar_id
            if player_information.blockjoin then
                util.notify("This player is already a fake friend.")
            return end
        break end
    end

    if rockstar_id != -1 then
        playerinfo[rockstar_id].friend, playerinfo[rockstar_id].blockjoin = true, false
    else
        rockstar_id, name = sc.get_rockstar_id_from_name(name)
        if !rockstar_id then
            util.notify($"Couldn't resolve {state}.")
        return end

        if playerinfo[rockstar_id] then
            playerinfo[rockstar_id].name, playerinfo[rockstar_id].friend, playerinfo[rockstar_id].blockjoin = name, true, false
        else
            playerinfo[rockstar_id] = {name = name, rockstar_id = rockstar_id, friend = true, blockjoin = false}
        end
    end

    commandrefs[4].root_fake_friends:trigger()
    commandrefs[4].fakefriend_name:focus()
end)

commandrefs[4].fakefriend_rid = commandrefs[4].root_fake_friends:action("Add Player By RID", {"fakefriendrid"}, "", || -> menu.show_command_box("fakefriendrid "), function(state)
    if !util.can_continue() or !tonumber(state) then return end
    if tonumber(state) == shadovis(players.user()).rockstar_id then return end

    if playerinfo[tonumber(state)]?.blockjoin then
        util.notify("This player is already a fake friend.")
    return end

    local rockstar_id, name = tonumber(state), nil

    if playerinfo[rockstar_id] != nil then
        playerinfo[rockstar_id].friend, playerinfo[rockstar_id].blockjoin = true, false
    else
        name = sc.get_name_from_rockstar_id(rockstar_id)
        if !name then
            util.notify($"Couldn't resolve {state}.")
        return end
        playerinfo[rockstar_id] = {name = name, rockstar_id = rockstar_id, friend = true, blockjoin = false}
    end

    commandrefs[4].root_fake_friends:trigger()
    commandrefs[4].fakefriend_rid:focus()
end)

commandrefs[4].fakefriend_sort = commandrefs[4].root_fake_friends:list_select("Sort By", {}, "", {{1, "Name"}, {2, "Rockstar ID"}, {3, "Online", {}, "This will only update each time you enter this list."}}, 1, function(state)
    if state == 3 and menu_version != 3 then
        util.notify("You need Ultimate to use this feature. :)", false, false, script_start)
        commandrefs[4].fakefriend_sort.value = 1 return
    end
    if !(script_start and util.can_continue() and menu.get_current_menu_list():equals(commandrefs[4].root_fake_friends)) then return end

    commandrefs[4].root_fake_friends:trigger()
    commandrefs[4].fakefriend_sort:focus()
end)

commandrefs[4].root_stealthblockjoin = commandrefs[4].root_online:list("Stealth Block Join", {}, "Like Stands block join, but limited to Love Letter kicks.", function()
    for position, commandref in commandrefs[4].root_stealthblockjoin:getChildren() do
        if position <= 2 or !commandref?:isValid?() then continue end
        commandref:delete()
    end

    local blockedjoins = {}
    for playerinfo as player_information do
        if !player_information.blockjoin then continue end
        blockedjoins[#blockedjoins + 1] = player_information.name
    end

    for table.sort_by_name(blockedjoins) as name do
        for playerinfo as player_information do
            if name != player_information.name then continue end

            if !(commandrefs[4]?.stealthblockjoin_divider and commandrefs[4].stealthblockjoin_divider:isValid()) then
                commandrefs[4].stealthblockjoin_divider = commandrefs[4].root_stealthblockjoin:divider("")
            end

            local player_root; player_root = commandrefs[4].root_stealthblockjoin:action(player_information.name, {}, removeplayercommand, function()
                playerinfo[player_information.rockstar_id].blockjoin = false
                player_root:delete()

                local blockedjoins = 0
                for playerinfo as player_information do
                    if !player_information.blockjoin then continue end
                    ++blockedjoins
                end
                if blockedjoins == 0 then
                    commandrefs[4].stealthblockjoin_divider:delete()
                else
                    commandrefs[4].stealthblockjoin_divider.menu_name = $"Stealth Blocked ({blockedjoins})"
                end
            end)
        break end
    end

    if commandrefs[4]?.stealthblockjoin_divider?:isValid?() then
        commandrefs[4].stealthblockjoin_divider.menu_name = $"Stealth Blocked ({table.get_size(blockedjoins)})"
    end
end)

commandrefs[4].stealthblockjoin_name = commandrefs[4].root_stealthblockjoin:action("Add Player By Name", {"stealthblockjoinname"}, "", || -> menu.show_command_box("stealthblockjoinname "), function(state)
    if !util.can_continue() or state == "" then return end
    if state == shadovis(players.user()).name then return end

    local rockstar_id, name = -1, state:lower()
    for playerinfo as player_information do
        if name == player_information.name:lower() then
            rockstar_id = player_information.rockstar_id
            if player_information.blockjoin then
                util.notify("This player is already being stealth blocked.")
            return end
        break end
    end

    if rockstar_id != -1 then
        playerinfo[rockstar_id].blockjoin, playerinfo[rockstar_id].friend = true, false
    else
        rockstar_id, name = sc.get_rockstar_id_from_name(name)
        if !rockstar_id then
            util.notify($"Couldn't resolve {state}.")
        return end

        if playerinfo[rockstar_id] then
            playerinfo[rockstar_id].name, playerinfo[rockstar_id].blockjoin, playerinfo[rockstar_id].friend = name, true, false
        else
            playerinfo[rockstar_id] = {name = name, rockstar_id = rockstar_id, friend = false, blockjoin = true}
        end
    end

    commandrefs[4].root_stealthblockjoin:trigger()
    commandrefs[4].stealthblockjoin_name:focus()
end)

commandrefs[4].stealthblockjoin_rid = commandrefs[4].root_stealthblockjoin:action("Add Player By RID", {"stealthblockjoinrid"}, "", || -> menu.show_command_box("stealthblockjoinrid "), function(state)
    if !util.can_continue() or !tonumber(state) then return end
    if tonumber(state) == shadovis(players.user()).rockstar_id then return end

    if playerinfo[tonumber(state)]?.blockjoin then
        util.notify("This player is already being stealth blocked.")
    return end

    local rockstar_id, name = tonumber(state), nil

    if playerinfo[rockstar_id] != nil then
        playerinfo[rockstar_id].blockjoin, playerinfo[rockstar_id].friend = true, false
    else
        name = sc.get_name_from_rockstar_id(rockstar_id)
        if !name then
            util.notify($"Couldn't resolve {state}.")
        return end
        playerinfo[rockstar_id] = {name = name, rockstar_id = rockstar_id, friend = false, blockjoin = true}
    end

    commandrefs[4].root_stealthblockjoin:trigger()
    commandrefs[4].stealthblockjoin_rid:focus()
end)

commandrefs[4].root_player_esp = commandrefs[4].root_online:list("Player ESP", {}, "")

commandrefs[4].espdraw = commandrefs[4].root_player_esp:toggle("Enable ESP", {"esptoggle"}, "", function() end)

commandrefs[4].espmaxdistance = commandrefs[4].root_player_esp:slider("Max Distance", {"espmaxdistance"}, "", 200, 1000, 200, 10, function() end)

commandrefs[4].espbox = commandrefs[4].root_player_esp:toggle("Boxes", {"espbox"}, "", function() end, true)

commandrefs[4].espskeleton = commandrefs[4].root_player_esp:toggle("Skeletons", {"espskeleton"}, "", function() end)

commandrefs[4].espnames = commandrefs[4].root_player_esp:toggle("Names", {"espnames"}, "", function() end, true)

commandrefs[4].esphealth = commandrefs[4].root_player_esp:toggle("Health", {"esphealth"}, "", function() end)

commandrefs[4].esparmour = commandrefs[4].root_player_esp:toggle("Armour", {"esparmour"}, "", function() end)

commandrefs[4].espweaponinfo = commandrefs[4].root_player_esp:toggle("Weapon Info", {"espweaponinfo"}, "", function() end)

commandrefs[4].espgodmode = commandrefs[4].root_player_esp:toggle("Godmode", {"espgodmode"}, "", function() end)

commandrefs[4].espdistance = commandrefs[4].root_player_esp:toggle("Distance", {"espdistance"}, "", function() end)

commandrefs[4].esptextminsize = commandrefs[4].root_player_esp:slider_float("Minimum Text Size", {"espnamesminimumsize"}, "", 0, 100, 50, 5, function() end)

commandrefs[4].espvisibleonly = commandrefs[4].root_player_esp:toggle("Visible Only", {"espvisibleonly"}, "", function() end)

commandrefs[4].root_player_esp:colour("Visible Colour", {"espvisiblecolour"}, "This currently only works accurately for nearby players.", colours.playerespvisible, true, function(state) colours.playerespvisible = state end):inline_rainbow()

commandrefs[4].root_player_esp:colour("Hidden Colour", {"esphiddencolour"}, "", colours.playeresphidden, true, function(state) colours.playeresphidden = state end):inline_rainbow()

commandrefs[4].esptracers = commandrefs[4].root_player_esp:list_select("Tracers", {}, "", {{1, "Disabled"}, {2, "Center"}, {3, "Bottom"}, {4, "Top"}, {5, "Left"}, {6, "Right"}}, 1, function() end)

commandrefs[4].esphpbar = commandrefs[4].root_player_esp:list_select("Health Bar", {}, "", {{1, "Disabled"}, {2, "Left"}, {3, "Right"}, {4, "Bottom"}, {5, "Top"}}, 2, function() end)

commandrefs[4].esphpbarbackground = commandrefs[4].root_player_esp:toggle("Health Bar Background", {"esphpbarbackground"}, "Only visible if they don't have full hp.", function() end)

commandrefs[4].esphpbaroutline = commandrefs[4].root_player_esp:toggle("Health Bar Outline", {"esphpbaroutline"}, "", function() end, true)

commandrefs[4].root_player_esp:colour("Health Bar Colour", {"esphpbarcolour"}, "", colours.playeresphpbar, true, function(state) colours.playeresphpbar = state end):inline_rainbow()

commandrefs[4].root_player_esp:colour("Health Bar Background Colour", {"esphpbarbackgroundcolour"}, "", colours.playeresphpbarbackground, true, function(state) colours.playeresphpbarbackground = state end):inline_rainbow()

commandrefs[4].root_autohostdlc = commandrefs[4].root_online:list("Auto Kick Host DLC", {}, "This extends the capabilities of \"Online > Spoofing > Host Token Spoofing > Kick Host When Joining As Next In Queue\".")

commandrefs[4].autohostdlcstate = commandrefs[4].root_autohostdlc:toggle_loop("Enable DLC", {}, "", function()
    if menu_version != 3 then
        util.notify("You need Ultimate to use this feature. :)")
        commandrefs[4].autohostdlcstate.value = false
    return end

    local function is_player_viable(player_id: int): bool
        if !players.exists(player_id) then return false end
        local player = shadovis(player_id)
        return !(
            menu.rbp("Online>Spoofing>Host Token Spoofing>Kick Host When Joining As Next In Queue>Exclude Friends").value and (player.friend or player:fakefriend()) or
            menu.rbp("Online>Spoofing>Host Token Spoofing>Kick Host When Joining As Next In Queue>Exclude Crew Members").value and player.crew or
            menu.rbp("Online>Spoofing>Host Token Spoofing>Kick Host When Joining As Next In Queue>Exclude Stand Users").value and players.is_stand_user(player_id) or
            menu.rbp("Online>Spoofing>Host Token Spoofing>Kick Host When Joining As Next In Queue>Exclude Organisation Members").value and player:is_org_member() or
            menu.rbp("Online>Spoofing>Host Token Spoofing>Kick Host When Joining As Next In Queue>Exclude Modders").value and players.is_marked_as_modder(player_id) or
            menu.rbp("Online>Spoofing>Host Token Spoofing>Kick Host When Joining As Next In Queue>Exclude Likely Modders").value and players.is_marked_as_likely_modder(player_id)
        )
    end

    local host = players.get_host()
    if !util.in_session() or util.in_activity() or !IS_PLAYER_CONTROL_ON(players.user()) or players.user() == host or players.get_host_queue_position(players.user()) != 1 and players.get_host_queue_position(players.user()) > commandrefs[4].autohostdlcqueuesize.value or !players.exists(host) or !shadovis(host).ready then return end
    if players.get_host_queue_position(players.user()) == 1 then
        local player = shadovis(host)
        repeat
            util.yield()
        until players.get_host_queue_position(players.user()) == 0

        local total_players_1, total_players_2 = 0, 0
        for i = 1, 2 do
            for player_list as player_data do
                if player_data.player_id == player.player_id or player_data.player_id == players.user() then continue end
                if i == 1 and (util.current_time_millis() - player_data.last_seen) < 500 then
                    ++total_players_1
                elseif i == 2 and players.exists(player_data.player_id) then
                    ++total_players_2
                end
            end
        end
        local entropy_chance = (100 / (total_players_1 > 0 ? total_players_1 : 1) * (total_players_2 > 0 ? total_players_2 : 1))
        entropy_chance = entropy_chance > 100 ? 100 : entropy_chance
        local entropy = entropy_chance >= 50

        if entropy and commandrefs[4].autohostdlcinvite.value == 2 then
            if menu.rbrp(player:history_root(), "Invite To Session"):isValid() then
                menu.rbrp(player:history_root(), "Invite To Session"):trigger()
            elseif menu.rbp("Online>Rockstar ID Tools>Invite To Session By RID"):isValid() then
                menu.rbp("Online>Rockstar ID Tools>Invite To Session By RID"):trigger($"{player.rockstar_id}")
            else
                util.notify($"Couldn't invite {player.name} back to the session.")
            end
        end
    return end

    local state = true
    for players.get_host_queue() as player_id do
        if player_id == host then continue end
        if !state or player_id == players.user() then break end
        state = is_player_viable(player_id)
    end
    if !state then return end

    local player = shadovis(players.get_host_queue()[2])
    if player.player_id != players.user() and player:kick(false, true, false) and commandrefs[4].autohostdlcinvite.value == 3 then
        if menu.rbrp(player:history_root(), "Invite To Session"):isValid() then
            menu.rbrp(player:history_root(), "Invite To Session"):trigger()
        elseif menu.rbp("Online>Rockstar ID Tools>Invite To Session By RID"):isValid() then
            menu.rbp("Online>Rockstar ID Tools>Invite To Session By RID"):trigger($"{player.rockstar_id}")
        else
            util.notify($"Couldn't invite {player.name} back to the session.")
        end
    end
end)

commandrefs[4].autohostdlcinvite = commandrefs[4].root_autohostdlc:list_select("Invite Kicked Players", {}, "", {{1, "Disabled"}, {2, "Previous Host"}, {3, "All Players"}}, 1, function() end)

commandrefs[4].autohostdlcqueuesize = commandrefs[4].root_autohostdlc:slider("Clean Queue", {""}, "", 0, 3, 0, 1, function() end)

commandrefs[4].root_removed_players = commandrefs[4].root_online:list("Removed Players", {}, "", function()
    for all_players as player do
        if !player.removed then continue end
        menu.rbrp(commandrefs[4].root_online, "Removed Players"):action(player.name, {}, $"{tostring(player.remove_reason != nil ? $"{player.remove_reason}\n" : "")}Click to remove this player.", function()
            player.removed, player.remove_reason = false, nil
            menu.rbrp(commandrefs[4].root_online, $"Removed Players>{player.name}"):delete()
        end)
    end
end, function()
    for menu.rbrp(commandrefs[4].root_online, "Removed Players"):getChildren() as commandref do
        if !commandref?:isValid?() then continue end
        commandref:delete()
    end
end)

commandrefs[4].root_macros = commandrefs[4].root:list("Macros", {}, "")

commandrefs[4].root_macros:action("Open Folder", {}, "", || -> util.open_folder($"{main_path}Macros"))

commandrefs[4].root_macros:hyperlink("Controls", "https://docs.fivem.net/docs/game-references/controls/", "")

commandrefs[4].root_macros:divider("Macros")

commandrefs[4].root_detectionmemory = commandrefs[4].root:list("Detection Memory", {}, "", function() detectionmemory_check() end, function()
    local detection_commandrefs = commandrefs[4].root_detectionmemory:getChildren()
    for i = 3, #detection_commandrefs do
        detection_commandrefs[i]:delete()
    end
end)

commandrefs[4].detectionmemory = commandrefs[4].root_detectionmemory:toggle("Enable", {}, "", function(state) if state and commandrefs[4].detectionmemory_method.value == 1 then detectionmemory_scan() end end)
commandrefs[4].detectionmemory:onTickInViewport(function()
    if commandrefs[4].preferenceupdatelive.value then detectionmemory_check() end
end)

commandrefs[4].filtergenericdetections = commandrefs[4].root_detectionmemory:toggle("Filter Generic Detections", {}, "", function() end, true)

commandrefs[4].root_modules = commandrefs[4].root:list("Modules", {}, "The list will only be updated on a script restart.")

commandrefs[4].root_modules:action("Open Folder", {}, "", || -> util.open_folder($"{main_path}Modules"))

commandrefs[4].root:divider("")

commandrefs[4].root_settings = commandrefs[4].root:list("Settings", {}, "")

commandrefs[4].root_files = commandrefs[4].root_settings:list("Files", {}, "")

commandrefs[4].root_files:action("Open Folder", {}, "", || -> util.open_folder(main_path))

commandrefs[4].updatescript = commandrefs[4].root_files:toggle("Auto Update Script", {}, "", function() end, true)

commandrefs[4].updatedependencies = commandrefs[4].root_files:toggle("Auto Update Dependencies", {}, "", function() end, true)

commandrefs[4].root_files:textslider("Check For Updates", {}, "", {"All", "Script", "Dependencies"}, function(state)
    if lua_version:endswith("-dev") then return end
    if !async_http.have_access() then util.notify("[SHADOVIS] Internet Access is disabled, can not check for updates.") return end
    local config = update_config
    config.dependencies = state != 2 ? config.dependencies : {}
    config.check_interval = 0
    if state == 3 then
        for update_config.dependencies as dependency do
            config.source_url = dependency.source_url
            config.script_relpath = dependency.script_relpath
        break end
        config.auto_restart = false
    end
    updater.run_auto_update(config)
    util.notify("[SHADOVIS] Checked for updates.")
end)

commandrefs[4].root_files:action("Uninstall", {}, "", || -> menu.show_warning(commandrefs[4].root_files, CLICK_MENU, $"Are you sure you want to uninstall \"{SCRIPT_NAME}\"?", function()
    if lua_version:endswith("-dev") then return end

    function delete_files_in_dir(path: string): void
        if !filesystem.exists(path) or !filesystem.is_dir(path) then return end
        if !path:startswith(main_path) then
            util.notify("[SHADOVIS] Path doesn't start where it should, exiting out of precaution.")
        return end
        for filesystem.list_files(path) as path do
            if !filesystem.exists(path) then continue end
            if filesystem.is_regular_file(path) then
                io.remove(path)
            elseif filesystem.is_dir(path) then
                delete_files_in_dir(path)
            end
        end
        io.remove(path)
    end

    if filesystem.exists(main_path) and filesystem.is_dir(main_path) then
        delete_files_in_dir(main_path)
    end
    if filesystem.exists($"{filesystem.scripts_dir()}{SCRIPT_RELPATH}") and filesystem.is_regular_file($"{filesystem.scripts_dir()}{SCRIPT_RELPATH}") then
        io.remove($"{filesystem.scripts_dir()}{SCRIPT_RELPATH}")
    end

    menu.rbp("Stand>Lua Scripts"):trigger()
    util.stop_script()
end))

commandrefs[4].reportloadingtime = commandrefs[4].root_settings:list_select("Report Loading Time", {}, "", {{1, "Disabled"}, {2, "Simple"}, {3, "Detailed"}}, 1, function() end)

commandrefs[4].notificationmasterswitch = commandrefs[4].root_settings:toggle("Notification Master Switch", {}, "This can turn off any and all notifications.", function() end, true)

commandrefs[4].waitforpedsync = commandrefs[4].root_settings:toggle("Wait For Ped Syncs", {}, "This will just make some functions wait an arbitrary amount to hope the ped has synced.", function() end, true)

commandrefs[4].reportlooperrors = commandrefs[4].root_settings:toggle("Report Loop Errors", {}, "If a loop for some reason errors.", function() end)

commandrefs[4].reportmoduleerrors = commandrefs[4].root_settings:toggle("Report Module Errors", {}, "If a module for some reason errors.", function() end)

commandrefs[4].savethirdpartydetections = commandrefs[4].root_settings:toggle("Save Third-Party Detections", {}, "Attempt to capture and save detections from other Lua Scripts.", function(state)
    if state and script_start then
        write_file($"{main_path}third_party_detections.txt", json.encode(possible_detections, true))
        tick_handlers.vks.fileupdatetimes["third_party_detections"] = util.current_unix_time_seconds()
    end
end, true)

commandrefs[4].root_shadows = commandrefs[4].root_settings:list("Shadows", {}, "")

commandrefs[4].shadowdepth = commandrefs[4].root_shadows:slider("Depth", {}, "", 1, 30, 3, 1, function() end)

commandrefs[4].shadowgradient = commandrefs[4].root_shadows:toggle("Gradient", {}, "", function() end, true)

commandrefs[4].root_textpositions = commandrefs[4].root_settings:list("Overlay Positions", {}, "")

commandrefs[4].textpositionautodrivex = commandrefs[4].root_textpositions:slider("Auto-Drive X", {"textpositionautodrivex"}, "", 0, screen_dimensions.x, math.round(screen_dimensions.x * 0.5), 2, function() end)

commandrefs[4].textpositionautodrivey = commandrefs[4].root_textpositions:slider("Auto-Drive Y", {"textpositionautodrivey"}, "", 0, screen_dimensions.y, math.round(screen_dimensions.y * 0.1), 2, function() end)

commandrefs[4].textpositionconnectioninfox = commandrefs[4].root_textpositions:slider("Connection Info X", {"textpositionconnectioninfox"}, "", 0, screen_dimensions.x, math.round(screen_dimensions.x * 0.5), 2, function() end)

commandrefs[4].textpositionconnectioninfoy = commandrefs[4].root_textpositions:slider("Connection Info Y", {"textpositionconnectioninfoy"}, "", 0, screen_dimensions.y, math.round(screen_dimensions.y * 0), 2, function() end)

commandrefs[4].textpositionpauserendererx = commandrefs[4].root_textpositions:slider("Pause Renderer X", {"textpositionpauserendererx"}, "", 0, screen_dimensions.x, math.round(screen_dimensions.x * 0.5), 2, function() end)

commandrefs[4].textpositionpauserenderery = commandrefs[4].root_textpositions:slider("Pause Renderer Y", {"textpositionpauserenderery"}, "", 0, screen_dimensions.y, math.round(screen_dimensions.y * 0.5), 2, function() end)

commandrefs[4].textpositionmodernspectatex = commandrefs[4].root_textpositions:slider("Modern Spectate X", {"textpositionmodernspectatex"}, "", 0, screen_dimensions.x, math.round(screen_dimensions.x * 0.5), 2, function() end)

commandrefs[4].textpositionmodernspectatey = commandrefs[4].root_textpositions:slider("Modern Spectate Y", {"textpositionmodernspectatey"}, "", 0, screen_dimensions.y, math.round(screen_dimensions.y * 0.925), 2, function() end)

commandrefs[4].textpositionthirdeyex = commandrefs[4].root_textpositions:slider("Third Eye X", {"textpositionthirdeyex"}, "", 0, screen_dimensions.x, math.round(screen_dimensions.x * 0.5), 2, function() end)

commandrefs[4].textpositionthirdeyey = commandrefs[4].root_textpositions:slider("Third Eye Y", {"textpositionthirdeyey"}, "", 0, screen_dimensions.y, math.round(screen_dimensions.y * 0.5), 2, function() end)

commandrefs[4].textpositionhotkeyx = commandrefs[4].root_textpositions:slider("Hotkey X", {"textpositionhotkeyx"}, "", 0, screen_dimensions.x, math.round(screen_dimensions.x * 1), 2, function() end)

commandrefs[4].textpositionhotkeyy = commandrefs[4].root_textpositions:slider("Hotkey Y", {"textpositionhotkeyy"}, "", 0, screen_dimensions.y, math.round(screen_dimensions.y * 0), 2, function() end)

commandrefs[4].standuseridentification = commandrefs[4].root_settings:toggle("Stand User Identification", {}, "This has to mess with \"Players > All Players > Excludes\" to be able to detect Stand Users.\nOnly needed if it doesn't detect Stand Users correctly anymore.", function() end)

commandrefs[4].root_settings:slider("Maximum Sound Instances", {"maxsoundinstances"}, "", 1, 50, 10, 1, function(state)
    local instances = {}
    for i = 1, state do
        instances[#instances + 1] = {file_path = nil, file_reader = nil, playback = nil}
    end
    sound_management.instances = instances
end)

commandrefs[4].root_hotkeys = commandrefs[4].root_settings:list("Hotkeys", {}, "")

commandrefs[4].root_hotkeys:toggle_loop("Show Hotkeys", {}, "", function()
    local border_colour, background_colour, text_colour = {
        r = menu.rbp("Stand>Settings>Appearance>Border>Colour>Red").value / 255,
        g = menu.rbp("Stand>Settings>Appearance>Border>Colour>Green").value / 255,
        b = menu.rbp("Stand>Settings>Appearance>Border>Colour>Blue").value / 255,
        a = menu.rbp("Stand>Settings>Appearance>Border>Colour>Opacity").value / 255
    }, {
        r = menu.rbp("Stand>Settings>Appearance>Colours>Background Colour>Red").value / 255,
        g = menu.rbp("Stand>Settings>Appearance>Colours>Background Colour>Green").value / 255,
        b = menu.rbp("Stand>Settings>Appearance>Colours>Background Colour>Blue").value / 255,
        a = menu.rbp("Stand>Settings>Appearance>Colours>Background Colour>Opacity").value / 255
    }, {
        r = menu.rbp("Stand>Settings>Appearance>Colours>Unfocused Text Colour>Red").value / 255,
        g = menu.rbp("Stand>Settings>Appearance>Colours>Unfocused Text Colour>Green").value / 255,
        b = menu.rbp("Stand>Settings>Appearance>Colours>Unfocused Text Colour>Blue").value / 255,
        a = menu.rbp("Stand>Settings>Appearance>Colours>Unfocused Text Colour>Opacity").value / 255
    }

    local hotkeys, total_width, total_height, scale = {}, 0, 0, commandrefs[4].hotkeytextscale.value / 100
    for path, value in util.read_colons_and_tabs_file($"{filesystem.stand_dir()}\\Hotkeys.txt") do
        if path == "Tree Compatibility Version" or value == "" then continue end
        local hotkey = $"{lang.get_string(menu.rbp(path).menu_name, "en")}: {value}"
        hotkeys[#hotkeys + 1] = {
            text = hotkey,
            height = total_height
        }
        local width, height = directx.get_text_size_client(hotkey, scale)
        total_width = width > total_width and width or total_width
        total_height += height
    end

    local start_x, start_y = 1 / screen_dimensions.x * commandrefs[4].textpositionhotkeyx.value, 1 / screen_dimensions.y * commandrefs[4].textpositionhotkeyy.value

    if commandrefs[4].forcehotkeysinbounds.value then
        start_x = start_x - 1 / screen_dimensions.x * 5 < 0 ? 1 / screen_dimensions.x * 5 : start_x + total_width + 1 / screen_dimensions.x * 5 > 1 ? 1 - total_width - 1 / screen_dimensions.x * 5 : start_x
        start_y = start_y - 1 / screen_dimensions.y * 5 < 0 ? 1 / screen_dimensions.y * 5 : start_y + total_height + 1 / screen_dimensions.y * 5 > 1 ? 1 - total_height - 1 / screen_dimensions.y * 5 : start_y
    end

    local dimensions = {
        x1 = start_x - 1 / screen_dimensions.x * 5,
        y1 = start_y - 1 / screen_dimensions.x * 5,
        x2 = start_x + total_width + 1 / screen_dimensions.x * 5,
        y2 = start_y + total_height + 1 / screen_dimensions.x * 5
    }

    directx.draw_rect_client(dimensions.x1, dimensions.y1, total_width + 1 / screen_dimensions.x * 10, total_height + 1 / screen_dimensions.x * 10, background_colour)
    directx.blurrect_draw_client(blur_instances[1], dimensions.x1, dimensions.y1, total_width + 1 / screen_dimensions.x * 10, total_height + 1 / screen_dimensions.x * 10, menu.rbp("Stand>Settings>Appearance>Background Blur").value)

    directx.draw_line_client(dimensions.x1, dimensions.y1, dimensions.x2, dimensions.y1, border_colour)
    directx.draw_line_client(dimensions.x2, dimensions.y1, dimensions.x2, dimensions.y2, border_colour)
    directx.draw_line_client(dimensions.x2, dimensions.y2, dimensions.x1, dimensions.y2, border_colour)
    directx.draw_line_client(dimensions.x1, dimensions.y2, dimensions.x1, dimensions.y1, border_colour)

    for hotkeys as hotkey do
        directx.draw_text_client(start_x - 1 / screen_dimensions.x * 5, start_y + hotkey.height, hotkey.text, ALIGN_TOP_LEFT, scale, text_colour)
    end
end)

commandrefs[4].forcehotkeysinbounds = commandrefs[4].root_hotkeys:toggle("Force In Bounds", {}, "", function() end, true)

commandrefs[4].hotkeytextscale = commandrefs[4].root_hotkeys:slider_float("Text Scale", {}, "", 50, 200, 100, 10, function() end)

commandrefs[4].root_settings:action("Add Missing Fake Friends", {}, "Adds missing fake friends to the player history.", function()
    local succeeded, failed = 0, 0
    for playerinfo as player_information do
        if !player_information?.friend or !player_information?.name or menu.ref_player_history(player_information.name):isValid() then continue end
        menu.rbp("Online>Player History>Meta>Add Player By RID"):trigger(player_information.rockstar_id)
        local result = util.wait_time(3, function()
            util.draw_debug_text($"Attempting to add {player_information.name} to player history.")
            return menu.ref_player_history(player_information.name):isValid()
        end)
        if result then
            util.notify($"Attempting to add them by name instead.")
            menu.rbp("Online>Player History>Meta>Add Player By Name"):trigger(player_information.name)
            result = util.wait_time(3, function()
                util.draw_debug_text($"Attempting to add {player_information.name} to player history.")
                return menu.ref_player_history(player_information.name):isValid()
            end)
        end
        if result then
            ++failed
            util.notify($"Failed to add {player_information.name} to player history.")
        else ++succeeded end
    end
    util.notify(succeeded > 0 or failed > 0 ? $"Added {succeeded} fake friends to player history. {failed} failed." : "There were no fake friends to add.")
end)

commandrefs[4].root_credits = commandrefs[4].root:list("Credits", {}, "")

commandrefs[4].root_credits_someoneidfk = commandrefs[4].root_credits:list("Developer - SomeoneIdfk", {}, "")

commandrefs[4].root_credits_someoneidfk:hyperlink("Discord", "https://discord.com/users/540462670575566848", "")

commandrefs[4].root_credits_someoneidfk:hyperlink("Discord Server", "https://discord.gg/N2HrRVNQCB", "")

commandrefs[4].root_credits_ilana = commandrefs[4].root_credits:list("Tester - ilana", {}, "")

commandrefs[4].root_credits_ilana:hyperlink("Discord", "https://discord.com/users/834862170423427072", "")

commandrefs[4].root_credits_yuno = commandrefs[4].root_credits:list("Tester - Yuno", {}, "")

commandrefs[4].root_credits_yuno:hyperlink("Discord", "https://discord.com/users/925353733062262784", "")

commandrefs[4].root_credits_thecashman = commandrefs[4].root_credits:list("Tester - TheCashMan", {}, "")

commandrefs[4].root_credits_thecashman:hyperlink("Discord", "https://discord.com/users/226514150761693184", "")

commandrefs[4].root_credits_sapphire = commandrefs[4].root_credits:list("Sapphire", {}, "Sapphire just knows some things eh?")

commandrefs[4].root_credits_sapphire:hyperlink("Discord", "https://discord.com/users/615014335525289984", "")

commandrefs[4].root_credits_prisuhm = commandrefs[4].root_credits:list("Prisuhm", {}, "Skidded a few things off of him.")

commandrefs[4].root_credits_prisuhm:hyperlink("Discord", "https://discord.com/users/466864485664161812", "")

commandrefs[4].root_credits_prisuhm:hyperlink("Discord Server", "https://discord.gg/hjs5S93kQv", "")

commandrefs[4].root_credits_aarroonn = commandrefs[4].root_credits:list("aarroonn", {}, "Helped me with basic Lua shit cause I'm dumb as hell.")

commandrefs[4].root_credits_aarroonn:hyperlink("Discord", "https://discord.com/users/185200691533447168", "")

commandrefs[4].root_credits_victorl = commandrefs[4].root_credits:list("VictorL", {}, "Stole the url and languages from his Lua \"Polyglot Translator\".")

commandrefs[4].root_credits_victorl:hyperlink("Discord", "https://discord.com/users/1106217262710542387", "")

commandrefs[4].root_credits_hexarobi = commandrefs[4].root_credits:list("hexarobi", {}, "Using his updater library.")

commandrefs[4].root_credits_hexarobi:hyperlink("Discord", "https://discord.com/users/342056088637669376", "")

commandrefs[4].root_credits_hexarobi:hyperlink("GitHub", "https://github.com/hexarobi/stand-lua-auto-updater", "")

commandrefs[4].root_credits_novahatecherax = commandrefs[4].root_credits:list("nova hate cherax", {}, "Basically stole their idea of detection memory.")

commandrefs[4].root_credits_novahatecherax:hyperlink("Discord", "https://discord.com/users/402969181663789056", "")

commandrefs[4].root_credits:divider("")

commandrefs[4].root_credits:hyperlink("Discord Server", "https://discord.gg/N2HrRVNQCB", "")



local start_time_hooks = util.current_time_millis()

players.on_join(function(player_id)
    local player = shadovis(player_id)
    while players.exists(player_id) and !(script_start and shadovis(player_id).ready) do
        util.yield()
    end
    if !players.exists(player_id) then return end

    if player_id == players.user() then
        ++session
        write_file($"{main_path}players.txt", json.encode(playerinfo, false))
        tick_handlers.vks.fileupdatetimes["players"] = util.current_unix_time_seconds()
    elseif all_players[player.rockstar_id].seen_first == 0 then
        all_players[player.rockstar_id].seen_first, all_players[player.rockstar_id].seen_last = util.current_unix_time_seconds(), util.current_unix_time_seconds()
    else
        all_players[player.rockstar_id].seen_last = util.current_unix_time_seconds()
    end

    if playerinfo[player.rockstar_id]?.blockjoin then
        if players.get_host() != player_id then
            player:kick(false, false, true, nil, false, "Love Letter")
        else
            util.notify($"Can't stealth block join {player.name} due to them being the host.", false, true, commandrefs[4].kicknotificationonfail.value)
        end
    end

    if player_id != players.user() and players.exists(players.get_script_host()) then
        if all_players[player.rockstar_id].session != session then
            all_players[player.rockstar_id].session = session
            if all_players[player.rockstar_id].seen_amount > 0 and commandrefs[4].seenbefore.value then
                util.notify($"I've seen {player.name} ({player.rockstar_id}{tostring(player.ip != 0 ? $" / {util.ip_to_string(player.ip)}" : "")}) before.", false, true, true)
            end
            ++all_players[player.rockstar_id].seen_amount
        end
        if all_players[player.rockstar_id].seen_amount >= 2 then
            do_affected_detection(player_id, "followingyou", !(commandrefs[4].kickignorejoindetectiononblockjoin.value and player.blockedjoin))
        end
    end

    if player_id != players.user() and (player.rockstar_id == 0x9E69C8D or player.rockstar_id == 0xD1FF4D4) then
        do_affected_detection(player_id, "shadovisdev")
    end

    if player_id != players.user() then player:match_account() end

    if player_id != players.user() and all_players[player.rockstar_id].removed then
        do_affected_detection(player_id, "previouslyremoved", (commandrefs[4].previouslyremovedevent.value == 2 or players.exists(players.get_script_host())) and !(commandrefs[4].kickignorejoindetectiononblockjoin.value and player.blockedjoin), (commandrefs[4].previouslyremovedevent.value == 2 or players.exists(players.get_script_host())))
    end

    if (player.host_token[1] == "0" or player.host_token[1] == "1") and player:has_classification("Spoofed Host Token", false) then
        do_affected_detection(player_id, "spoofinghosttoken", !(commandrefs[4].spoofinghosttokenignorehost.value and player_id == players.get_host() or commandrefs[4].kickignorejoindetectiononblockjoin.value and player.blockedjoin))
    end

    util.create_tick_handler(function() -- i should, but really dont want to redo whatever the fuck this mess is
        if not players.exists(player_id) then return false end
        if not (util.in_session() and players.get_script_host() != -1) then return end

        if player_id == players.user() then
            if commandrefs[4].kleptomaniac.value then
                if kleptomaniac != 0 and util.current_time_millis() > kleptomaniac and players.get_script_host() != player_id then
                    menu.rbrp(menu.pr(player_id), "Friendly>Give Script Host"):trigger()
                    util.yield(1000)
                end
            elseif commandrefs[4].automaticmigration.value != 0 then
                local player = shadovis(players.get_script_host())
                if !player then return end
                local current_ping, current_packet_loss = math.round(average_from_list(player.ping, 30, true, {max = 300, penalty = 1.5})), math.round(average_from_list(player.packet_loss, 30), 2)
                if (commandrefs[4].automaticmigration.value == 2 and players.get_script_host() == player_id) or (
                    #player.ping >= 15 and #player.packet_loss >= 15 and
                    (player.unstable.state or current_ping >= 300 or current_packet_loss >= 0.5)
                ) then
                    if commandrefs[4].automaticmigration.value == 2 then
                        local candidates = {}
                        for players.list_except(true) as candidate_id do
                            player = shadovis(candidate_id)
                            local temp_ping, temp_packet_loss = math.round(average_from_list(player.ping, 30, true, {max = 300, penalty = 1.5})), math.round(average_from_list(player.packet_loss, 30), 2)
                            if (player.unstable.state or temp_ping >= 300 or temp_packet_loss >= 0.5) then continue end
                            candidates[#candidates + 1] = {player_id = candidate_id, ping = temp_ping, packet_loss = temp_packet_loss}
                        end

                        if #candidates > 0 then
                            local selected_candidate = {player_id = -1, ping = -1, packet_loss = -1}
                            for candidates as candidate do
                                if (selected_candidate.ping == -1 or candidate.ping < selected_candidate.ping) and (selected_candidate.packet_loss == -1 or candidate.packet_loss < selected_candidate.packet_loss) then
                                    selected_candidate = candidate
                                end
                            end

                            if players.exists(selected_candidate.player_id) then
                                util.notify($"Switching script host to {shadovis(selected_candidate.player_id).name}.")
                                menu.rbrp(menu.pr(selected_candidate.player_id), "Friendly>Give Script Host"):trigger()
                            end
                        else
                            menu.rbrp(menu.pr(player_id), "Friendly>Give Script Host"):trigger()
                        end
                    elseif commandrefs[4].automaticmigration.value == 3 then
                        menu.rbrp(menu.pr(player_id), "Friendly>Give Script Host"):trigger()
                    end

                    util.wait_time(15, function()
                        return !util.in_session() or commandrefs[4].kleptomaniac.value
                    end)
                end
            end
        else
            for i = 1, 2 do
                local new_list, player = {[1] = i == 1 ? NETWORK_GET_AVERAGE_PING(player_id) : NETWORK_GET_AVERAGE_PACKET_LOSS(player_id)}, shadovis(player_id)
                for i2 = 1, #player[i == 1 ? "ping" : "packet_loss"] do
                    if i2 >= 30 then break end
                    new_list[i2 + 1] = player[i == 1 ? "ping" : "packet_loss"][i2]
                end
                player[i == 1 ? "ping" : "packet_loss"] = new_list
            end
            util.yield(1000)
        end
    end)

    util.create_tick_handler(function()
        if player_id == players.user() then return false end
        util.wait_time(1, function()
            return !players.exists(player_id)
        end)
        if players.exists(player_id) and commandrefs[4].preferenceaddpreviousdetections.value and all_players[player.rockstar_id]?.detections then
            for all_players[player.rockstar_id].detections as detection do
                if not detection or player:has_classification(detection.name, false) then continue end
                local detection_extra;
                for detection.extras as extra do detection_extra = extra break end
                local commandref = players.add_detection(player_id, $"{detection.name}{detection_extra and $" ({detection_extra})" or ""}", 0, 0)
                if !commandref:isValid() then return end
                all_players[player.rockstar_id].detections[detection.hash].fake.commandref, all_players[player.rockstar_id].detections[detection.hash].fake.bypass = commandref, commandref, true
            end
        end
        while players.exists(player_id) and not players.exists(players.get_script_host()) do
            util.yield()
        end
        if players.exists(player_id) then
            player:match_ip()
        end
        while players.exists(player_id) and (!util.in_session() or !players.valid_position(player_id)) do
            util.yield()
        end
        if players.exists(player_id) then
            player.vehicletakeover = player:has_classification(detections.blockingvehicletakeover.name) ? 2 : 0
        end
        if players.exists(player_id) and !util.in_activity() and !player:has_classification(detections.blockingvehicletakeover.name) then
            while players.exists(player_id) and !(commandrefs[4].checkforvehicletakeover.value and players.get_vehicle(player_id, true) and check_player_data(player_id)) do
                util.yield()
            end
            if players.exists(player_id) and commandrefs[4].checkforvehicletakeover.value and entities.get_owner(players.get_vehicle(player_id, true)) == player_id and !request_entity_control(players.get_vehicle(player_id, true)) then
                player.vehicletakeover = 2
                do_affected_detection(player_id, "blockingvehicletakeover")
            else player.vehicletakeover = 1 end
        end
        return false
    end)
end)

players.on_leave(function(player_id)
    local player = shadovis(player_id)
    player.ready = false
    if player_id == players.user() then
        kleptomaniac = 0
    elseif player.otr.blip != nil then
        util.remove_blip(player.otr.blip)
    end

    execute_modules("on_leave", nil, player_id)
end)

players.dispatch_on_join()

players.add_command_hook(function(player_id, player_root)
    while players.exists(player_id) and !script_start do util.yield() end
    if !players.exists(player_id) then return end

    local player = shadovis(player_id)
    player:ready_data()

    player_root = player_root:isValid() ? player_root : menu.pr(player_id)

    if !players.exists(player_id) then return end

    if player_id != players.user() then
        local shghosted = menu.rbrp(player_root, "Information>Status>Session Player ID / Slot"):attachAfter(menu.shadow_root():readonly("Shadovis Ghosted", "N/A"))

        local vehicletakeover = menu.rbrp(player_root, "Information>Status>Session Player ID / Slot"):attachAfter(menu.shadow_root():readonly("Vehicle Takeover", "N/A"))

        shghosted:onTickInViewport(function() shghosted.value = tostring(player.shghosted):upper(1) end)
        vehicletakeover:onTickInViewport(function() vehicletakeover.value = player.vehicletakeover == 0 ? "N/A" : player.vehicletakeover == 1 ? "Passed" : "Blocked" end)

        player.toggle_loops.tploop = menu.rbrp(player_root, "Teleport>Teleport To Them"):attachBefore(
            menu.shadow_root():toggle_loop("Teleport To Them Loop", {"tploop"}, "", function()
                if not (players.exists(player_id) and players.valid_position(player_id)) then
                    SET_PED_CAN_RAGDOLL(players.user_ped(), true)
                    tploopplayer = nil
                end
                if tploopplayer != nil and tploopplayer != player_id and players.exists(tploopplayer) then
                    shadovis(tploopplayer).toggle_loops.tploop.value = false
                    while tploopplayer != nil do
                        util.yield()
                    end
                end

                tploopplayer = player_id
                local position = players.get_position(player_id)
                local state, ground = util.get_ground_z(position.x, position.y, position.z + 5)
                SET_PED_CAN_RAGDOLL(players.user_ped(), false)
                SET_ENTITY_COORDS_NO_OFFSET(players.user_ped(), v3.setZ(position, (state and (ground >= position.z) and ground or position.z) + 1), true, true, false)
            end, function()
                SET_PED_CAN_RAGDOLL(players.user_ped(), true)
                SET_ENTITY_COORDS_NO_OFFSET(players.user_ped(), shadovis(players.user()).antitp.position, false, false, false)
                tploopplayer = nil
            end)
        )

        local sk_root = menu.rbrp(player_root, "Kick>Smart"):attachBefore(menu.shadow_root():list("Shadovis", {}, "Kicks players based on your kick preferences."))

        sk_root:action("Kick", {"shadoviskick", "shadovkick", "skick", "sk"}, "", || -> player:kick(true, false, true))

        sk_root:action("Block Join Kick", {"shadovisblockkick", "shadovblockkick", "sbkick", "sbk"}, "", function()
            player:history_edit({{path = "Note", state = "Blast Kicked"}, {path = "Whitelist Join", state = false}, {path = "Player Join Reactions>Notification", state = true}, {path = "Player Join Reactions>Block Join", state = true}})
            player:kick(true, false, true)
        end)

        local sc_root = menu.rbrp(player_root, "Crash>Elegant"):attachBefore(menu.shadow_root():list("Shadovis", {}, "Crashes players based on your crash preferences."))

        sc_root:action("Crash", {"shadoviscrash", "shadovcrash", "scrash", "sc"}, "", function()
            player:crash(true, false, true)
            util.notify(successfulcommand)
        end)

        sc_root:action("Block Join Crash", {"shadovisblockcrash", "shadovblockcrash", "sbcrash", "sbc"}, "", function()
            player:history_edit({{path = "Note", state = "Blast Crashed"}, {path = "Whitelist Join", state = false}, {path = "Player Join Reactions>Notification", state = true}, {path = "Player Join Reactions>Block Join", state = true}})
            player:crash(true, false, true)
            util.notify(successfulcommand)
        end)

        if menu_version > 1 then
            menu.rbrp(player_root, "Crash>Elegant"):attachBefore(
                menu.shadow_root():action("All", {}, "", function()
                    local usable_crashes = {[1] = "Elegant", [3] = "Burger King Foot Lettuce", [4] = "Vehicular Manslaughter"}
                    if commandrefs[4]?.preferencesteamrollercrash?.value then usable_crashes[2] = "Steamroller" end
                    for usable_crashes as method do
                        if method == "Vehicular Manslaughter" and not players.get_vehicle(player_id, false) then continue end
                        menu.rbrp(player_root, $"Crash>{method}"):trigger()
                        util.yield(1000)
                        if !players.exists(player_id) then break end
                    end
                    util.notify(successfulcommand)
                end)
            )
        end
    end

    player_root:divider("Shadovis")

    player.commandrefs.friendly = player_root:list("Friendly", {}, "")

    player.commandrefs.friendly:action("Stealth Indestructible Vehicle", {"givestealthindestructible", "givestealthvehgodmode"}, "This is now detected since Stand 110.4, other menus might not detect it however.", function()
        spectate_if_needed(player_id, false, function()
            local vehicle = players.get_vehicle(player_id, true)
            if not vehicle then util.notify($"{player.name} isn't driving in a vehicle.") return end
            if entities.is_vehicle_indestructible(vehicle, true) then util.notify($"{player.name} already has a stealth godmode vehicle.") return end
            if request_entity_control(vehicle, 3, false) then
                player.vehicletakeover = player.vehicletakeover == 2 ? 2 : 1
                SET_ENTITY_PROOFS(vehicle, true, false, true, true, true, true, true, true)
            else
                player.vehicletakeover = 2
                do_affected_detection(player_id, "blockingvehicletakeover")
                util.notify($"Couldn't get control of {player.name}'s vehicle.")
            end
            if not request_entity_control(vehicle, 1, true) then return end
            util.notify(successfulcommand)
        end)
    end, nil, nil, COMMANDPERM_FRIENDLY)

    player.toggle_loops.stealth_indestructible = player.commandrefs.friendly:toggle_loop("Stealth Indestructible Vehicle", {"stealthindestructible", "stealthvehgodmode"}, "This is now detected since Stand 110.4, other menus might not detect it however.", function()
        if !players.exists(player_id) then return end
        local vehicle = players.get_vehicle(player_id, true)
        if vehicle and player.antitp.vehicle.time == 0 and !entities.is_vehicle_indestructible(vehicle, true) then
            if request_entity_control(vehicle, 10, false) then
                player.vehicletakeover = player.vehicletakeover == 2 ? 2 : 1
                SET_ENTITY_PROOFS(vehicle, true, false, true, true, true, true, true, true)
            else
                player.vehicletakeover = 2
                do_affected_detection(player_id, "blockingvehicletakeover")
                util.notify($"Couldn't get control of {player.name}'s vehicle.")
                player.toggle_loops.stealth_indestructible.value = false
            end
            request_entity_control(vehicle, 1, true)
        end
    end, function()
        if !(players.exists(player_id) and util.can_continue()) then return end
        local vehicle = players.get_vehicle(player_id, true)
        if !vehicle then return end
        if entities.is_vehicle_indestructible(vehicle, true) and request_entity_control(vehicle, 3, false) then
            player.vehicletakeover = player.vehicletakeover == 2 ? 2 : 1
            SET_ENTITY_PROOFS(vehicle, false, false, false, false, false, false, false, false)
        end
        if entities.get_owner(vehicle) == player_id then
            player.vehicletakeover = 2
            do_affected_detection(player_id, "blockingvehicletakeover")
        end
        request_entity_control(vehicle, 1, true)
    end, COMMANDPERM_FRIENDLY)

    if player_id != players.user() then
        player.toggle_loops.force_org = player.commandrefs.friendly:toggle_loop("Force Organization", {"forceorg"}, "Forces you to be in their organization.", function()
            if !players.exists(player_id) then orgplayer = nil return end
            if orgplayer != nil and orgplayer != player_id and players.exists(orgplayer) then
                shadovis(orgplayer).toggle_loops.force_org.value = false
                while orgplayer != nil do
                    util.yield()
                end
            end
            orgplayer = player_id
            if players.get_boss(player_id) != -1 then
                memory.write_int(globals[9](players.user()), players.get_org_type(player_id))
                memory.write_int(globals[10](players.user()), players.get_boss(player_id))
            elseif players.get_boss(players.user()) != players.user() then
                memory.write_int(globals[9](players.user()), -1)
                memory.write_int(globals[10](players.user()), -1)
            end
        end, function()
            memory.write_int(globals[9](players.user()), -1)
            memory.write_int(globals[10](players.user()), -1)
            orgplayer = nil
        end)
    end

    player.commandrefs.trolling = player_root:list("Trolling", {}, "")

    player.commandrefs.trolling:textslider("Become Their Wheel", {"becomewheel"}, "This likely won't work on most modders as it will be a modded event. If you ever get stuck, open the commandbox and type \"detach\".", {"Attach", "Detach"}, function(state)
        if state == 1 then
            spectate_if_needed(player_id, false, function()
                local vehicle = players.get_vehicle(player_id, false)
                if not vehicle then util.notify($"{player.name} isn't in a car.") return end
                if IS_ENTITY_ATTACHED_TO_ENTITY(vehicle, players.user_ped()) then util.notify($"You're already attached to {player.name}'s car.") return end

                local validbone;
                for i = 1, 4 do
                    if entities.get_bone(vehicle, vehicle_bones[i]) != nil then
                        validbone = vehicle_bones[i] break
                    end
                end
                if not validbone then util.notify($"{player.name}'s car doesn't have a valid bone.") return end

                if players.get_vehicle(players.user(), false) then CLEAR_PED_TASKS_IMMEDIATELY(players.user_ped()) end

                DISABLE_CAM_COLLISION_FOR_OBJECT(vehicle)
                ATTACH_ENTITY_TO_ENTITY(players.user_ped(), vehicle, entities.get_bone(vehicle, validbone), v3.new(), v3.new(), false, false, false, false, 1, false, 0)
            end)
        else
            local entity = GET_ENTITY_ATTACHED_TO(players.user_ped())
            if not (entity and DOES_ENTITY_EXIST(entity)) then util.notify($"You're not attached to {player.name}'s car.") return end
            DETACH_ENTITY(players.user_ped(), true, false)
        end
        util.notify(successfulcommand)
    end)

    player.commandrefs.trolling:list_action("Attach To Bone", {"attachbone"}, "", menu.table_to_list(vehicle_bones, "Attach", "Detach"), function(state, name)
        if name == "Detach" then
            local entity = GET_ENTITY_ATTACHED_TO(players.user_ped())
            if not (entity and DOES_ENTITY_EXIST(entity)) then util.notify($"You're not attached to {player.name}'s vehicle.") return end
            DETACH_ENTITY(players.user_ped(), true, false)
            util.notify(successfulcommand) return
        end

        spectate_if_needed(player_id, false, function()
            local vehicle = players.get_vehicle(player_id, false)
            if not vehicle then util.notify($"{player.name} isn't in a vehicle.") return end

            if state > 1 and entities.get_bone(vehicle, name) == nil then
                util.notify($"{player.name}'s vehicle doesn't have this bone.") return
            end

            local validbone;
            if state == 1 then
                for vehicle_bones as bone do
                    if entities.get_bone(vehicle, bone) != nil then
                        validbone = bone break
                    end
                end
                if not validbone then util.notify($"{player.name}'s vehicle doesn't have a valid bone.") return end
            else
                validbone = name
            end

            if players.get_vehicle(players.user(), false) then CLEAR_PED_TASKS_IMMEDIATELY(players.user_ped()) end
            DISABLE_CAM_COLLISION_FOR_OBJECT(vehicle)
            ATTACH_ENTITY_TO_ENTITY(players.user_ped(), vehicle, entities.get_bone(vehicle, validbone), v3.new(), v3.new(), false, false, false, false, 1, false, 0)
            util.notify(successfulcommand)
        end)
    end)

    player.commandrefs.trolling:action("Attach Clones To Wheels", {"wheelclones"}, "Modders are likely gonna block this because this is a modded event.", function()
        spectate_if_needed(player_id, false, function()
            local vehicle = players.get_vehicle(player_id, false)
            if not vehicle then util.notify($"{player.name} isn't in a car.") return end
            local hash;
            for i = 1, 2 do
                if IS_PED_MODEL(players.get_ped(player_id), util.joaat(i == 1 ? "mp_m_freemode_01" : "mp_f_freemode_01")) then
                    hash = util.joaat(i == 1 ? "mp_m_freemode_01" : "mp_f_freemode_01")
                end
            end

            for i = 1, 10 do
                if entities.get_bone(vehicle, vehicle_bones[i]) != nil then
                    local ped = create_ped(hash, always_exist = player_id)
                    CLONE_PED_TO_TARGET(players.get_ped(player_id), ped)
                    ATTACH_ENTITY_TO_ENTITY(ped, vehicle, entities.get_bone(vehicle, vehicle_bones[i]), v3.new(), v3.new(), false, false, false, false, 1, false, 0)
                end
            end
            util.notify(successfulcommand)
        end)
    end, nil, nil, COMMANDPERM_NEUTRAL)

    player.toggle_loops.overwork_renderer = player.commandrefs.trolling:toggle_loop("Overwork Renderer", {"overworkrenderer", "or"}, "This is a particle that if spammed, fucks players renderer to the point their screen will go wonky.", function()
        if not players.exists(player_id) then return end
        if not HAS_NAMED_PTFX_ASSET_LOADED("scr_xt_trip") then
            REQUEST_NAMED_PTFX_ASSET("scr_xt_trip")
            util.wait_time(1, function()
                return HAS_NAMED_PTFX_ASSET_LOADED("scr_xt_trip")
            end)
        end
        if HAS_NAMED_PTFX_ASSET_LOADED("scr_xt_trip") then
            local predicted_position = v3.add(players.get_cam_pos(player_id), v3.mul(GET_ENTITY_VELOCITY(players.get_ped(player_id)), util.get_tps() / 1000 + NETWORK_GET_AVERAGE_PING(player_id) / 1000))

            local above_ground = util.get_ground_z(predicted_position.x, predicted_position.y, predicted_position.z)
            if !above_ground then
                local state, ground = util.get_ground_z(predicted_position.x, predicted_position.y, players.get_cam_pos(player_id).z)
                if state then predicted_position.z = ground end
            end

            for i = 1, 5 do
                USE_PARTICLE_FX_ASSET("scr_xt_trip")
                START_NETWORKED_PARTICLE_FX_NON_LOOPED_AT_COORD("scr_xt_trip_rabbit_death", predicted_position, v3.new(), 10, false, false, false, false)
            end
            if player_id != players.user() then
                util.draw_sphere(predicted_position, 0.1, 255, 255, 255)
                REMOVE_PARTICLE_FX_IN_RANGE(predicted_position, 1)
            end
        end
    end, nil, COMMANDPERM_AGGRESSIVE)

    player.toggle_loops.fake_explosion = player.commandrefs.trolling:toggle_loop("Fake Explosion", {"fakeexplode"}, "This is just a particle that emits sound.", function()
        if not players.exists(player_id) then return end
        if not HAS_NAMED_PTFX_ASSET_LOADED("scr_xt_dax") then
            REQUEST_NAMED_PTFX_ASSET("scr_xt_dax")
            util.wait_time(1, function()
                return HAS_NAMED_PTFX_ASSET_LOADED("scr_xt_dax")
            end)
        end
        if HAS_NAMED_PTFX_ASSET_LOADED("scr_xt_dax") then
            local position = v3.add(players.get_position(player_id), v3.mul(GET_ENTITY_VELOCITY(players.get_ped(player_id)), NETWORK_GET_AVERAGE_PING(player_id) / 1000))
            USE_PARTICLE_FX_ASSET("scr_xt_dax")
            START_NETWORKED_PARTICLE_FX_NON_LOOPED_AT_COORD("scr_xt_dax_exp_gascan", position.x, position.y, position.z, v3.new(), 1, false, false, false, false)
            util.wait_time(5, function()
                return !player.toggle_loops.fake_explosion.value
            end)
        end
    end, nil, COMMANDPERM_RUDE)

    if player_id != players.user() then
        player.commandrefs.trolling:action("Murder", {"murder"}, "Tries to find a ped close to the player first, otherwise it'll spawn one.", || -> spectate_if_needed(player_id, true, function()
            local function attack_with_ped(player_id: int, ped: int, teleport: ?bool = false): bool
                if entities.get_owner(ped) != players.user() and !request_entity_control(ped, 5, false) then
                    util.notify($"{shadovis(entities.get_owner(ped)).name} is blocking the control request for some reason.")
                return false end
                GIVE_WEAPON_TO_PED(ped, util.joaat("weapon_heavysniper_mk2"), 9999, false, false)
                SET_CURRENT_PED_WEAPON(ped, util.joaat("weapon_heavysniper_mk2"), true)
                SET_PED_ACCURACY(ped, 100)
                local timeout = util.current_time_millis() + 10000
                while util.current_time_millis() < timeout do
                    local position, rotation = players.get_position(player_id), math.rad(GET_ENTITY_HEADING_FROM_EULERS(players.get_ped(player_id)))
                    local behind_position, forward_position = v3.new(position.x + 1 * math.sin(rotation), position.y - 1 * math.cos(rotation), position.z + 0.3), v3.new(position.x - 5 * math.sin(rotation), position.y + 5 * math.cos(rotation), position.z + 0.3)
                    if request_entity_control(ped, 1, false) and teleport then
                        SET_ENTITY_COORDS_NO_OFFSET(ped, v3.setZ(position, position.z + 50), false, false, false)
                    end
                    if IS_PED_RAGDOLL(players.get_ped(player_id)) then
                        behind_position, forward_position = players.get_position(player_id), players.get_position(player_id)
                        behind_position.z += 50
                    end
                    SHOOT_SINGLE_BULLET_BETWEEN_COORDS_IGNORE_ENTITY_NEW(behind_position, forward_position, 9999, 0, util.joaat("weapon_heavysniper_mk2"), ped, false, true, 9999, players.get_vehicle(player_id, false) or 0, 0, 0, players.get_ped(player_id), 0, 0, 0, 0)
                    if not players.exists(player_id) or IS_PLAYER_DEAD(player_id) then break end
                    util.yield(100)
                end
                request_entity_control(ped, 1, true)
                return true
            end

            local ped, pedInt, timeout = nil, allocated_memory[2], util.current_time_millis() + 3000
            while !GET_CLOSEST_PED(players.get_position(player_id), 100, 1, 0, pedInt, 0, 1, -1) and util.current_time_millis() < timeout do
                util.yield()
            end
            if !(GET_CLOSEST_PED(players.get_position(player_id), 100, 1, 0, pedInt, 0, 1, -1) and attack_with_ped(player_id, memory.read_int(pedInt))) then
                local closestPed, closestDistance, closestPosition = nil, math.huge, v3.new()
                for entities.get_all_vehicles_as_pointers() as vehicle_pointer do
                    if v3.distance(entities.get_position(vehicle_pointer), players.get_position(player_id)) > 100 or entities.get_health(vehicle_pointer) == 0 then continue end
                    local ped = GET_PED_IN_VEHICLE_SEAT(entities.pointer_to_handle(vehicle_pointer), -1, true)
                    if ped == 0 or entities.get_health(ped) == 0 then continue end
                    local position = GET_ENTITY_COORDS(ped, false)
                    local distance = v3.distance(closestPosition, position) or nil
                    if ped != 0 and !entities.is_player_ped(ped) and (!closestPed or distance < closestDistance) then
                        closestPed, closestDistance, closestPosition = ped, distance, position
                    end
                end

                if !(closestPed and attack_with_ped(player_id, closestPed)) then
                    util.notify($"Spawned in a ped on {player.name}.")
                    ped = create_ped(nil, true, false, "weapon_heavysniper_mk2", player_id)
                    if commandrefs[4].waitforpedsync.value then
                        util.yield(3500)
                    end
                    attack_with_ped(player_id, ped, true)
                    entities.delete(ped)
                end
            end
        end), nil, nil, COMMANDPERM_RUDE)

        local killerped;
        player.toggle_loops.killwithped = player.commandrefs.trolling:toggle_loop("Murder Loop", {"murderloop"}, "Doesn't work over long distances. Spectate them if it doesn't work.", function()
            if not players.exists(player_id) then return end
            if not (killerped and DOES_ENTITY_EXIST(killerped)) then
                killerped = create_ped(nil, true, false, "weapon_heavysniper_mk2", player_id)
                if commandrefs[4].waitforpedsync.value then
                    util.yield(3500)
                end
            end
            request_entity_control(killerped, 1, false)
            SET_ENTITY_COORDS_NO_OFFSET(killerped, v3.setZ(players.get_position(player_id), players.get_position(player_id).z + 50), false, false, false)
            if not IS_PLAYER_DEAD(player_id) then
                local position, rotation = players.get_position(player_id), math.rad(GET_ENTITY_HEADING_FROM_EULERS(players.get_ped(player_id)))
                local behind_position, forward_position = v3.new(position.x + 1 * math.sin(rotation), position.y - 1 * math.cos(rotation), position.z + 0.3), v3.new(position.x - 5 * math.sin(rotation), position.y + 5 * math.cos(rotation), position.z + 0.3)
                if IS_PED_RAGDOLL(players.get_ped(player_id)) then
                    behind_position, forward_position = players.get_position(player_id), players.get_position(player_id)
                    behind_position.z += 50
                end
                SHOOT_SINGLE_BULLET_BETWEEN_COORDS_IGNORE_ENTITY_NEW(behind_position, forward_position, 9999, 0, util.joaat("weapon_heavysniper_mk2"), killerped, false, true, 9999, players.get_vehicle(player_id, false) or 0, 0, 0, players.get_ped(player_id), 0, 0, 0, 0)
            end
        end, function()
            if killerped and DOES_ENTITY_EXIST(killerped) then
                entities.delete(killerped)
            end
        end)

        player.commandrefs.trolling:action("Stun Gun", {"stungun"}, "", || -> spectate_if_needed(player_id, true, function()
            local ped = create_ped(nil, true, false, "weapon_stungun_mp", player_id)
            if commandrefs[4].waitforpedsync.value then
                util.yield(3500)
            end
            local timeout, vehicle = util.current_time_millis() + 10000, players.get_vehicle(player_id, false)
            while util.current_time_millis() < timeout do
                if not players.exists(player_id) then break end
                local position, rotation = players.get_position(player_id), math.rad(GET_ENTITY_HEADING_FROM_EULERS(players.get_ped(player_id)))
                local behind_position, forward_position = v3.new(position.x + 1 * math.sin(rotation), position.y - 1 * math.cos(rotation), position.z + 0.3), v3.new(position.x - 5 * math.sin(rotation), position.y + 5 * math.cos(rotation), position.z + 0.3)
                SET_ENTITY_COORDS_NO_OFFSET(ped, v3.setZ(position, position.z + 50), false, false, false)
                if IS_PED_RAGDOLL(players.get_ped(player_id)) then
                    behind_position, forward_position = players.get_position(player_id), players.get_position(player_id)
                    behind_position.z += 50
                end
                SHOOT_SINGLE_BULLET_BETWEEN_COORDS_IGNORE_ENTITY_NEW(behind_position, forward_position, 0, 0, util.joaat("weapon_stungun_mp"), ped, false, true, 9999, players.get_vehicle(player_id, false) or 0, 0, 0, players.get_ped(player_id), 0, 0, 0, 0)
                if not players.exists(player_id) or IS_PED_BEING_STUNNED(players.get_ped(player_id), 0) then break end
                util.yield(100)
            end
            if players.exists(player_id) and IS_PED_BEING_STUNNED(players.get_ped(player_id), 0) and vehicle then
                SET_ENTITY_VISIBLE(ped, false, 0)
                timeout = util.current_time_millis() + 3000
                repeat
                    SET_ENTITY_COORDS_NO_OFFSET(ped, v3.setZ(players.get_position(player_id), players.get_position(player_id).z + 50), false, false, false)
                    util.yield()
                until not players.exists(player_id) or players.get_vehicle(player_id, false) != vehicle or util.current_time_millis() >= timeout
                if players.get_vehicle(player_id, false) != vehicle then
                    timeout = util.current_time_millis() + 10000
                    repeat
                        SET_ENTITY_COORDS_NO_OFFSET(ped, v3.setZ(players.get_position(player_id), players.get_position(player_id).z + 50), false, false, false)
                        util.yield()
                    until not players.exists(player_id) or not IS_PED_BEING_STUNNED(players.get_ped(player_id), 0) or util.current_time_millis() >= timeout
                end
            end
            entities.delete(ped)
        end), nil, nil, COMMANDPERM_RUDE)
    end

    local function chance(percentage: float): bool
        return (math.random(1000) / 1000) <= percentage
    end

    local zombies, chances = {}, {
        zombies = {
            spawn = 0.1,
            normal = 0.5,
            ranged = 0.1,
            hound = 0.2,
            boss = 0.005
        },
        rewards = {
            chance = 0.11,
            autoheal = 0.2,
            rpandcash = 0.2,
            otr = 0.2,
            giverp = 1
        }
    }
    player.commandrefs.trolling:toggle_loop("Zombie Outbreak", {"zombieoutbreak"}, "Have you ever wanted to play COD zombies in GTA? Well this ain't it, but it's close enough.", function()
        if not players.exists(player_id) then return end
        if not (HAS_NAMED_PTFX_ASSET_LOADED("scr_rcbarry1") and HAS_NAMED_PTFX_ASSET_LOADED("scr_rcbarry2")) then
            REQUEST_NAMED_PTFX_ASSET("scr_rcbarry1") REQUEST_NAMED_PTFX_ASSET("scr_rcbarry2") return
        end

        local player_position, total_zombies = players.get_position(player_id), 0
        for zombies as zombie_info do
            if zombie_info?.zombie and DOES_ENTITY_EXIST(zombie_info.zombie) then
                ++total_zombies
            end
        end

        for i = 1, 64 do
            if total_zombies > 15 or !chance(chances.zombies.spawn) then continue end
            local radius, angle = math.random(25, 50), (i - 1) * (2 * math.pi / 64)
            local vector = v3.new(player_position.x + radius * math.cos(angle), player_position.y + radius * math.sin(angle), player_position.z)

            vector.z = util.get_lowest_ground_z(vector.x, vector.y, 1000, vector.z)
            if vector.z < (player_position.z - 10) or vector.z > (player_position.z + 10) then continue end

            for zombie_type, zombie_chance in chances.zombies do
                if zombie_type == "spawn" or !chance(zombie_chance) then continue end

                local zombie_hash, zombie_weapon, int = util.joaat(
                    (zombie_type == "normal" or zombie_type == "ranged") and "u_m_y_zombie_01" or
                    zombie_type == "hound" and "a_c_coyote_02" or
                    zombie_type == "boss" and "u_m_m_juggernaut_03"
                ), util.joaat(
                    zombie_type == "normal" and "WEAPON_SWITCHBLADE" or
                    zombie_type == "ranged" and "WEAPON_PRECISIONRIFLE" or
                    zombie_type == "hound" and "" or
                    zombie_type == "boss" and "WEAPON_CARBINERIFLE_MK2"
                ), #zombies + 1

                util.request_model(zombie_hash, 3000)
                zombies[int] = {
                    zombie = create_ped(zombie_hash, false, true, zombie_weapon, player_id),
                    type = zombie_type,
                    hp_timer = util.current_time_millis() + 1000,
                    path_timer = 0,
                    attack_timer = 0
                }
                ++total_zombies

                USE_PARTICLE_FX_ASSET("scr_rcbarry2")
                START_NETWORKED_PARTICLE_FX_NON_LOOPED_AT_COORD("scr_clown_death", v3.addNew(vector, v3.new(0, 0, 0.5)), v3.new(), 1, false, false, false, false)

                SET_BLOCKING_OF_NON_TEMPORARY_EVENTS(zombies[int].zombie, true)
                SET_PED_COMBAT_ATTRIBUTES(zombies[int].zombie, 5, true)
                SET_PED_COMBAT_ATTRIBUTES(zombies[int].zombie, 58, true)
                SET_PED_COMBAT_ABILITY(zombies[int].zombie, 3)
                if zombie_type == "boss" then
                    CHANGE_PED_HEALTH(zombies[int].zombie, 1600)
                    SET_PED_SUFFERS_CRITICAL_HITS(zombies[int].zombie, false)
                    SET_PED_CAN_RAGDOLL(zombies[int].zombie, false)
                end
                if zombie_type != "hound" then
                    SET_PED_PATH_CLIMB_COST_MODIFIER(zombies[int].zombie, 0.05)
                    SET_PED_COMBAT_ATTRIBUTES(zombies[int].zombie, 1, true)
                    SET_PED_ACCURACY(zombies[int].zombie, zombie_type == "boss" ? 50 : zombie_type == "ranged" ? 10 : 0)
                    SET_PED_PATH_CAN_USE_LADDERS(zombies[int].zombie, true)
                end

                SET_ENTITY_COORDS_NO_OFFSET(zombies[int].zombie, vector, false, false, false)

                local blip = ADD_BLIP_FOR_ENTITY(zombies[int].zombie)
                SET_BLIP_CATEGORY(blip, 7)
                SET_BLIP_SPRITE(blip, zombie_type == "normal" ? 126 : zombie_type == "ranged" ? 409 : zombie_type == "hound" ? 273 : zombie_type == "boss" ? 84 : 1)
                SET_BLIP_COLOUR(blip, 1)
                BEGIN_TEXT_COMMAND_SET_BLIP_NAME("STRING")
                ADD_TEXT_COMPONENT_SUBSTRING_PLAYER_NAME(zombie_type == "normal" ? "Zombie" : zombie_type == "ranged" ? "Ranged Zombie" : zombie_type == "hound" ? "Hell Hound" : zombie_type == "boss" ? "Zombie Boss" : "")
                END_TEXT_COMMAND_SET_BLIP_NAME(blip)

                break
            end
        end

        for int, zombie_info in zombies do
            if !(zombie_info?.zombie and DOES_ENTITY_EXIST(zombie_info.zombie)) then zombies[int].zombie = nil continue end
            request_entity_control(zombie_info.zombie, 1, false)
            local zombie_position = GET_ENTITY_COORDS(zombie_info.zombie, true)
            if GET_ENTITY_HEALTH(zombie_info.zombie) == 0 or v3.distance(player_position, zombie_position) >= 200 then
                USE_PARTICLE_FX_ASSET("scr_rcbarry2")
                START_NETWORKED_PARTICLE_FX_NON_LOOPED_AT_COORD("muz_clown", zombie_position, v3.new(), 1, false, false, false, false)

                local death_source = GET_PED_SOURCE_OF_DEATH(zombie_info.zombie)

                entities.delete(zombie_info.zombie)
                zombies[int].zombie = nil

                if IS_ENTITY_A_VEHICLE(death_source) then
                    death_source = GET_PED_IN_VEHICLE_SEAT(GET_VEHICLE_INDEX_FROM_ENTITY_INDEX(death_source), -1, true)
                end
                if IS_PED_A_PLAYER(death_source) then
                    util.create_tick_handler(function()
                        if chance(chances.rewards.chance) then
                            for reward_type, reward_chance in chances.rewards do
                                if reward_type == "chance" or !chance(reward_chance) then continue end

                                local timeout, reward_id = util.current_time_millis() + 15000, -1
                                while util.current_time_millis() < timeout do
                                    USE_PARTICLE_FX_ASSET("scr_rcbarry1")
                                    START_NETWORKED_PARTICLE_FX_NON_LOOPED_AT_COORD("scr_alien_teleport", zombie_position, v3.new(), 1, false, false, false, false)
                                    for players.list_except() as player_id2 do
                                        if v3.distance(players.get_position(player_id2), zombie_position) <= 1 then
                                            reward_id = player_id2 break 2
                                        end
                                    end
                                    util.yield()
                                end

                                if reward_id == -1 then return false end

                                local sound_id = GET_SOUND_ID()
                                local network_id = GET_NETWORK_ID_FROM_SOUND_ID(sound_id)
                                SET_NETWORK_ID_ALWAYS_EXISTS_FOR_PLAYER(network_id, players.user(), true)
                                SET_NETWORK_ID_ALWAYS_EXISTS_FOR_PLAYER(network_id, reward_id, true)
                                PLAY_SOUND_FROM_COORD(sound_id, "Score_Up", zombie_position, "DLC_IE_PL_Player_Sounds", true, 500, 0)
                                USE_PARTICLE_FX_ASSET("scr_rcbarry2")
                                START_NETWORKED_PARTICLE_FX_NON_LOOPED_AT_COORD("scr_clown_bul", zombie_position, v3.new(), 1, false, false, false, false)

                                util.notify($"{shadovis(reward_id).name} got the {tostring(
                                    reward_type == "autoheal" and "auto heal" or
                                    reward_type == "rpandcash" and "rp & cash" or
                                    reward_type == "otr" and "off the radar" or
                                    reward_type == "giverp" and "rp"
                                )} power up!")

                                local path, looped = (
                                    reward_id == players.user() and (
                                        reward_type == "autoheal" and "Self>Auto Heal" or
                                        reward_type == "otr" and "Online>Off The Radar"
                                    ) or
                                    reward_type == "autoheal" and "Friendly>Auto Heal" or
                                    reward_type == "rpandcash" and "Friendly>Drop Casino Figurines" or
                                    reward_type == "giverp" and "Friendly>Give RP" or
                                    reward_type == "otr" and "Friendly>Off The Radar"
                                ), (
                                    reward_type == "autoheal" or
                                    reward_type == "rpandcash" or
                                    reward_type == "otr"
                                )
                                timeout = util.current_time_millis() + (
                                    reward_type == "autoheal" and 30 or
                                    reward_type == "rpandcash" and 5 or
                                    reward_type == "otr" and 120 or 0
                                ) * 1000

                                if looped then
                                    while players.exists(reward_id) and util.current_time_millis() < timeout and util.can_continue() do
                                        if reward_id == players.user() and (
                                            reward_type == "autoheal" or
                                            reward_type == "otr"
                                        ) then
                                            menu.rbp(path).value = true
                                        else
                                            menu.rbrp(menu.pr(reward_id), path).value = true
                                        end
                                        util.yield()
                                    end

                                    if reward_id == players.user() and (
                                        reward_type == "autoheal" or
                                        reward_type == "otr"
                                    ) then
                                        menu.rbp(path).value = false
                                    elseif players.exists(reward_id) then
                                        menu.rbrp(menu.pr(reward_id), path).value = false
                                    end
                                else
                                    menu.rbrp(menu.pr(reward_id), path):trigger()
                                end

                                break
                            end
                        end
                        return false
                    end)
                end
            else
                if util.current_time_millis() > zombie_info.hp_timer then
                    zombies[int].hp_timer = util.current_time_millis() + 1000
                    CHANGE_PED_HEALTH(zombie_info.zombie, GET_PED_MAX_HEALTH(zombie_info.zombie) - (GET_PED_MAX_HEALTH(zombie_info.zombie) / 100 * math.random(5)), true)
                end
                if !(zombie_info.type == "hound" and players.get_vehicle(player_id, false)) and v3.distance(player_position, zombie_position) < ((zombie_info.type == "ranged" or zombie_info.type == "boss") and 50 or 10) then
                    if util.current_time_millis() < zombie_info.attack_timer then continue end
                    zombies[int].attack_timer = util.current_time_millis() + 3000
                    TASK_COMBAT_PED(zombie_info.zombie, players.get_ped(player_id), 0, 16)
                elseif util.current_time_millis() > zombie_info.path_timer then
                    zombies[int].path_timer = util.current_time_millis() + 3000
                    TASK_GO_TO_ENTITY(zombie_info.zombie, players.get_ped(player_id), -1, 2.0, 100, 0, 0)
                end
            end
        end
    end, function()
        for int, zombie_info in zombies do
            if (zombie_info?.zombie and DOES_ENTITY_EXIST(zombie_info.zombie)) then
                entities.delete(zombie_info.zombie)
            end
            zombies[int].zombie = nil
        end
    end, COMMANDPERM_NEUTRAL)

    player.commandrefs.misc = player_root:list("Miscellaneous", {}, "")

    if player_id != players.user() then
        player.toggle_loops.block = player.commandrefs.misc:toggle_loop("Block Player", {"block"}, "This will block all syncs. Network events will be blocked from anyone who isn't the (script) host.", function()
            if !players.exists(player_id) then return end

            SET_REMOTE_PLAYER_AS_GHOST(player_id, true)
            SET_PLAYER_INVISIBLE_LOCALLY(player_id, true)

            local state = util.in_session() and players.valid_position(player_id) and !players.in_transition(player_id)
            menu.rbrp(player_root, "Network Events>Block").value = state and players.get_host() != player_id and players.get_script_host() != player_id
            menu.rbrp(player_root, "Incoming Syncs>Block").value = state
            menu.rbrp(player_root, "Outgoing Syncs>Block").value = state

            -- incase its flashing, turning it off and on again seems to work, same goes for the code below
            if IS_BLIP_FLASHING(memory.read_int(globals[13](player_id))) then
                memory.subtract(globals[14](player_id), 0x19, "short")
                util.yield()
            end
            memory.add(globals[14](player_id), 0x19, "short")
        end, function()
            menu.rbrp(player_root, "Network Events>Block").value = false
            menu.rbrp(player_root, "Incoming Syncs>Block").value = false
            menu.rbrp(player_root, "Outgoing Syncs>Block").value = false

            SET_REMOTE_PLAYER_AS_GHOST(player_id, false)
            memory.subtract(globals[14](player_id), 0x19, "short")

            -- when turning it off it could lead to the blip flashing, so this is the best way to mitigate it since it works quickly apparently
            while players.exists(player_id) and IS_PLAYER_DEAD(player_id) do util.yield() end
            util.wait_time(3, function()
                if !players.exists(player_id) then return true end
                if !IS_BLIP_FLASHING(memory.read_int(globals[13](player_id))) then return end
                while players.exists(player_id) and !player.toggle_loops.block.value and IS_BLIP_FLASHING(memory.read_int(globals[13](player_id))) do
                    memory.add(globals[14](player_id), 0x19, "short")
                    util.yield()
                    memory.subtract(globals[14](player_id), 0x19, "short")
                end
            end)
        end)
    end

    player.toggle_loops.spoofposition = player.commandrefs.misc:toggle_loop("Spoof To Position", {"positionspoof", "posspoof"}, "This will spoof your position to their position, can be modified with the offset found in settings.", function()
        if not (players.exists(player_id) and players.valid_position(player_id)) then
            spooftoplayer = nil
        end
        if spooftoplayer != nil and spooftoplayer != player_id and players.exists(spooftoplayer) then
            shadovis(spooftoplayer).toggle_loops.spoofposition.value = false
            while spooftoplayer != nil do
                util.yield()
            end
        end

        spooftoplayer = player_id
        local position = players.get_position(player_id)
        position.z = commandrefs[4].psol.value ? util.get_lowest_ground_z(position.x, position.y, position.z - 1, nil, 10) : position.z
        position = position:add(v3.new((commandrefs[4].psox.value / 100), (commandrefs[4].psoy.value / 100), (commandrefs[4].psoz.value / 100)))

        menu.rbp("Online>Spoofing>Position Spoofing>Spoofed Position"):trigger(position:toString())
        menu.rbp("Online>Spoofing>Position Spoofing>Position Spoofing").value = true
        if player_id != players.user() then
            util.draw_ar_beacon(position)
        end
    end, function()
        spooftoplayer, menu.rbp("Online>Spoofing>Position Spoofing>Position Spoofing").value = nil, false
    end)

    if player_id != players.user() then
        player.commandrefs.misc:action("Add As Fake Friend", {"fakefriend"}, "", function()
            if playerinfo[player.rockstar_id]?.friend then
                util.notify("This player is already a fake friend.")
            return end

            playerinfo[player.rockstar_id] = {name = player.actual_name, rockstar_id = player.rockstar_id, friend = true, blockjoin = false}
        end)

        player.commandrefs.misc:action("Add To Stealth Block Joins", {"stealthblockjoin"}, "", function()
            if playerinfo[player.rockstar_id]?.blockjoin then
                util.notify("This player is already being stealth blocked.")
            return end

            playerinfo[player.rockstar_id] = {name = player.actual_name, rockstar_id = player.rockstar_id, friend = false, blockjoin = true}
        end)
    end

    execute_modules("on_join", nil, player_id, menu.pr(player_id), player.commandrefs.friendly, player.commandrefs.trolling, player.commandrefs.misc)
end)

util.on_transition_finished(function()
    kleptomaniac = util.current_time_millis() + 30000

    execute_modules("transition_finished")
    execute_modules("on_spawn", nil, players.user())

    spawn_function(true)
end)

util.on_pre_stop(function()
    execute_modules("stop", nil, true)

    if util.in_session() then
        if commandrefs[4].undead_otr.value then
            SET_PED_MAX_HEALTH(players.user_ped(), 328)
        end
        if commandrefs[4].health_mod.value != 1 then
            CHANGE_PED_HEALTH(players.user_ped(), 328)
            SET_PLAYER_HEALTH_RECHARGE_MULTIPLIER(players.user(), 1)
        end
        if (vehicle := previous_vehicle?.vehicle) and DOES_ENTITY_EXIST(vehicle) and request_entity_control(vehicle) then
            if previous_vehicle.fillcarwithpeds != 1 then
                for previous_vehicle.peds as seat do
                    if seat?.ped and DOES_ENTITY_EXIST(seat.ped) then
                        entities.delete(seat.ped)
                    end
                    seat = nil
                end
            end
            if previous_vehicle.wheel_peds != 1 then
                for previous_vehicle.peds_2 as ped do
                    if ped?.ped and DOES_ENTITY_EXIST(ped.ped) then
                        entities.delete(ped.ped)
                    end
                    ped = nil
                end
            end
            if previous_vehicle.autodrive then
                CLEAR_PED_TASKS(players.user_ped())
            end
        end

        for player_list as player_id do
            for player_id.detections as detection do
                if !detection:isValid() then continue end
                detection:trigger()
            end
            if player_id.otr.blip != nil then
                util.remove_blip(player_id.otr.blip)
            end
        end
    end

    for players.list_except(true) as player_id do
        if shadovis(player_id).shghosted or shadovis(player_id).ghosted then
            SET_REMOTE_PLAYER_AS_GHOST(player_id, players.is_passive_mode(players.user()) or players.is_passive_mode(player_id))
        end
    end

    write_file($"{main_path}players.txt", json.encode(playerinfo, false))
    tick_handlers.vks.fileupdatetimes["players"] = util.current_unix_time_seconds()
end)

players.on_flow_event_done(function(player_id, name, extra)
    name = lang.get_localised(name)
    local player, detection, detection_extra = shadovis(player_id), string.match(name, "(.-)%s*%(") or name, string.match(name, "%((.-)%)") or extra

    local found_method = false
    for all_detections as method do
        if detection != method then continue end
        found_method = true
    break end
    for possible_detections as method do
        if detection != method then continue end
        found_method = true
    break end
    for detections as method do
        if detection != method.name then continue end
        found_method = true
    break end

    if !found_method then
        for generic_detections as method do
            if detection != method then continue end
            found_method = true
        break end
        for {"Script Host Kick", "Explosive User", "Arcade Game", "Removed Freemode Activity", "Session Breaking", "Service", "Open Interaction Menu", "Flight School", "Lightning Strike For Random Player", "Disable Passive Mode", "Darts", "Impromptu Deathmatch", "Slasher", "Cutscene"} as method do
            if detection != method then continue end
            found_method = true
        break end
        if found_method or !player:has_classification(detection, false) then return end
        possible_detections[#possible_detections + 1] = detection
        generic_detections[detection] = false
        commandrefs[4].root_detectionmemory_thirdpartydetections:toggle(detection, {}, "", function(state) generic_detections[detection] = state end, false)
        detections[$"possible_detection_{detection}"] = {name = detection, description = "", reason = $"for triggering {detection}", reactions = {note = detection, addnote = 3, blockjoins = 3, track = 3, timeout = 3, block = 3, kick = 3, crash = 3}}
        create_detection_commands($"possible_detection_{detection}", commandrefs[4].root_customreactions)
        if commandrefs[4].savethirdpartydetections.value then
            write_file($"{main_path}third_party_detections.txt", json.encode(possible_detections, true))
            tick_handlers.vks.fileupdatetimes["third_party_detections"] = util.current_unix_time_seconds()
        end
    end

    while !script_start do
        util.yield()
    end

    for possible_detections as method do
        if detection != method then continue end
        do_affected_detection(player_id, $"possible_detection_{method}")
    break end

    if !all_players[player.rockstar_id]?.detections?[hash_string(detection)]?.fake?.bypass then
        if detection == "Off The Radar For Too Long" then
            player.otr.time = util.current_time_millis() + 1000
        elseif detection == "Kick Event" and (!commandrefs[4].kickeventforgiveness.value or players.get_host() != players.user() or players.get_host_queue_position(player_id) != 1 or util.current_time_millis() >= (player.first_seen + 60000)) or detection == "Crash Event" and (!commandrefs[4].ignoretraincrash.value or detection_extra != "T9" and detection_extra != "TD") then
            do_affected_detection(player_id, detection == "Kick Event" ? "kickevent" : "crashevent")
        end
    end

    if player.ready and not all_players[player.rockstar_id]?.detections?[hash_string(detection)]?.fake?.bypass then
        for malicious_events as event do
            if detection != event then continue end
            if (event == "Start Freemode Mission" or event == "Teleport To Interior" or event == "Give Collectible") and detection_extra != "Not My Boss" or event == "Kick Event" and commandrefs[4].kickeventforgiveness.value and players.get_host() == players.user() and players.get_host_queue_position(player_id) == 1 and util.current_time_millis() < (player.first_seen + 60000) or event == "Crash Event" and commandrefs[4].ignoretraincrash.value and (detection_extra == "T9" or detection_extra == "TD") or (event == "Kick Event" or event == "Crash Event") and commandrefs[4].ignorekickandcrashevents.value or (event == "Vehicle Takeover" or event == "Kick From Vehicle") and util.in_activity() or event == "Modded Damage Event" and (menu.rbrp(menu.pr(player_id), "Timeout").value or player.toggle_loops.block.value) then break end
            
            if (event == "Vehicle Takeover" or event == "Kick From Vehicle") and player_id != players.user() and players.get_personal_vehicle(players.user()) != players.get_vehicle(players.user()) then
                local vehicle = players.get_vehicle(players.user())
                if !vehicle then break end
                local org_vehicle = switch entities.get_model_hash(vehicle) do
                    case util.joaat("kosatka") -> true
                    case util.joaat("hauler2") -> true
                    case util.joaat("phantom3") -> true
                    case util.joaat("terbyte") -> true
                    case util.joaat("avenger3") -> true
                    default -> false
                end

                if org_vehicle then
                    local owner = -1
                    for i = 0, 31 do
                        for {"Player_Vehicle", "Player_Truck", "Player_Truck", "Player_Submarine", "Player_Hacker_Truck"} as decor_type do
                            local decor, hash = DECOR_GET_INT(vehicle, decor_type), NETWORK_HASH_FROM_PLAYER_HANDLE(i)
                            if decor == -1 or hash == 0 or decor != hash then continue end
                            owner = i
                        break end
                    end
                    if owner != -1 and players.get_boss(player_id) == players.get_boss(owner) then break end
                else
                    for i = 0, 31 do
                        if i == players.user() or vehicle != shadovis(i).personal_vehicle and vehicle != shadovis(i).previous_personal_vehicle then continue end
                        if i == player_id or !players.exists(i) and (util.current_time_millis() - shadovis(i).last_seen) < 1000 then break 2 end
                    end
                end
            end
            if (event == "Vehicle Takeover" or event == "Kick From Vehicle") and player_id != players.user() then
                util.toast($"unauthorized vehicle access from {player.name}")
            end
            do_affected_detection(player_id, "maliciousevents")
        end
    end

    execute_modules("on_detection", nil, player_id, detection, detection_extra)

    if not (player_id != players.user() and commandrefs[4].detectionmemory.value and commandrefs[4].detectionmemory_method.value == 1) or ignore_this_detection(detection) then return end

    if not player.ready or all_players[player.rockstar_id] == nil then
        util.wait_time(5, function()
            return player.ready and all_players[player.rockstar_id] != nil
        end)
        if all_players[player.rockstar_id] == nil then return end
    end

    if menu_name := player:classification_root()?.menu_name then
        all_players[player.rockstar_id].classification = menu_name:gsub("Classification: ", "")
    end

    if not all_players[player.rockstar_id].detections[hash_string(detection)] then
        all_players[player.rockstar_id].detections[hash_string(detection)] = {name = detection, hash = hash_string(detection), extras = {}, fake = {commandref = nil, bypass = false}}
    elseif (commandref := all_players[player.rockstar_id].detections[hash_string(detection)].fake.commandref) and commandref:isValid() then
        if all_players[player.rockstar_id].detections[hash_string(detection)].fake.bypass then
            all_players[player.rockstar_id].detections[hash_string(detection)].fake.bypass = false
        else
            commandref:trigger()
            all_players[player.rockstar_id].detections[hash_string(detection)].fake.commandref = nil
        end
    end

    if not detection_extra then return end
    for all_players[player.rockstar_id].detections[hash_string(detection)].extras as i_extra do
        if detection_extra == i_extra then return end
    end
    all_players[player.rockstar_id].detections[hash_string(detection)].extras[#all_players[player.rockstar_id].detections[hash_string(detection)].extras + 1] = detection_extra
end)

chat.on_message(function(sender, reserved, text, team_chat, networked, is_auto)
    if !networked or is_auto or sender != reserved then return end
    if players.exists(sender) then
        if sender == players.user() then
            my_chat_messages[#my_chat_messages + 1] = {timestamp = util.current_unix_time_seconds(), message = text}
        else
            while !shadovis(sender).ready do util.yield() end
            all_players[shadovis(sender).rockstar_id].messages[#all_players[shadovis(sender).rockstar_id].messages + 1] = {timestamp = util.current_unix_time_seconds(), message = text}
        end
    end

    if sender != players.user() and text:contains(util.ip_to_string(shadovis(players.user()).ip)) then
        do_affected_detection(sender, "maliciousevents")
    end

    -- A fucked way to check it, but honestly I don't even care anymore.
    local match = text:match("[%p] %w+ triggered a detection:(.-)")
    if sender != players.user() and (match or text:match("[%p] (.+) from %w+")) then
        local player_name = match and text:match("^[%p ]*([%w_]+)") or text:match("from ([%w_]+)$")
        for players.list() as player_id do
            if shadovis(player_id).name == player_name then
                do_affected_detection(sender, "fuckchatreactions")
                break
            end
        end
    elseif sender != players.user() and commandrefs[4].translateothers.value or sender == players.user() and commandrefs[4].translateme.value then
        local translation = json.decode(http.get_response($"translate.googleapis.com/translate_a/t?client=dict%2Dchrome%2Dex&q={url.encode(text):gsub("%%20", "+")}&tl={languages[commandrefs[4][$"{tostring(sender == players.user() ? "outgoing" : "incoming")}targetlanguage"].value].key}&sl=auto", "[]"))[1]
        if translation and translation[1] and translation[2] != languages[commandrefs[4][$"{tostring(sender == players.user() ? "outgoing" : "incoming")}targetlanguage"].value].key then
            local ignore = false
            for languages as language do
                if translation[2] != language.key then continue end
                ignore = language.ignore
            break end
            if !ignore and commandrefs[4].messagenotification.value then
                util.notify($"{shadovis(sender).name}: {translation[1]}")
            end
            if !ignore and (sender == players.user() or commandrefs[4].messagemessage.value) then
                if commandrefs[4].messagemessage.value then
                    chat.send_targeted_message(players.user(), sender, translation[1], commandrefs[4].messageteam.value)
                end
                chat.send_message(sender == players.user() ? translation[1] : $"{shadovis(sender).name}: {translation[1]}", commandrefs[4].messageteam.value, false, sender == players.user() or commandrefs[4].messagenetwork.value)
            end
        end
    end
end)



function tick_handlers.commandref_positions.func()
    local list = {self = "Self>Movement", vehicle = "Vehicle>Spawner", online = "Online>New Session", players = "Players>Settings", world = "World>Places", game = "Game>Disables", stand = "Stand>Settings"}
    for tab, path in list do
        tabpositions[tab] = tabpositions[tab] == nil ? menu.rbp(path) : tabpositions[tab]
    end

    if tabpositions.current?:isValid() and !((commandref := menu.get_current_position()) and commandref:equals(tabpositions.current)) then
        tabpositions.current = nil
    end
    if menu.is_open() and tabpositions.save and tabpositions.current == nil and (commandref := menu.get_current_position()):isValid() then
        tabpositions.current, tabpositions[menu.get_commandref_tab(commandref)] = commandref, commandref
    end
end

function tick_handlers.player_main.func()
    local antimoddedotr, revealotr = commandrefs[4].antimoddedotr.value, menu.rbp("Online>Reveal Off The Radar Players").value

    for players.list() as player_id do
        local player = shadovis(player_id)
        if !(players.exists(player_id) and player?.ready) then continue end
        if !(util.in_session() and players.valid_position(player_id) and !player.antitp.timeout.state) then continue end

        if player_id == players.user() and commandrefs[4].skeleton.value and IS_PLAYER_CONTROL_ON(player_id) and !players.is_first_person(player_id) and !IS_PAUSE_MENU_ACTIVE() and players.is_visible(player_id) then
            directx.draw_ped_skeleton(players.user_ped(), colours.skeleton)
        end

        if player_id != players.user() and commandrefs[4].espdraw.value and v3.distance(players.get_position(players.user()), players.get_position(player_id)) <= commandrefs[4].espmaxdistance.value and !players.in_transition(player_id) and !IS_PLAYER_IN_CUTSCENE(player_id) and !NETWORK_IS_PLAYER_IN_MP_CUTSCENE(player_id) and !IS_PAUSE_MENU_ACTIVE() and !players.is_using_rc_vehicle(player_id) and (!players.in_interior(player_id, true) and !players.in_interior(players.user(), true) or players.get_interior_id(players.user()) == players.get_interior_id(player_id)) then
            local visible_only = commandrefs[4].espvisibleonly.value
            local visible = players.has_clear_line_of_sight(player_id, true)
            local colour = visible ? colours.playerespvisible : colours.playeresphidden
            local dimensions = directx.get_ped_dimensions(players.get_ped(player_id), true)
            local is_different = dimensions.x.low != 1 or dimensions.x.high != 0 or dimensions.y.low != 1 or dimensions.y.high != 0
            local bar = (!visible_only or visible) and commandrefs[4].esphpbar.value or 1
            local tracer = (!visible_only or visible) and commandrefs[4].esptracers.value or 1
            local box_width, total_height = (!visible_only or visible) and dimensions.x.high - dimensions.x.low + (bar == 2 or bar == 3 ? 1 / screen_dimensions.x * 10 : 0) or 0, 0
            local minimum_scale, scale_player_name = commandrefs[4].esptextminsize.value / 100, directx.get_scale_for_text_width(player.name, box_width) * 0.95
            local general_text_scale = scale_player_name < minimum_scale and minimum_scale or scale_player_name
            if is_different and bar != 1 then
                local length, health = bar == 2 or bar == 3 ? dimensions.y.high - dimensions.y.low : dimensions.x.high - dimensions.x.low, GET_ENTITY_HEALTH(players.get_ped(player_id)) - 100
                local hppercentage = length / (GET_PED_MAX_HEALTH(players.get_ped(player_id)) - 100) * (health < 0 ? 0 : health)
                local width, height, start_height, start_width

                if commandrefs[4].esphpbarbackground.value then
                    width = (bar == 2 or bar == 3) and 1 / screen_dimensions.x * 10 or length
                    height = (bar == 2 or bar == 3) and length or 1 / screen_dimensions.y * 10

                    if bar == 2 or bar == 3 then
                        width = width > ((dimensions.x.high - dimensions.x.low) * 0.4) and ((dimensions.x.high - dimensions.x.low) * 0.4) or width
                    else
                        height = height > ((dimensions.y.high - dimensions.y.low) * 0.4) and ((dimensions.y.high - dimensions.y.low) * 0.4) or height
                    end
                    start_height = bar == 2 ? dimensions.x.low - width : bar == 3 ? dimensions.x.high : dimensions.x.low
                    start_width = bar == 2 or bar == 3 ? dimensions.y.high : bar == 4 ? dimensions.y.high + height : dimensions.y.low
                    directx.draw_rect_client(start_height, start_width, width, height * -1, colours.playeresphpbarbackground.r, colours.playeresphpbarbackground.g, colours.playeresphpbarbackground.b, colours.playeresphpbarbackground.a)
                end

                width = (bar == 2 or bar == 3) and 1 / screen_dimensions.x * 10 or (hppercentage > length ? length : hppercentage)
                height = (bar == 2 or bar == 3) and (hppercentage > length ? length : hppercentage) or 1 / screen_dimensions.y * 10

                if bar == 2 or bar == 3 then
                    width = width > ((dimensions.x.high - dimensions.x.low) * 0.4) and ((dimensions.x.high - dimensions.x.low) * 0.4) or width
                else
                    height = height > ((dimensions.y.high - dimensions.y.low) * 0.4) and ((dimensions.y.high - dimensions.y.low) * 0.4) or height
                end

                start_height = bar == 2 ? dimensions.x.low - width : bar == 3 ? dimensions.x.high : dimensions.x.low
                start_width = bar == 2 or bar == 3 ? dimensions.y.high : bar == 4 ? dimensions.y.high + height : dimensions.y.low
                directx.draw_rect_client(start_height, start_width, width, height * -1, colours.playeresphpbar.r, colours.playeresphpbar.g, colours.playeresphpbar.b, colours.playeresphpbar.a)

                if commandrefs[4].esphpbaroutline.value then
                    directx.draw_line_client(bar == 3 ? dimensions.x.high : dimensions.x.low, bar == 5 ? dimensions.y.low : dimensions.y.high, bar == 2 ? dimensions.x.low - width : bar == 3 ? dimensions.x.high + width : dimensions.x.low, bar == 4 ? dimensions.y.high + height : bar == 5 ? dimensions.y.low - height : dimensions.y.high, colour.r, colour.g, colour.b, colour.a)
                    directx.draw_line_client(bar == 2 ? dimensions.x.low - width : bar == 3 ? dimensions.x.high + width : dimensions.x.low, bar == 4 ? dimensions.y.high + height : bar == 5 ? dimensions.y.low - height : dimensions.y.high, bar == 2 ? dimensions.x.low - width : bar == 3 ? dimensions.x.high + width : dimensions.x.high, bar == 4 ? dimensions.y.high + height : bar == 5 ? dimensions.y.low - height : dimensions.y.low, colour.r, colour.g, colour.b, colour.a)
                    directx.draw_line_client(bar == 2 ? dimensions.x.low - width : bar == 3 ? dimensions.x.high + width : dimensions.x.high, bar == 4 ? dimensions.y.high + height : bar == 5 ? dimensions.y.low - height : dimensions.y.low, bar == 2 ? dimensions.x.low : dimensions.x.high, bar == 4 ? dimensions.y.high : dimensions.y.low, colour.r, colour.g, colour.b, colour.a)
                    if !commandrefs[4].espbox.value then
                        directx.draw_line_client(bar == 2 ? dimensions.x.low : dimensions.x.high, bar == 4 ? dimensions.y.high : dimensions.y.low, bar == 3 ? dimensions.x.high : dimensions.x.low, bar == 5 ? dimensions.y.low : dimensions.y.high, colour.r, colour.g, colour.b, colour.a)
                    end
                end
            end
            if is_different and (!visible_only or visible) and commandrefs[4].espbox.value then
                directx.draw_ped_box(players.get_ped(player_id), colour)
            end
            if is_different and (!visible_only or visible) and commandrefs[4].espskeleton.value then
                directx.draw_ped_skeleton(players.get_ped(player_id), colour)
            end
            if is_different and (!visible_only or visible) and commandrefs[4].espnames.value then
                directx.draw_text_client(dimensions.x.low + (scale_player_name < minimum_scale ? box_width / 2 : 0) - (scale_player_name > minimum_scale and bar == 2 ? 1 / screen_dimensions.x * 10 : 0), dimensions.y.low - (bar == 5 ? 1 / screen_dimensions.y * 10 : 0), player.name, scale_player_name < minimum_scale ? ALIGN_BOTTOM_CENTRE : ALIGN_BOTTOM_LEFT, general_text_scale, colour.r, colour.g, colour.b, colour.a, false)
            end
            if is_different and (!visible_only or visible) and commandrefs[4].esphealth.value then
                local text = $"Health: {GET_ENTITY_HEALTH(players.get_ped(player_id))} / {GET_ENTITY_MAX_HEALTH(players.get_ped(player_id))}"

                local scale_text = directx.get_scale_for_text_width(text, box_width) * 0.95
                scale_text = scale_text < minimum_scale ? minimum_scale : scale_text > general_text_scale ? general_text_scale : scale_text

                local text_width, text_height = directx.get_text_size_client(text, scale_text + scale_text * 0.05)
                total_height += text_height

                directx.draw_text_client(dimensions.x.low - text_width - (bar == 2 ? 1 / screen_dimensions.x * 10 : 0) - 1 / screen_dimensions.x * 5, dimensions.y.low + total_height - (bar == 5 ? 1 / screen_dimensions.y * 10 : 0), text, ALIGN_BOTTOM_LEFT, scale_text, colour.r, colour.g, colour.b, colour.a, false)
            end
            if is_different and (!visible_only or visible) and commandrefs[4].esparmour.value then
                local text = $"Armour: {GET_PED_ARMOUR(players.get_ped(player_id))} / {GET_PLAYER_MAX_ARMOUR(player_id)}"

                local scale_text = directx.get_scale_for_text_width(text, box_width) * 0.95
                scale_text = scale_text < minimum_scale ? minimum_scale : scale_text > general_text_scale ? general_text_scale : scale_text

                local text_width, text_height = directx.get_text_size_client(text, scale_text + scale_text * 0.05)
                total_height += text_height

                directx.draw_text_client(dimensions.x.low - text_width - (bar == 2 ? 1 / screen_dimensions.x * 10 : 0) - 1 / screen_dimensions.x * 5, dimensions.y.low + total_height - (bar == 5 ? 1 / screen_dimensions.y * 10 : 0), text, ALIGN_BOTTOM_LEFT, scale_text, colour.r, colour.g, colour.b, colour.a, false)
            end
            if is_different and (!visible_only or visible) and commandrefs[4].espweaponinfo.value and (!players.get_vehicle(player_id) or IS_PLAYER_FREE_AIMING(player_id)) and (weapon_data := GET_PED_WEAPON_DATA(players.get_ped(player_id)))?.label_key then
                local weapon_name = util.get_label_text(weapon_data.label_key)

                local scale_weapon_name = directx.get_scale_for_text_width(weapon_name, box_width) * 0.95
                scale_weapon_name = scale_weapon_name < minimum_scale ? minimum_scale : scale_weapon_name > general_text_scale ? general_text_scale : scale_weapon_name

                local weapon_name_width, weapon_name_height = directx.get_text_size_client(weapon_name, scale_weapon_name + scale_weapon_name * 0.05)
                total_height += weapon_name_height

                directx.draw_text_client(dimensions.x.low - weapon_name_width - (bar == 2 ? 1 / screen_dimensions.x * 10 : 0) - 1 / screen_dimensions.x * 5, dimensions.y.low + total_height - (bar == 5 ? 1 / screen_dimensions.y * 10 : 0), weapon_name, ALIGN_BOTTOM_LEFT, scale_weapon_name, colour.r, colour.g, colour.b, colour.a, false)

                if weapon_data.category_id != 0 and weapon_data.category_id != 1 and GET_AMMO_IN_CLIP(players.get_ped(player_id), weapon_data.hash, allocated_memory[7]) then
                    local weapon_ammo = $"Ammo: {memory.read_int(allocated_memory[7])} / {GET_MAX_AMMO_IN_CLIP(players.get_ped(player_id), weapon_data.hash, 1)}"

                    local scale_weapon_ammo = directx.get_scale_for_text_width(weapon_ammo, box_width) * 0.95
                    scale_weapon_ammo = scale_weapon_ammo < minimum_scale ? minimum_scale : scale_weapon_ammo > general_text_scale ? general_text_scale : scale_weapon_ammo

                    local weapon_ammo_width, weapon_ammo_height = directx.get_text_size_client(weapon_ammo, scale_weapon_ammo + scale_weapon_ammo * 0.05)
                    total_height += weapon_ammo_height

                    directx.draw_text_client(dimensions.x.low - weapon_ammo_width - (bar == 2 ? 1 / screen_dimensions.x * 10 : 0) - 1 / screen_dimensions.x * 5, dimensions.y.low + total_height - (bar == 5 ? 1 / screen_dimensions.y * 10 : 0), weapon_ammo, ALIGN_BOTTOM_LEFT, scale_weapon_ammo, colour.r, colour.g, colour.b, colour.a, false)
                end
            end
            if is_different and (!visible_only or visible) and commandrefs[4].espgodmode.value and players.in_godmode(player_id) then
                local text = "Godmode"

                local scale_text = directx.get_scale_for_text_width(text, box_width) * 0.95
                scale_text = scale_text < minimum_scale ? minimum_scale : scale_text > general_text_scale ? general_text_scale : scale_text

                local text_width, text_height = directx.get_text_size_client(text, scale_text + scale_text * 0.05)
                total_height += text_height

                directx.draw_text_client(dimensions.x.low - text_width - (bar == 2 ? 1 / screen_dimensions.x * 10 : 0) - 1 / screen_dimensions.x * 5, dimensions.y.low + total_height - (bar == 5 ? 1 / screen_dimensions.y * 10 : 0), text, ALIGN_BOTTOM_LEFT, scale_text, colour.r, colour.g, colour.b, colour.a, false)
            end
            if is_different and (!visible_only or visible) and commandrefs[4].espdistance.value then
                local distance = $"Distance: {math.float_to_int(v3.distance(players.get_position(players.user()), players.get_position(player_id)))}"

                local scale_distance = directx.get_scale_for_text_width(distance, box_width) * 0.95
                scale_distance = scale_distance < minimum_scale ? minimum_scale : scale_distance > general_text_scale ? general_text_scale : scale_distance

                local distance_width, distance_height = directx.get_text_size_client(distance, scale_distance + scale_distance * 0.05)
                total_height += distance_height

                directx.draw_text_client(dimensions.x.low - distance_width - (bar == 2 ? 1 / screen_dimensions.x * 10 : 0) - 1 / screen_dimensions.x * 5, dimensions.y.low + total_height - (bar == 5 ? 1 / screen_dimensions.y * 10 : 0), distance, ALIGN_BOTTOM_LEFT, scale_distance, colour.r, colour.g, colour.b, colour.a, false)
            end
            if is_different and (!visible_only or visible) and tracer != 1 then
                local width, height = 1 / screen_dimensions.x * 10, 1 / screen_dimensions.y * 10
                local window = {x = tracer == 2 or tracer == 3 or tracer == 4 ? 0.5 : tracer == 6 ? 1 : 0, y = tracer == 2 or tracer == 5 or tracer == 6 ? 0.5 : tracer == 3 ? 1 : 0}
                local player_side = {
                    x = tracer == 2 or tracer == 3 or tracer == 4 ? dimensions.x.low + (dimensions.x.high - dimensions.x.low) / 2 : tracer == 5 ? dimensions.x.low - (bar == 2 ? width : 0) : dimensions.x.high + (bar == 3 ? width : 0),
                    y = tracer == 5 or tracer == 6 ? dimensions.y.low + (dimensions.y.high - dimensions.y.low) / 2 : tracer == 4 ? dimensions.y.low - (bar == 5 ? height : 0) : dimensions.y.high + (bar == 4 ? height : 0)
                }
                directx.draw_line_client(window.x, window.y, player_side.x, player_side.y, colour.r, colour.g, colour.b, colour.a)
            end
        end

        if player_id != players.user() then
            SHOW_FRIEND_INDICATOR_ON_BLIP(memory.read_int(globals[13](player_id)), player.friend or player:fakefriend())
        end

        if player_id != players.user() and (player.ghost or players.is_passive_mode(players.user()) or players.is_passive_mode(player_id) or commandrefs[4].ghostplayers.value != 1 or commandrefs[4].ghostgodmode.value or commandrefs[4].ghostvehiclegodmode.value or commandrefs[4].ghostmk2.value) then
            local vehicle = commandrefs[4].ghostvehiclegodmode.value and players.get_vehicle(player_id, false)
            local vehicle_hash = commandrefs[4].ghostmk2.value and players.get_vehicle_model(player_id)
            local state = !util.in_activity() and (commandrefs[4].ghostplayers.value == 2 or commandrefs[4].ghostplayers.value == 3 and !(player.friend or player:fakefriend()) or commandrefs[4].ghostplayers.value == 4 and (player.friend or player:fakefriend()) or commandrefs[4].ghostgodmode.value and players.in_godmode(player_id) or vehicle and entities.is_vehicle_indestructible(vehicle, false) or vehicle_hash and vehicle_hash == util.joaat("oppressor2"))
            local override = player.ghost or !player:is_org_member() and (players.is_passive_mode(players.user()) or players.is_passive_mode(player_id))
            SET_REMOTE_PLAYER_AS_GHOST(player_id, override or state)
            player.shghosted, player.ghosted = state, override
        elseif player.shghosted or player.ghosted then
            SET_REMOTE_PLAYER_AS_GHOST(player_id, players.is_passive_mode(players.user()) or players.is_passive_mode(player_id))
            player.shghosted, player.ghosted = false, false
        end

        if player_id == players.user() and commandrefs[4].forceorg.value != 1 then
            local org_type, boss = players.get_org_type(players.user()), players.get_boss(players.user())
            if boss == -1 and #players.get_orgs() > 10 then
                for players.list_except(true) as org_id do
                    if players.get_org_type(org_id) == -1 or players.get_boss(org_id) != org_id then continue end
                    memory.write_int(globals[9](org_id), -1)
                    memory.write_int(globals[10](org_id), -1)
                break end
            end
            if (commandrefs[4].forceorg.value == 4 and (org_type != -1 or boss != players.user()) or commandrefs[4].forceorg.value != 4 and org_type != (commandrefs[4].forceorg.value - 2)) and (boss == -1 and #players.get_orgs() < 9 or boss == players.user()) then
                memory.write_int(globals[9](players.user()), commandrefs[4].forceorg.value == 4 ? -1 : commandrefs[4].forceorg.value - 2)
                memory.write_int(globals[10](players.user()), players.user())
            end
        end

        if player_id == players.user() and players.get_boss(players.user()) != -1 and util.current_time_millis() >= player.org_manage_delay and (commandrefs[4].orgrainbow.value or commandrefs[4].orgcolour.value != -2 or memory.read_int(globals[12](player_id)) == -1) then
            player.org_manage_delay = util.current_time_millis() + 1000
            local org_colour = memory.read_int(globals[12](player_id))
            memory.write_int(globals[12](player_id), commandrefs[4].orgrainbow.value ? org_colour >= 14 ? 0 : org_colour + 1 : commandrefs[4].orgcolour.value != -2 ? commandrefs[4].orgcolour.value : 0)
        end

        if player_id == players.user() and commandrefs[4].bullettracers.value and GET_PED_LAST_WEAPON_IMPACT_COORD(players.user_ped(), allocated_memory[3]) then
            local weapon = GET_CURRENT_PED_WEAPON_ENTITY_INDEX(players.user_ped(), 0)
            if commandrefs[4].bullettracers.value and bone := entities.get_bone(weapon, "gun_muzzle") then
                local bone_position = GET_WORLD_POSITION_OF_ENTITY_BONE(weapon, bone)
                local vector = memory.read_vector3(allocated_memory[3])
                util.create_tick_handler(function()
                    util.wait_time(commandrefs[4].bullettracerstime.value * 10, function()
                        local on_screen1, x1, y1 = util.get_screen_position(bone_position)
                        local on_screen2, x2, y2 = util.get_screen_position(vector)
                        if !on_screen1 or !on_screen2 then return end
                        directx.draw_line_client(x1, y1, x2, y2, colours.bullettracers.r, colours.bullettracers.g, colours.bullettracers.b, colours.bullettracers.a)
                    end, true)
                    return false
                end)
            end
        end

        if IS_PLAYER_DEAD(player_id) then
            if player.dead then continue end
            player.dead = true

            execute_modules("on_death", nil, player_id)

            if player_id == players.user() and commandrefs[4].customdeathmessage.value != "" then
                util.BEGIN_TEXT_COMMAND_THEFEED_POST(commandrefs[4].customdeathmessage.value)
	            END_TEXT_COMMAND_THEFEED_POST_TICKER(0, 1)
            end
            if player.otr.blip != nil then
                SHOW_HEADING_INDICATOR_ON_BLIP(player.otr.blip, false)
                SET_BLIP_SPRITE(player.otr.blip, 274)
            end
        else
            if player.dead then
                if player_id == players.user() then
                    spawn_function()
                elseif commandrefs[4].notifyonrespawn.value then
                    local colour = players.get_org_colour(player_id)
                    util.BEGIN_TEXT_COMMAND_THEFEED_POST($"~HC_{tostring(colour != -1 ? colour + 192 : 0)}~<C>{player.name}</C> ~HC_0~respawned.")
	                END_TEXT_COMMAND_THEFEED_POST_TICKER(0, 1)
                end

                execute_modules("on_spawn", nil, player_id)
            end
            player.dead = false
            if !player.antitp.timeout.state and GET_PED_MAX_HEALTH(players.get_ped(player_id)) == 0 then
                do_affected_detection(player_id, "undeadotr")
            end

            if player_id == players.user() then
                local health = GET_ENTITY_HEALTH(players.user_ped())
                if commandrefs[4].health_mod.value == 1 and health > 328 or commandrefs[4].health_mod.value == 2 and health < 65535 or commandrefs[4].health_mod.value == 3 and health > 100 then
                    CHANGE_PED_HEALTH(players.user_ped(), commandrefs[4].health_mod.value == 2 ? 65535 : commandrefs[4].health_mod.value == 3 ? 100 : 328, true)
                    SET_PLAYER_HEALTH_RECHARGE_MULTIPLIER(players.user(), commandrefs[4].health_mod.value != 3 ? 1 : 0)
                end

                local max_health = GET_PED_MAX_HEALTH(players.user_ped())
                if commandrefs[4].undead_otr.value == true and max_health != 0 or commandrefs[4].undead_otr.value == false and max_health == 0 then
                    SET_PED_MAX_HEALTH(players.user_ped(), commandrefs[4].undead_otr.value ? 0 : 328)
                end
            elseif antimoddedotr and !revealotr and (players.is_otr(player_id) and util.current_time_millis() <= player.otr.time or GET_PED_MAX_HEALTH(players.get_ped(player_id)) == 0) then
                local blip = memory.read_int(globals[14](player_id))
                if player.otr.blip == nil then
                    player.otr.blip = ADD_BLIP_FOR_COORD(players.get_position(player_id))
                    SET_BLIP_SCALE(player.otr.blip, 0.8)
                    SET_BLIP_CATEGORY(player.otr.blip, 7)
                else
                    local colour, conversion, blip_type = players.get_org_colour(player_id), {[-1] = 0, [0] = 9, [1] = 8, [2] = 33, [3] = 12, [4] = 14, [5] = 11, [6] = 32, [7] = 10, [8] = 25, [9] = 6, [10] = 63, [11] = 69, [12] = 51, [13] = 53, [14] = 65}, players.in_interior(player_id, true) and players.get_bounty(player_id) ? 4 : players.in_interior(player_id) ? 5 : players.get_bounty(player_id) ? 0 : players.get_org_type(player_id) != -1 ? players.get_org_type(player_id) + 1 : 3
                    SET_BLIP_SPRITE(player.otr.blip, blip_type == 0 ? 303 : blip_type == 1 ? 364 : blip_type == 2 ? 348 : blip_type == 3 ? 1 : blip_type == 4 ? 418 : 417)
                    SET_BLIP_COLOUR(player.otr.blip, blip_type == 0 ? colour != -1 ? conversion[colour] : 1 : blip_type == 3 ? 0 : conversion[colour])
                    SET_BLIP_SCALE(player.otr.blip, IS_PAUSE_MENU_ACTIVE() ? 1.2 : 0.8)
                    SHOW_HEADING_INDICATOR_ON_BLIP(player.otr.blip, !players.in_interior(player_id, true) and !players.get_bounty(player_id) and players.get_org_type(player_id) == -1)
                    local distance = v3.distance(players.get_position(players.user()), players.get_position(player_id))
                    SET_BLIP_ALPHA(player.otr.blip, util.is_bigmap_active() or IS_PAUSE_MENU_ACTIVE() or distance <= 200 ? 255 : distance <= 300 ? 200 : distance <= 400 ? 175 : distance <= 500 ? 150 : distance <= 1000 ? 64 : 32)

                    BEGIN_TEXT_COMMAND_SET_BLIP_NAME("STRING")
                    ADD_TEXT_COMPONENT_SUBSTRING_PLAYER_NAME(player.name)
                    END_TEXT_COMMAND_SET_BLIP_NAME(player.otr.blip)

                    SET_BLIP_COORDS(player.otr.blip, players.get_position(player_id))
                    if blip_type == 3 then
                        SET_BLIP_ROTATION_WITH_FLOAT(player.otr.blip, GET_ENTITY_HEADING_FROM_EULERS(players.get_ped(player_id)))
                    end
                end
            elseif player.otr.blip != nil then
                util.remove_blip(player.otr.blip)
                player.otr.blip = nil
            end
        end

        local personal_vehicle = players.get_personal_vehicle(player_id)
        -- there is a possibility that the personal vehicle is just not networked anymore even though its synced to you, which is why we keep at as a "previous" one here
        if !player.previous_personal_vehicle or !DOES_ENTITY_EXIST(player.previous_personal_vehicle) or player.personal_vehicle and player.personal_vehicle != player.previous_personal_vehicle then
            player.previous_personal_vehicle = player.personal_vehicle
        end
        player.personal_vehicle = personal_vehicle

        execute_modules("on_tick", nil, player_id)
    end
end

function tick_handlers.player_teleport.func()
    if !util.in_session() then return end

    local last_position = shadovis(players.user()).antitp.position or v3.new()
    update_player_data(players.user())
    local user_data = check_player_data(players.user())

    for players.list_except(true) as player_id do
        local player = shadovis(player_id)
        player.last_seen = util.current_time_millis()
        if !user_data or global_compatibility_mode then update_player_data(player_id) check_player_data(player_id) continue end

        local attach = GET_ENTITY_ATTACHED_TO(players.user_ped())
        if !util.in_activity() and check_player_data(player_id) and (
            player.antitp.nearby and commandrefs[4].tpoyshortrange.value and
            v3.distance(v3.setZ(players.get_position(players.user()), players.get_position(players.user()).z + 1.5), players.get_position(player_id)) <= 2 and
            v3.distance(player.antitp.position, players.get_position(player_id)) >= 10 or
            not player.antitp.nearby and
            v3.distance(players.get_position(players.user()), players.get_position(player_id)) <= 25
        ) and v3.distance(last_position, players.get_position(player_id)) <= 10 and (attach == 0 or attach != GET_ENTITY_ATTACHED_TO(players.get_ped(player_id))) then
            do_affected_detection(player_id, "teleportedonyou")
        end

        update_player_data(player_id)
    end
end

function tick_handlers.player_death.func()
    for index = 0, GET_NUMBER_OF_EVENTS(1) - 1 do
        if GET_EVENT_AT_INDEX(1, index) != 186 or !GET_EVENT_DATA(1, index, allocated_memory[8], 13) then continue end -- CEventNetworkEntityDamage

        local victim, attacker, died, weapon_hash, damage = memory.read_int(allocated_memory[8]), memory.read_int(allocated_memory[8] + 1 * 8), memory.read_int(allocated_memory[8] + 5 * 8) == 1, memory.read_int(allocated_memory[8] + 6 * 8), memory.read_float(allocated_memory[8] + 2 * 8)
        local player_id, killer_id = NETWORK_GET_PLAYER_INDEX_FROM_PED(victim), NETWORK_GET_PLAYER_INDEX_FROM_PED(attacker)

        if player_id != -1 then
            damage = shadovis(player_id).ped_health == 0 or damage < shadovis(player_id).ped_health ? damage : shadovis(player_id).ped_health
            shadovis(player_id).ped_health = entities.get_health(victim)
        end

        if killer_id == players.user() and player_id != killer_id and IS_ENTITY_A_PED(victim) and commandrefs[4][died ? "killsound" : "hitsound"].value != 1 then
            play_sound_file($"{main_path}Sounds\\{sounds[commandrefs[4][died ? "killsound" : "hitsound"].value - 1]}.wav")
        end

        if killer_id != -1 and killer_id != player_id and weapon_hash == util.joaat("weapon_tranquilizer") then
            do_affected_detection(killer_id, "tranq")
            if player_id == players.user() and died then
                util.create_tick_handler(function()
                    if !IS_PLAYER_DEAD(players.user()) then return false end
                    local hash = util.joaat("a_f_m_beach_01")
                    util.request_model(hash)
                    SET_PLAYER_MODEL(players.user(), hash)
                end)
            end
        end

        if killer_id != -1 and killer_id != player_id and check_player_data(killer_id) and players.in_godmode(killer_id) then
            do_affected_detection(killer_id, "attackingwhilegodmode")    
        end

        if player_id == -1 or killer_id == -1 or player_id == killer_id then continue end
        execute_modules("on_damage", nil, player_id, killer_id, died, weapon_hash, damage)
        if !died then continue end

        local kills, deaths, killordeath = 0, 0, killer_id == players.user() ? 1 : player_id == players.user() ? 2 : 0
        local kill = shadovis(killordeath == 1 and player_id or killer_id)
        if killordeath != 0 then
            ++kill[killordeath == 1 ? "deaths" : "kills"]
            kills, deaths = kill.deaths, kill.kills
        end
        if (killordeath == 1 and commandrefs[4].killmessage.value != 1) or (killordeath == 2 and commandrefs[4].deathmessage.value != 1) then
            local int, entry = commandrefs[4][$"{killordeath == 1 ? "kill" : "death"}message"].value - 2, nil
            if int > 0 then entry = killreactions[killordeath == 1 ? 1 : 2][int] end
            local message = entry and entry[math.random(#entry)] or $"{kills} - {deaths}"
            message = message:gsub("_victimname_", kill.name) message = message:gsub("_ip_", kill.ip != 0 ? util.ip_to_string(kill.ip) : "N/A") message = message:gsub("_menuad_", killreactions[3][commandrefs[4].menuadvertisement.value].name) message = message:gsub("_linkad_", killreactions[3][commandrefs[4].menuadvertisement.value].link)
            message = message:gsub("_geoip_", players.geo_ip(kill.ip))
            util.create_tick_handler(function()
                util.wait_time(commandrefs[4].killmessagedelay.value)
                chat.send_message($"({kill.name}): {message}", false, true, false)
                chat.send_targeted_message(player_id == players.user() and killer_id or player_id, players.user(), message, false)
                return false
            end)
        end

        if check_player_data(killer_id) and players.in_godmode(killer_id) then
            do_affected_detection(killer_id, "killedsomeonewhilegodmode", true, true, $"Victim: {shadovis(player_id).name}")
        end
    end
end

function tick_handlers.detection_memory.func()
    if !(commandrefs[4].detectionmemory.value and commandrefs[4].detectionmemory_method.value == 2) then return end
    detectionmemory_scan()
end

function tick_handlers.vehicle.func()
    if !util.in_session() then return end
    local vehicle = players.get_vehicle(players.user(), true)
    if !IS_PLAYER_DEAD(players.user()) and vehicle and (previous_vehicle?.vehicle == vehicle or previous_vehicle?.vehicle == nil) then
        if previous_vehicle?.vehicle == nil then
            previous_vehicle = {
                peds = previous_vehicle.peds,
                peds_2 = previous_vehicle.peds_2,
                vehicle = vehicle,
                tyreburst = GET_VEHICLE_TYRES_CAN_BURST(vehicle),
                repair = util.current_time_millis() + 60000,
                defaultbrokenoff = 0,
                upsidedown = 0,
                seats = GET_VEHICLE_MODEL_NUMBER_OF_SEATS(entities.get_model_hash(vehicle)),
                fillcarwithpeds = nil,
                fillcarwithpedscustom = nil,
                ptfxtrail = {from = nil, effect = nil, interval = 0},
                wheel_peds = nil,
                wheel_peds_custom = nil,
                blip_coords = v3.new(),
                goal_coords = v3.new(),
                autodrive = false,
                autodrivectrl = true,
                driving_style = previous_vehicle.driving_style,
                driving_style_2 = 0,
                autodrivespeed = previous_vehicle.autodrivespeed,
                autodrivespeed_2 = 0,
                route_timeout = 0,
                autodriveautospeed = nil,
                ptfx = {}
            }
        end
        if commandrefs[4].fill_car_with_peds.value == 1 or previous_vehicle.fillcarwithpeds != commandrefs[4].fill_car_with_peds.value or previous_vehicle.fillcarwithpedscustom != commandrefs[4].fillcarwithpedsmodel.value then
            previous_vehicle.fillcarwithpeds, previous_vehicle.fillcarwithpedscustom = commandrefs[4].fill_car_with_peds.value, commandrefs[4].fillcarwithpedsmodel.value
            for i = 0, (previous_vehicle.seats - 2) do
                if previous_vehicle.peds[i]?.ped and DOES_ENTITY_EXIST(previous_vehicle.peds[i].ped) then
                    entities.delete(previous_vehicle.peds[i].ped)
                    previous_vehicle.peds[i] = {timeout = 1, ped = nil}
                else
                    previous_vehicle.peds[i] = nil
                end
            end
        end
        if previous_vehicle.ptfx?.index != commandrefs[4].ptfxtrailseffect.value or previous_vehicle.ptfx?.scale != commandrefs[4].ptfxtrailsscale.value or previous_vehicle.ptfx?.flw != commandrefs[4].ptfxtrailsflw.value or previous_vehicle.ptfx?.frw != commandrefs[4].ptfxtrailsfrw.value or previous_vehicle.ptfx?.rlw != commandrefs[4].ptfxtrailsrlw.value or previous_vehicle.ptfx?.rrw != commandrefs[4].ptfxtrailsrrw.value or previous_vehicle.ptfx?.exhaust != commandrefs[4].ptfxtrailsexhaust.value then
            previous_vehicle.ptfx.index, previous_vehicle.ptfx.scale = commandrefs[4].ptfxtrailseffect.value, commandrefs[4].ptfxtrailsscale.value
            previous_vehicle.ptfx.flw, previous_vehicle.ptfx.frw, previous_vehicle.ptfx.rlw, previous_vehicle.ptfx.rrw, previous_vehicle.ptfx.exhaust = commandrefs[4].ptfxtrailsflw.value, commandrefs[4].ptfxtrailsfrw.value, commandrefs[4].ptfxtrailsrlw.value, commandrefs[4].ptfxtrailsrrw.value, commandrefs[4].ptfxtrailsexhaust.value

            -- we do all this shit just to get different dictionaries when options have the same name
            local duplicates, filter, start_index, selected_index = 0, {}, 0, 0
            for i = 1, #ptfx_effects.small do
                if ptfx_effects.small[i] != ptfx_effects.small[previous_vehicle.ptfx.index - 1] then continue end
                start_index, selected_index = start_index == 0 and i or start_index, i == (previous_vehicle.ptfx.index - 1) ? i : selected_index
            end
            local position = selected_index - start_index + 1

            for dictionary, effects in ptfx_effects.full do
                for effects as effect do
                    if effect != ptfx_effects.small[previous_vehicle.ptfx.index - 1] then continue end
                    filter[#filter + 1] = dictionary
                    ++duplicates
                    if #filter == position then break 2 end
                break end
            end

            previous_vehicle.ptfx.dictionary, previous_vehicle.ptfx.effect = previous_vehicle.ptfx.index != 1 ? filter[position] : nil, previous_vehicle.ptfx.index != 1 ? ptfx_effects.small[previous_vehicle.ptfx.index - 1] : nil
        end
        if previous_vehicle.wheel_peds != commandrefs[4].wheel_peds.value or previous_vehicle.wheel_peds_custom != commandrefs[4].wheel_peds_model.value then
            previous_vehicle.wheel_peds, previous_vehicle.wheel_peds_custom = commandrefs[4].wheel_peds.value, commandrefs[4].wheel_peds_model.value
            for i = 1, 10 do
                if entities.get_bone(vehicle, vehicle_bones[i]) == nil then continue end
                if previous_vehicle.peds_2[i]?.ped and DOES_ENTITY_EXIST(previous_vehicle.peds_2[i].ped) then
                    entities.delete(previous_vehicle.peds_2[i].ped)
                    previous_vehicle.peds_2[i] = {timeout = 1, ped = nil}
                else
                    previous_vehicle.peds_2[i] = nil        
                end
            end
        end
        if commandrefs[4].radio_off.value and IS_VEHICLE_RADIO_ON(vehicle) then
            SET_RADIO_TO_STATION_NAME("OFF")
        end
        if previous_vehicle.fillcarwithpeds != 1 then
            for i = 0, (previous_vehicle.seats - 2) do
                if previous_vehicle.peds[i]?.timeout == nil then
                    previous_vehicle.peds[i] = {timeout = 0, ped = nil}
                end
                if IS_VEHICLE_SEAT_FREE(vehicle, i, true) then
                    if previous_vehicle.peds[i].timeout == 0 then
                        previous_vehicle.peds[i].timeout = util.current_time_millis() + 1000
                    end
                    if util.current_time_millis() < previous_vehicle.peds[i].timeout then continue end

                    if previous_vehicle.peds[i]?.ped and DOES_ENTITY_EXIST(previous_vehicle.peds[i].ped) then
                        SET_PED_INTO_VEHICLE(previous_vehicle.peds[i].ped, vehicle, i)
                    else
                        local hash, player_id;
                        if previous_vehicle.fillcarwithpeds == 4 then
                            hash = util.joaat(previous_vehicle.fillcarwithpedscustom)
                            if IS_MODEL_VALID(hash) then
                                util.request_model(hash, 1000)
                            end
                        else
                            player_id = previous_vehicle.fillcarwithpeds == 2 and players.user() or players.random_player(true, true)
                            for i_hash = 1, 2 do
                                if IS_PED_MODEL(players.get_ped(player_id), util.joaat(i_hash == 1 ? "mp_m_freemode_01" : "mp_f_freemode_01")) then
                                    hash = util.joaat(i_hash == 1 ? "mp_m_freemode_01" : "mp_f_freemode_01")
                                end
                            end
                        end

                        if not hash then continue end
                        previous_vehicle.peds[i].ped = create_ped(hash, true, false)
                        if player_id != nil then
                            CLONE_PED_TO_TARGET(players.get_ped(player_id), previous_vehicle.peds[i].ped)
                        end
                        SET_PED_INTO_VEHICLE(previous_vehicle.peds[i].ped, vehicle, i)
                    end
                else
                    previous_vehicle.peds[i].timeout = 0
                    local ped = GET_PED_IN_VEHICLE_SEAT(vehicle, i, false)
                    if ped != previous_vehicle.peds[i]?.ped and previous_vehicle.peds[i]?.ped != nil and DOES_ENTITY_EXIST(previous_vehicle.peds[i].ped) then
                        entities.delete(previous_vehicle.peds[i].ped)
                        previous_vehicle.peds[i].ped = nil
                    elseif ped == previous_vehicle.peds[i]?.ped and request_entity_control(ped, 1, false) then
                        if IS_PED_DEAD_OR_DYING(ped) then
                            entities.delete(ped)
                            previous_vehicle.peds[i] = {timeout = 1, ped = nil}
                            continue
                        end
                        CLEAR_PED_TASKS(ped)
                        SET_ENTITY_CAN_BE_DAMAGED(ped, false)
                        SET_BLOCKING_OF_NON_TEMPORARY_EVENTS(ped, true)
                        TASK_SET_BLOCKING_OF_NON_TEMPORARY_EVENTS(ped, true)
                        CHANGE_PED_HEALTH(ped, GET_ENTITY_MAX_HEALTH(ped))
                        SET_PED_CAN_BE_DRAGGED_OUT(ped, false)
                        BLOCK_ALL_SPEECH_FROM_PED(ped, true, 1)
                    end
                end
            end
        end
        if previous_vehicle.ptfx?.index != 1 then
            if !HAS_NAMED_PTFX_ASSET_LOADED(previous_vehicle.ptfx.dictionary) then REQUEST_NAMED_PTFX_ASSET(previous_vehicle.ptfx.dictionary) end
            if util.current_time_millis() >= (previous_vehicle.ptfx?.interval or 0) and HAS_NAMED_PTFX_ASSET_LOADED(previous_vehicle.ptfx.dictionary) then
                for {"wheel_lf", "wheel_rf", "wheel_lr", "wheel_rr", "exhaust"} as bone do
                    if entities.get_bone(vehicle, bone) == nil or bone == "wheel_lf" and !previous_vehicle.ptfx.flw or bone == "wheel_rf" and !previous_vehicle.ptfx.frw or bone == "wheel_lr" and !previous_vehicle.ptfx.rlw or bone == "wheel_rr" and !previous_vehicle.ptfx.rrw or bone == "exhaust" and !previous_vehicle.ptfx.exhaust then continue end
                    if bone == "exhaust" then
                        for i = 1, 16 do
                            if entities.get_bone(vehicle, i == 1 ? "exhaust" : $"exhaust_{i}") == nil then break end
                            USE_PARTICLE_FX_ASSET(previous_vehicle.ptfx.dictionary)
                            if !START_PARTICLE_FX_NON_LOOPED_ON_ENTITY_BONE(previous_vehicle.ptfx.effect, vehicle, v3.new(), v3.new(), entities.get_bone(vehicle, i == 1 ? "exhaust" : $"exhaust_{i}"), previous_vehicle.ptfx.scale / 100, false, false, false) then
                                util.notify("rate limited", false, false, true)
                            end
                        end
                    continue end
                    USE_PARTICLE_FX_ASSET(previous_vehicle.ptfx.dictionary)
                    if !START_PARTICLE_FX_NON_LOOPED_ON_ENTITY_BONE(previous_vehicle.ptfx.effect, vehicle, v3.new(), v3.new(), entities.get_bone(vehicle, bone), previous_vehicle.ptfx.scale / 100, false, false, false) and bone != "wheel_lf" then
                        util.notify("rate limited", false, false, true)
                    end
                end
                previous_vehicle.ptfx.interval = util.current_time_millis() + commandrefs[4].ptfxtrailsinterval.value
            end
        end
        if previous_vehicle.wheel_peds != 1 then
            for i = 1, 10 do
                if entities.get_bone(vehicle, vehicle_bones[i]) == nil then continue end
                if previous_vehicle.peds_2[i]?.timeout == nil then
                    previous_vehicle.peds_2[i] = {timeout = 0, ped = nil}
                end
                if previous_vehicle.peds_2[i]?.ped and DOES_ENTITY_EXIST(previous_vehicle.peds_2[i].ped) and GET_ENTITY_ATTACHED_TO(previous_vehicle.peds_2[i].ped) == vehicle then
                    previous_vehicle.peds_2[i].timeout = 0
                    if request_entity_control(previous_vehicle.peds_2[i].ped, 1, false) then
                        if IS_PED_DEAD_OR_DYING(previous_vehicle.peds_2[i].ped) then
                            entities.delete(previous_vehicle.peds_2[i].ped)
                            previous_vehicle.peds_2[i] = {timeout = 1, ped = nil}
                            continue
                        end
                        CLEAR_PED_TASKS(previous_vehicle.peds_2[i].ped)
                        SET_ENTITY_CAN_BE_DAMAGED(previous_vehicle.peds_2[i].ped, false)
                        SET_BLOCKING_OF_NON_TEMPORARY_EVENTS(previous_vehicle.peds_2[i].ped, true)
                        TASK_SET_BLOCKING_OF_NON_TEMPORARY_EVENTS(previous_vehicle.peds_2[i].ped, true)
                        CHANGE_PED_HEALTH(previous_vehicle.peds_2[i].ped, GET_ENTITY_MAX_HEALTH(previous_vehicle.peds_2[i].ped))
                        SET_PED_CAN_BE_DRAGGED_OUT(previous_vehicle.peds_2[i].ped, false)
                        BLOCK_ALL_SPEECH_FROM_PED(previous_vehicle.peds_2[i].ped, true, 1)
                    end
                else
                    if previous_vehicle.peds_2[i].timeout == 0 then
                        previous_vehicle.peds_2[i].timeout = util.current_time_millis() + 1000
                    end
                    if util.current_time_millis() < previous_vehicle.peds_2[i].timeout then continue end

                    if previous_vehicle.peds_2[i]?.ped and DOES_ENTITY_EXIST(previous_vehicle.peds_2[i].ped) then
                        ATTACH_ENTITY_TO_ENTITY(previous_vehicle.peds_2[i].ped, vehicle, entities.get_bone(vehicle, vehicle_bones[i]), v3.new(), v3.new(), false, false, false, false, 1, false, 0)
                    else
                        local hash, player_id;
                        if previous_vehicle.wheel_peds == 4 then
                            hash = util.joaat(previous_vehicle.wheel_peds_custom)
                            if IS_MODEL_VALID(hash) then
                                util.request_model(hash, 1000)
                            end
                        else
                            player_id = previous_vehicle.wheel_peds == 2 and players.user() or players.random_player(true, true)
                            for i_hash = 1, 2 do
                                if IS_PED_MODEL(players.get_ped(player_id), util.joaat(i_hash == 1 ? "mp_m_freemode_01" : "mp_f_freemode_01")) then
                                    hash = util.joaat(i_hash == 1 ? "mp_m_freemode_01" : "mp_f_freemode_01")
                                end
                            end
                        end

                        if not hash then continue end
                        previous_vehicle.peds_2[i].ped = create_ped(hash, true, false)
                        if player_id != nil then
                            CLONE_PED_TO_TARGET(players.get_ped(player_id), previous_vehicle.peds_2[i].ped)
                        end
                        ATTACH_ENTITY_TO_ENTITY(previous_vehicle.peds_2[i].ped, vehicle, entities.get_bone(vehicle, vehicle_bones[i]), v3.new(), v3.new(), false, false, false, false, 1, false, 0)
                    end
                end
            end
        end
        if commandrefs[4].autodriveenable.value or previous_vehicle.autodrive then
            local position, waypoint, objective, force_update = players.get_position(players.user()), util.get_gps_route(0), util.get_gps_route(1), false
            local gps_type = commandrefs[4].autodrivewaypoint.value and (#waypoint > 0 and 1 or players.get_waypoint_no_0(players.user()) != nil and 3) or commandrefs[4].autodriveobjective.value and #objective > 0 and 2 or 0
            local min_distance, node_distance = gps_type == 1 or gps_type == 3 ? 60 : 5, 100
            local goal_coords = gps_type == 1 ? v3.new(waypoint[#waypoint]) : gps_type == 2 ? v3.new(objective[#objective]) : gps_type == 3 ? players.get_waypoint_no_0(players.user()) : v3.new()
            local coords, nodes = gps_type == 3 and goal_coords or v3.new(), {}
            for i = 1, (gps_type == 1 ? #waypoint : gps_type == 2 ? #objective : 0) do
                local vector = v3.new(gps_type == 1 ? waypoint[i] : objective[i])
                if v3.distance(vector, position) <= 200 and type(gps_type == 1 ? waypoint[i - 1] : objective[i - 1]) == "table" then
                    nodes[#nodes + 1] = v3.distance(vector, v3.new(gps_type == 1 ? waypoint[i - 1] : objective[i - 1]))
                end
                if i == 1 or v3.distance(vector, position) <= node_distance then
                    if type(gps_type == 1 ? waypoint[i + 1] : objective[i + 1]) == "table" and (vector := v3.new(gps_type == 1 ? waypoint[i + 1] : objective[i + 1])) and (distance := v3.distance(vector, position)) > node_distance then
                        coords, force_update = vector, (distance - 60) >= node_distance and v3.distance(vector, previous_vehicle.blip_coords) > 0.1
                    else
                        coords = vector
                    end
                end
            end
            local distance_coords = gps_type == 1 ? players.get_waypoint_no_0(players.user()) : goal_coords
            position.z = distance_coords.z
            local distance = math.round(v3.distance(distance_coords, position))
            if gps_type != 0 and commandrefs[4].autodriveoverlay.value then
                if commandrefs[4].autodrivedraw.value != 3 then
                    directx.draw_text_with_shadow(commandrefs[4].textpositionautodrivex.value, commandrefs[4].textpositionautodrivey.value, $"Auto-Drive{tostring(gps_type != 0 and $" ({math.float_to_int(distance)})" or "")} [CTRL]: {tostring(previous_vehicle.autodrivectrl and "On" or "Off")}", ALIGN_CENTRE, 1, colours.autodrive, commandrefs[4].autodrivedraw.value == 2 ? commandrefs[4].shadowdepth.value : 0)
                else
                    directx.draw_text_with_outline(commandrefs[4].textpositionautodrivex.value, commandrefs[4].textpositionautodrivey.value, $"Auto-Drive{tostring(gps_type != 0 and $" ({math.float_to_int(distance)})" or "")} [CTRL]: {tostring(previous_vehicle.autodrivectrl and "On" or "Off")}", ALIGN_CENTRE, 1, colours.autodrive, colours.autodriveoutline)
                end
            end
            if (!commandrefs[4].autodriveenable.value or gps_type == 0 or !previous_vehicle.autodrivectrl) and previous_vehicle.autodrive then
                util.notify("[Auto-Drive] Now disabled.")
                previous_vehicle.autodrive = false
                CLEAR_PED_TASKS(players.user_ped())
                SET_PED_INTO_VEHICLE(players.user_ped(), vehicle, -1)
            elseif gps_type != 0 and previous_vehicle.autodrivectrl then
                if previous_vehicle.autodrive and commandrefs[4].autodrivebeacon.value != 1 then
                    util.draw_ar_beacon(commandrefs[4].autodrivebeacon.value == 2 ? coords : distance_coords)
                end
                if commandrefs[4].autodriveinput.value and distance > min_distance and !(chat.is_open() or menu.command_box_is_open()) and (util.is_key_pressed("w") or util.is_key_pressed("s") or util.is_key_pressed("a") or util.is_key_pressed("d")) then
                    previous_vehicle.autodrivectrl = false
                end
                if previous_vehicle.autodrive and commandrefs[4].autodrivedisablecollision.value then
                    for entities.get_all_vehicles_as_pointers() as pointer do
                        local pointer_position = entities.get_position(pointer)
                        if v3.distance(players.get_position(players.user()), pointer_position) > 30 then continue end
                        local handle = entities.pointer_to_handle(pointer)
                        if handle == vehicle then continue end
                        SET_ENTITY_NO_COLLISION_ENTITY(handle, vehicle, true)
                    end
                end
                if gps_type != 0 and distance > min_distance and (!previous_vehicle.autodrive or v3.distance(distance_coords, previous_vehicle.goal_coords) > 1 and util.current_time_millis() >= (previous_vehicle.route_timeout  + 100) or v3.distance(coords, previous_vehicle.blip_coords) > 0.1 and util.current_time_millis() >= (previous_vehicle.route_timeout  + 1000) or GET_IS_TASK_ACTIVE(players.user_ped(), 159) or force_update or previous_vehicle.driving_style != previous_vehicle.driving_style_2 or previous_vehicle.autodrivespeed != previous_vehicle.autodrivespeed_2 or previous_vehicle.autodriveautospeed != commandrefs[4].autodriveautospeed.value) and ((chat.is_open() or menu.command_box_is_open()) or !(util.is_key_pressed("w") or util.is_key_pressed("s") or util.is_key_pressed("a") or util.is_key_pressed("d"))) then
                    util.notify(previous_vehicle.autodrive and "[Auto-Drive] Changing route." or "[Auto-Drive] Now enabled.", false, false, previous_vehicle.driving_style == previous_vehicle.driving_style_2 and previous_vehicle.autodrivespeed == previous_vehicle.autodrivespeed_2 and (!previous_vehicle.autodrive or v3.distance(distance_coords, previous_vehicle.goal_coords) > 1))
                    previous_vehicle.autodrive, previous_vehicle.driving_style_2, previous_vehicle.autodrivespeed_2, previous_vehicle.route_timeout, previous_vehicle.autodriveautospeed = true, previous_vehicle.driving_style, previous_vehicle.autodrivespeed, util.current_time_millis(), commandrefs[4].autodriveautospeed.value
                    local average_distance = gps_type != 3 and previous_vehicle.autodriveautospeed ? average_from_list(nodes) : math.huge
                    local adjusted_speed = gps_type != 3 and previous_vehicle.autodriveautospeed ? (average_distance <= 8 ? 10 : average_distance <= 10 ? 20 : average_distance <= 15 ? 40 : average_distance <= 20 ? 60 : previous_vehicle.autodrivespeed < 5 ? 5 : previous_vehicle.autodrivespeed) : previous_vehicle.autodrivespeed
                    SET_DRIVER_ABILITY(players.user_ped(), 1.0)
                    TASK_VEHICLE_DRIVE_TO_COORD_LONGRANGE(players.user_ped(), vehicle, coords, adjusted_speed, previous_vehicle.driving_style, 5.0)
                elseif distance <= min_distance and previous_vehicle.autodrive then
                    util.notify("[Auto-Drive] You've arrived at your destination.")
                    previous_vehicle.autodrive = false
                    BRING_VEHICLE_TO_HALT(vehicle, 3.0, 1, false)
                    CLEAR_PED_TASKS(players.user_ped())
                end
            end

            local change = util.is_key_just_pressed("left control") and !(!previous_vehicle.autodrivectrl and (util.is_key_pressed("w") or util.is_key_pressed("s") or util.is_key_pressed("a") or util.is_key_pressed("d")))
            previous_vehicle.autodrivectrl = change and !(chat.is_open() or menu.command_box_is_open()) ? !previous_vehicle.autodrivectrl : previous_vehicle.autodrivectrl
            previous_vehicle.blip_coords = change ? v3.new() : coords
            previous_vehicle.goal_coords = distance_coords
        end

        execute_modules("driving_vehicle", nil, vehicle)
    else
        if previous_vehicle?.vehicle and DOES_ENTITY_EXIST(previous_vehicle.vehicle) and request_entity_control(previous_vehicle.vehicle) then
            if previous_vehicle.fillcarwithpeds != 1 then
                for previous_vehicle.peds as seat do
                    if seat?.ped and DOES_ENTITY_EXIST(seat.ped) then
                        entities.delete(seat.ped)
                    end
                    seat = nil
                end
            end
            if previous_vehicle.wheel_peds != 1 then
                for previous_vehicle.peds_2 as ped do
                    if ped?.ped and DOES_ENTITY_EXIST(ped.ped) then
                        entities.delete(ped.ped)
                    end
                    ped = nil
                end
            end
        end
        previous_vehicle.vehicle = nil
    end
end

function tick_handlers.session.func()
    local function transition_broken(): bool
        return memory.read_int(globals[5]()) == 66 and players.exists(players.user()) and !players.exists(players.get_host()) and !players.exists(players.get_script_host())
    end

    local function sh_broken(): bool
        return util.in_session() and players.exists(players.user()) and players.exists(players.get_host()) and !players.exists(players.get_script_host())
    end

    local function fix_model(): void
        if gender != -1 and !(gender == 0 and IS_PED_MODEL(players.user_ped(), util.joaat("mp_m_freemode_01")) or gender == 1 and IS_PED_MODEL(players.user_ped(), util.joaat("mp_f_freemode_01"))) then
            util.request_model(util.joaat(gender == 0 ? "mp_m_freemode_01" : "mp_f_freemode_01"), 1000)
            SET_PLAYER_MODEL(players.user(), util.joaat(gender == 0 ? "mp_m_freemode_01" : "mp_f_freemode_01"))
        end
    end

    if players.exists(players.get_host()) and players.get_host() != players.user() and commandrefs[4].ihatebe.value != 1 then
        if commandrefs[4].ihatebe.value == 3 then
            if ihatebe.player_id != nil and ihatebe.player_id != players.get_host() and players.exists(players.get_host()) and !util.is_session_transition_active() then
                ihatebe.sss, ihatebe.wsc, ihatebe.ss = menu.rbp("Online>Transitions>Seamless Session Switching>Seamless Session Switching").value, menu.rbp("Online>Transitions>Seamless Session Switching>World State Change"):getState(), menu.ref_by_path("Online>Transitions>Skip Swoop Down").value
                menu.rbp("Online>Transitions>Seamless Session Switching>Seamless Session Switching").value = true
                menu.rbp("Online>Transitions>Seamless Session Switching>World State Change"):setState("Deferred")
                menu.ref_by_path("Online>Transitions>Skip Swoop Down").value = true
                while !{util.get_session_code()}[2] or ihatebe.sc == {util.get_session_code()}[2] do util.yield() end
                local sessioncode = {util.get_session_code()}[2]
                menu.rbp("Online>Session>Be Alone"):trigger()
                while !{util.get_session_code()}[2] or sessioncode == {util.get_session_code()}[2] do util.yield() end
                menu.rbp("Online>Session>Session Code>Join Session Via Code"):trigger(sessioncode)
            elseif ihatebe.sss != nil and ihatebe.wsc != nil and ihatebe.ss != nil and util.in_session() then
                menu.rbp("Online>Transitions>Seamless Session Switching>Seamless Session Switching").value = ihatebe.sss
                menu.rbp("Online>Transitions>Seamless Session Switching>World State Change"):setState(ihatebe.wsc)
                menu.ref_by_path("Online>Transitions>Skip Swoop Down").value = ihatebe.ss
                ihatebe.sss, ihatebe.wsc, ihatebe.ss = nil, nil, nil
            end
        end
        ihatebe.player_id = players.exists(players.get_host()) and players.get_host() != players.user() ? players.get_host() : nil
        ihatebe.sc = ihatebe.player_id != nil ? {util.get_session_code()}[2] : nil
        if ihatebe.player_id != nil then
            menu.rbrp(menu.pr(players.get_host()), "Network Events>Block").value, menu.rbrp(menu.pr(players.get_host()), "Outgoing Syncs>Block").value = true, true
            if util.in_session() and players.get_script_host() == ihatebe.player_id then
                menu.rbrp(menu.pr(players.user()), "Friendly>Give Script Host"):trigger()
            end
        end
    end

    if util.on_call() then
        if commandrefs[4].groupoverride.value and menu.rbp("Online>Transitions>Join Group Override"):getState() != "Don't Override" then
            menu.rbp("Online>Transitions>Join Group Override"):setState("Don't Override")
        end
        fix_model()
    elseif commandrefs[4].groupoverride.value and (memory.read_int(globals[5]()) != 66 or util.in_session() and !util.in_activity()) and menu.rbp("Online>Transitions>Join Group Override"):getState() != "Spectator" then
        menu.rbp("Online>Transitions>Join Group Override"):setState("Spectator")
    end

    local frontend, activity = GET_CURRENT_FRONTEND_MENU_VERSION() == util.joaat("FE_MENU_VERSION_CORONA"), util.in_activity() and players.cam_in_clouds(players.user())
    if commandrefs[4].lockweapons.value then
        menu.rbp("Self>Weapons>Lock Weapons>Lock Weapons").value = !(frontend or util.in_activity())
    end
    if commandrefs[4].lockoutfit.value then
        menu.rbp("Self>Appearance>Outfit>Lock Outfit").value = !(frontend or util.in_activity())
    end

    if util.in_sp() or memory.read_int(globals[5]()) != 66 then
        tick_handlers.session.state = 0
    elseif commandrefs[4].fixtransitions.value and transition_broken() and util.wait_time(3, function() return !transition_broken() end) then
        -- DANGER ZONE :)
        memory.write_int(globals[5](), 20)
        while !players.exists(players.get_script_host()) do
            util.yield()
        end
        memory.write_int(globals[5](), 25)
        util.wait_time(3)
        memory.write_int(globals[5](), 26)
        if !players.cam_in_clouds(players.user()) then
            while !players.cam_in_clouds(players.user()) and !IS_PLAYER_CONTROL_ON(players.user()) do
                util.yield()
            end
        end
        while !players.is_visible(players.user()) and !IS_PLAYER_CONTROL_ON(players.user()) do
            util.yield()
        end
        memory.write_int(globals[5](), 27)
        while v3.distance(players.get_position(players.user()), players.get_cam_pos(players.user())) > 30 and !IS_PLAYER_CONTROL_ON(players.user()) do
            util.yield()
        end
        memory.write_int(globals[5](), 66)
    elseif frontend or activity or tick_handlers.session?.state != 2 and !commandrefs[4].fixtransitions.value and transition_broken() and util.wait_time(3, function() return !transition_broken() end) then
        tick_handlers.session.state, tick_handlers.session.int = frontend or activity ? 1 : 2, math.huge
        if frontend then fix_model() end
        if commandrefs[4].lockweapons.value and (frontend or activity) then
            menu.rbp("Self>Weapons>Lock Weapons>Lock Weapons").value = false
        end
    elseif (tick_handlers.session?.state == 1 or tick_handlers.session?.state == 2) and !IS_PLAYER_CONTROL_ON(players.user()) then
        tick_handlers.session.int = util.current_time_millis() + 3000
    elseif (tick_handlers.session?.state == 1 or tick_handlers.session?.state == 2) and util.current_time_millis() >= (tick_handlers.session?.int or math.huge) or tick_handlers.session?.state == 3 and IS_PLAYER_CONTROL_ON(players.user()) then
        if tick_handlers.session.state == 2 then
            kleptomaniac = util.current_time_millis() + 30000
            execute_modules("transition_finished")
        end

        tick_handlers.session.state, tick_handlers.session.int = 0, math.huge
        execute_modules("on_spawn", nil, players.user())
        util.create_tick_handler(function()
            spawn_function(true)
            return false
        end)
    elseif commandrefs[4].restartonnosh.value and sh_broken() and util.wait_time(5, function() return !sh_broken() end) then
        util.notify("Restarting freemode script because there is no script host.", false, true, true)
        menu.rbp("Online>Session>Restart Freemode Script"):trigger()
    end
end

function tick_handlers.vks.func()
    for virtual_keycodes as vk do
        virtual_keycode_states[vk[2]] = {previous = virtual_keycode_states[vk[2]]?.current or false, current = util.is_key_down(vk[2])}
    end

    local screen_dimension_x, screen_dimension_y = directx.get_client_size()
    if screen_dimension_x != screen_dimensions.x or screen_dimension_y != screen_dimensions.y then
        for commandrefs[4].root_textpositions:getChildren() as commandref do
            if !commandref:isValid() then continue end
            local characters = commandref.menu_name:split("")
            local xory = characters[#characters]:lower()
            local ratio = 1 / (xory == "x" and screen_dimensions.x or screen_dimensions.y) * commandref.value
            commandref.value, commandref.max_value = math.round((xory == "x" and screen_dimension_x or screen_dimension_y) * ratio), (xory == "x" and screen_dimension_x or screen_dimension_y)
        end
        screen_dimensions.x, screen_dimensions.y = screen_dimension_x, screen_dimension_y
    end

    if util.current_time_millis() < tick_handlers.vks.filelisttime then return end
    tick_handlers.vks.filelisttime = util.current_time_millis() + 5000

    for {"ped_transformations", "ptfx", "third_party_detections", "players"} as file_name do
        if !filesystem.exists($"{main_path}{file_name}.txt") or !filesystem.is_regular_file($"{main_path}{file_name}.txt") or (tick_handlers.vks.fileupdatetimes[file_name] or 0) == io.writetime($"{main_path}{file_name}.txt") then continue end
        tick_handlers.vks.fileupdatetimes[file_name] = io.writetime($"{main_path}{file_name}.txt")
        if !script_start then continue end
        if file_name == "players" then
            playerinfo = json.decode(read_file($"{main_path}{file_name}.txt", "{}"))
        elseif file_name == "ped_transformations" then
            local new_list = {}
            for key, value in util.read_colons_and_tabs_file($"{main_path}{file_name}.txt") do
                new_list[key] = util.joaat(value)
            end
            ped_transformations = new_list
        elseif file_name == "ptfx" then
            local new_list = {small = {}, full = {}}
            for dictionary, effects in json.decode(read_file($"{main_path}{file_name}.txt", "{}")) do
                if type(new_list.full[dictionary]) != "table" then
                    new_list.full[dictionary] = {}
                end
                for effects as effect do
                    new_list.small[#new_list.small + 1], new_list.full[dictionary][#new_list.full[dictionary] + 1] = effect, effect
                end
            end
            new_list.small = table.sort(new_list.small, |a, b| -> a:lower() < b:lower())
            ptfx_effects = new_list

            commandrefs[4].ptfxtrailseffect:setListActionOptions(menu.table_to_list(ptfx_effects.small, "None"))
        elseif file_name == "third_party_detections" then
            possible_detections = json.decode(read_file($"{main_path}{file_name}.txt", "{}"))

            for commandrefs[4].root_detectionmemory_thirdpartydetections:getChildren() as commandref do
                if !commandref?:isValid?() then continue end
                commandref:delete()
            end

            for commandrefs[4].root_customreactions:getChildren() as commandref do
                if !commandref?:isValid?() then continue end
                commandref:delete()
            end

            for possible_detections as detection do
                generic_detections[detection] = generic_detections[detection] == nil ? false : generic_detections[detection]
                commandrefs[4].root_detectionmemory_thirdpartydetections:toggle(detection, {}, "", function(state) generic_detections[detection] = state end, generic_detections[detection])

                detections[$"possible_detection_{detection}"] = type(detections[$"possible_detection_{detection}"]) == "nil" ? {name = detection, description = "", reason = $"for triggering {detection}", reactions = {note = detection, addnote = 3, blockjoins = 3, track = 3, timeout = 3, block = 3, kick = 3, crash = 3}} : detections[$"possible_detection_{detection}"]
                create_detection_commands($"possible_detection_{detection}", commandrefs[4].root_customreactions)
            end
        end

        util.notify($"File \"{file_name}\" was updated.", false, true, true)
    end

    local list_modules, list_sounds, list_outfits, list_macros = filesystem.list_files($"{main_path}Modules"), filesystem.list_files($"{main_path}Sounds"), filesystem.list_files($"{filesystem.stand_dir()}Outfits"), filesystem.list_files($"{main_path}Macros")

    new_list, all_match = {}, #list_modules == #modules
    for list_modules as path do
        local filter, found = io.filename(path), false
        new_list[#new_list + 1] = filter
        for modules as name do
            if filter != name then continue end
            found = true
        break end
        if !found then
            if !(commandrefs[4]?.modules_divider and commandrefs[4].modules_divider:isValid()) then
                commandrefs[4].modules_divider = commandrefs[4].root_modules:divider("Modules")
            end

            commandrefs[4][$"root_module_{filter}"] = commandrefs[4].root_modules:list(filter, {}, "")

            commandrefs[4][$"root_module_{filter}_load"] = commandrefs[4][$"root_module_{filter}"]:action("Load", {}, "", function()
                if load_module(filter) then
                    commandrefs[4][$"root_module_{filter}_load"].visible = false
                    commandrefs[4][$"root_module_{filter}_load"].menu_name = "Start"
                    commandrefs[4][$"root_module_{filter}_stop"].visible = true
                end
            end)

            commandrefs[4][$"root_module_{filter}_stop"] = commandrefs[4][$"root_module_{filter}"]:action("Stop", {}, "This will only return functions from running, it will not unload them.", function()
                stop_module(filter)
                commandrefs[4][$"root_module_{filter}_stop"].visible = false
                commandrefs[4][$"root_module_{filter}_load"].visible = true
            end)

            commandrefs[4][$"root_module_{filter}_autoload"] = commandrefs[4][$"root_module_{filter}"]:toggle("Auto-Load", {}, "", function(state)
                if state and commandrefs[4][$"root_module_{filter}_load"]:isValid() and commandrefs[4][$"root_module_{filter}_load"].visible then
                    commandrefs[4][$"root_module_{filter}_load"]:trigger()
                end
            end)

            commandrefs[4][$"root_module_{filter}_stop"].visible = false
            commandrefs[4][$"root_module_{filter}_autoload"].value = module_functions.autoload[filter] != nil or false
        end
        all_match = all_match ? found : false
    end
    for modules as module do
        local found = false
        for new_list as name do
            if module != name then continue end
            found = true
        break end
        if !found then
            stop_module(module)
            commandrefs[4][$"root_module_{module}"]?:delete?()
        end
    end
    if !all_match then
        modules = new_list
        util.notify("Automatically updated module list.", false, false, script_start)
    end

    local new_list, all_match = {}, #list_sounds == #sounds
    for list_sounds as path do
        local filter, found = io.filename(path), false
        new_list[#new_list + 1] = filter
        for sounds as name do
            if filter != name then continue end
            found = true
        break end
        all_match = all_match ? found : false
    end
    if !all_match then
        sounds = new_list

        local value, found = commandrefs[4].hitsound:getState(), false
        for sounds as name do
            if value != name then continue end
            found = true
        break end
        commandrefs[4].hitsound:setListActionOptions(menu.table_to_list(sounds, "Disabled"))
        if found then
            commandrefs[4].hitsound:setState(value)
        else
            commandrefs[4].hitsound.value = 1
        end

        local value, found = commandrefs[4].killsound:getState(), false
        for sounds as name do
            if value != name then continue end
            found = true
        break end
        commandrefs[4].killsound:setListActionOptions(menu.table_to_list(sounds, "Disabled"))
        if found then
            commandrefs[4].killsound:setState(value)
        else
            commandrefs[4].killsound.value = 1
        end

        util.notify("Automatically updated sound list.", false, false, script_start)
    end

    new_list, all_match = {}, #list_outfits == #outfits
    for list_outfits as path do
        local filter, found = io.filename(path), false
        new_list[#new_list + 1] = filter
        for outfits as name do
            if filter != name then continue end
            found = true
        break end
        all_match = all_match ? found : false
    end
    if !all_match then
        outfits = new_list
        local value, found = commandrefs[4].outfit_changer:getState(), false
        for outfits as name do
            if value != name then continue end
            found = true
        break end
        commandrefs[4].outfit_changer:setListActionOptions(menu.table_to_list(outfits, "None"))
        if found then
            commandrefs[4].outfit_changer:setState(value)
        else
            commandrefs[4].outfit_changer.value = 1
        end
        util.notify("Automatically updated outfit list.", false, false, script_start)
    end

    new_list, all_match = {}, #list_macros == #macros
    for list_macros as path do
        local filter, found = path, false
        local macro = json.decode(read_file(path, "{macro = {}}"))
        macro.path, macro.name = path, io.filename(path)
        macro.name = macro.name[-1] == "\\" ? "[EMPTY]" : macro.name
        new_list[#new_list + 1] = macro
        for macros as name do
            if macro.path != name?.path then continue end
            found = true
        break end
        if !found then
            macro.commandref = commandrefs[4].root_macros:action(macro.name, {$"macro{macro.name}"}, macro?.description or "", || -> execute_macro(macro.path), function()
                util.yield(100)
                execute_macro(macro.path)
            end)
        end
        all_match = all_match ? found : false
    end
    for macros as macro do
        local found = false
        for new_list as filter do
            if macro.path != filter?.path then continue end
            found = true
        break end
        if !found and macro?.commandref?:isValid?() then
            macro.commandref?:delete?()
        end
    end
    if !all_match then
        macros = new_list
        util.notify("Automatically updated macro list.", false, false, script_start)
    end
end

for handler_name, handler in tick_handlers do
    if type(handler?.func) != "function" then continue end
    util.create_tick_handler(function()
        try
            handler.func()
        catch error then
            util.notify(error, commandrefs[4].reportlooperrors.value, commandrefs[4].reportlooperrors.value, commandrefs[4].reportlooperrors.value)
        end
    end)
end



local end_time = util.current_time_millis()
util.yield(100)
script_start = menu.get_version().game == game_version

util.notify($"[SHADOVIS] Loaded in: {end_time - start_time} ms.{commandrefs[4].reportloadingtime.value == 3 and $"\nLibraries: {start_time_values - start_time} ms.\nValues: {start_time_functions - start_time_values} ms.\nFunctions: {start_time_commands - start_time_functions} ms.\nCommands: {start_time_hooks - start_time_commands} ms.\nHooks: {end_time - start_time_hooks} ms." or ""}", false, true, commandrefs[4].reportloadingtime.value != 1)
spawn_function()
if commandrefs[4].detectionmemory.value and commandrefs[4].detectionmemory_method.value == 1 then detectionmemory_scan() end

if async_http.have_access() and (commandrefs[4].updatescript.value or commandrefs[4].updatedependencies.value) then
    local config = update_config
    config.dependencies = commandrefs[4].updatedependencies.value ? update_config.dependencies : {}
    if commandrefs[4].updatescript.value and !lua_version:endswith("-dev") then
        updater.run_auto_update(config)
    elseif commandrefs[4].updatedependencies.value and !lua_version:endswith("-dev") then
        for update_config.dependencies as dependency do
            config.source_url = dependency.source_url
            config.script_relpath = dependency.script_relpath
        break end
        config.auto_restart = false
        updater.run_auto_update(config)
    end
end

for playerinfo as player_information do -- preload friends
    if !player_information?.friend or !player_information?.name then continue end
    functions.queue_function("ref_by_path", 0, function()
        if !menu.ref_player_history(player_information.name):isValid() then return end
        menu.ref_player_history(player_information.name):getState()
    end)
end
